<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crucigrama de Frutas</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(to bottom, #6366f1, #a5b4fc);
            min-height: 100vh;
        }

       .header {
            background-color: #4338ca;
            color: white;
            padding: 10px 15px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
      .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

          .timer-mini {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .timer-mini.warning {
            background-color: #f59e0b;
            border-color: #f59e0b;
            animation: pulse 1s infinite;
        }
.timer-mini-icon {
            font-size: 12px;
        }
.crossword-container {
    background-color: #e0f2fe;
    padding: 15px;
    border-radius: 10px;
    margin: 0 auto;
    max-width: 600px; /* Reducido de 800px a 600px para ver mejor la foto */
}

.grid-container {
    overflow-x: auto;
    overflow-y: auto; /* Cambiado de hidden a auto para permitir scroll vertical */
    padding: 15px;
    margin: 20px 0;
    border-radius: 8px;
    background-color: rgba(255, 255, 255, 0.1);
    max-height: 500px; /* A√±adido l√≠mite de altura para activar scroll vertical */
    border: 2px solid rgba(255, 255, 255, 0.2); /* Borde sutil */
}

/* Personalizar la barra de scroll horizontal */
.grid-container::-webkit-scrollbar:horizontal {
    height: 10px;
}

.grid-container::-webkit-scrollbar-track:horizontal {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:horizontal {
    background: #4338ca;
    border-radius: 5px;
}

/* Personalizar la barra de scroll vertical */
.grid-container::-webkit-scrollbar:vertical {
    width: 10px;
}

.grid-container::-webkit-scrollbar-track:vertical {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:vertical {
    background: #4338ca;
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:hover {
    background: #3730a3;
}

/* Esquina del scroll */
.grid-container::-webkit-scrollbar-corner {
    background: rgba(0, 0, 0, 0.1);
}

        .fruit-display {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #4338ca;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            gap: 20px;
        }

       .fruit-image {
            width: 100px;
            height: 100px;
            border-radius: 10px;
            object-fit: cover;
            border: 3px solid white;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

 .fruit-image:hover {
            transform: scale(1.05);
        }

          .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }
        
         .modal-image {
            max-width: 90%;
            max-height: 90%;
            border-radius: 15px;
            border: 5px solid white;
            object-fit: contain;
            animation: zoomIn 0.3s ease;
        }

            @keyframes zoomIn {
            from {
                transform: scale(0.3);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
        }

        .close-modal:hover {
            color: #ff6b6b;
        }

        .zoom-hint {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            pointer-events: none;
        }

        .fruit-info {
            text-align: center;
        }

        .fruit-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .fruit-instruction {
            font-size: 16px;
            opacity: 0.9;
        }

.grid {
    display: grid;
    grid-template-columns: repeat(18, 40px);
    grid-template-rows: repeat(19, 40px);
    gap: 2px;
    margin: 0;
    justify-content: start;
    min-width: calc(18 * 40px + 34px);
    min-height: calc(19 * 40px + 36px); /* A√±adido altura m√≠nima */
}

.cell {
    width: 40px;
    height: 40px;
    border: 2px solid #333;
    text-align: center;
    font-weight: bold;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}


       .white {
    background-color: #f8fafc;
}

        .green {
            background-color: #86efac;
            border: 3px solid #22c55e;
        }

        .blue {
            background-color: #93c5fd;
        }

        .blocked {
            background-color: #64748b;
        }

        .filled {
            background-color: #f3f4f6;
            color: #374151;
            font-weight: bold;
        }


        input[type="text"] {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            background: transparent;
            text-transform: uppercase;
        }

        .green input[type="text"] {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .correct {
            background-color: #f3f70f !important;
            color: white;
        }

  @media (max-width: 1024px) {
    .crossword-container {
        max-width: 95%;
        padding: 12px;
    }
    
    .grid-container {
        max-height: 450px; /* Reducido para tablets */
        padding: 12px;
    }
    
    .grid {
        grid-template-columns: repeat(18, 35px);
        grid-template-rows: repeat(19, 35px);
        gap: 1px;
        min-width: calc(18 * 35px + 17px);
        min-height: calc(19 * 35px + 18px);
    }
    
    .cell {
        width: 35px;
        height: 35px;
        font-size: 13px;
    }
    
    input[type="text"] {
        font-size: 13px;
    }
}
@media (max-width: 768px) {
    body {
        padding: 5px;
    }
    
    .crossword-container {
        padding: 10px;
        max-width: 100%;
    }

    .header-right {
        gap: 5px;
    }

    .timer-mini {
        font-size: 10px;
        padding: 3px 6px;
    }

    .grid-container {
        margin: 10px 0;
        padding: 8px;
        max-height: 350px; /* Reducido para m√≥viles */
    }

    .grid {
        grid-template-columns: repeat(18, 28px);
        grid-template-rows: repeat(19, 28px);
        gap: 1px;
        min-width: calc(18 * 28px + 17px);
        min-height: calc(19 * 28px + 18px);
    }
    
    .cell {
        width: 28px;
        height: 28px;
        font-size: 12px;
    }
    
    input[type="text"] {
        font-size: 12px;
    }
    
    .fruit-display {
        flex-direction: column;
        gap: 10px;
        padding: 15px;
    }
    
    .fruit-image {
        width: 80px;
        height: 80px;
    }

    .modal-image {
        max-width: 95%;
        max-height: 95%;
    }

    .close-modal {
        top: 10px;
        right: 15px;
        font-size: 30px;
    }
    
    .fruit-name {
        font-size: 20px;
    }

    /* Barras de scroll m√°s delgadas en m√≥vil */
    .grid-container::-webkit-scrollbar:horizontal {
        height: 8px;
    }
    
    .grid-container::-webkit-scrollbar:vertical {
        width: 8px;
    }
}
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .timer-icon {
            font-size: 20px;
        }

   faouzielhilali/Documents/cruci.html */
/* ...existing code... */

/* Teclado Virtual */
.virtual-keyboard {
    background-color: #2d3748;
    padding: 15px;
    border-radius: 15px;
    margin: 20px auto;
    max-width: 600px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    border: 2px solid #4a5568;
}

.keyboard-row {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 8px;
}

.keyboard-row:last-child {
    margin-bottom: 0;
}

.key {
    background: linear-gradient(145deg, #4a5568, #2d3748);
    color: white;
    border: 2px solid #4a5568;
    border-radius: 8px;
    width: 50px;
    height: 50px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    text-transform: lowercase;
    user-select: none;
}

.key:hover {
    background: linear-gradient(145deg, #5a6478, #3d4758);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

.key:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    background: linear-gradient(145deg, #3d4758, #2d3748);
}

.key.special {
    background: linear-gradient(145deg, #6366f1, #4338ca);
    border-color: #4338ca;
    font-size: 18px;
}

.key.special:hover {
    background: linear-gradient(145deg, #7c3aed, #5b21b6);
}

.key.backspace {
    width: 60px;
}

/* Responsive para teclado */
@media (max-width: 768px) {
    .virtual-keyboard {
        max-width: 95%;
        padding: 12px;
    }
    
    .keyboard-row {
        gap: 6px;
        margin-bottom: 6px;
    }
    
    .key {
        width: 40px;
        height: 40px;
        font-size: 14px;
    }
    
    .key.backspace {
        width: 50px;
    }
}

@media (max-width: 480px) {
    .key {
        width: 35px;
        height: 35px;
        font-size: 12px;
    }
    
    .key.backspace {
        width: 45px;
    }
}

/* ...existing code... */     
        /* A√±adir este estilo para la clase separator */
.separator {
    background-color: #1f2937 !important;
    color: white !important;
    border: 3px solid #374151 !important;
}
    </style>
</head>
<body>
   <div class="header">
    <span>‚Üê</span>
    <span style="font-size: 24px; font-weight: bold;">Crucigrama</span>
    <div class="header-right">
        <div id="timerMini" class="timer-mini">
            <span class="timer-mini-icon">‚è∞</span>
            <span id="timerDisplay">30</span>
        </div>
        <span>üçé Frutas</span>
    </div>
</div>

<div class="crossword-container">
    <div class="fruit-display" id="fruitDisplay">
        <div style="position: relative;">
            <img id="fruitImage" class="fruit-image" src="" alt="Fruta" onclick="openImageModal()">
            <div class="zoom-hint">üîç</div>
        </div>
    
    </div>
    
    <!-- Nuevo contenedor con scroll horizontal -->
    <div class="grid-container">
        <div class="grid" id="crossword">
            <!-- La cuadr√≠cula se generar√° con JavaScript -->
        </div>
    </div>
</div>

<div class="virtual-keyboard">
    <div class="keyboard-row">
        <button class="key" data-key="Q">q</button>
        <button class="key" data-key="W">w</button>
        <button class="key" data-key="E">e</button>
        <button class="key" data-key="R">r</button>
        <button class="key" data-key="T">t</button>
        <button class="key" data-key="Y">y</button>
        <button class="key" data-key="U">u</button>
        <button class="key" data-key="I">i</button>
        <button class="key" data-key="O">o</button>
        <button class="key" data-key="P">p</button>
    </div>
    <div class="keyboard-row">
        <button class="key" data-key="A">a</button>
        <button class="key" data-key="S">s</button>
        <button class="key" data-key="D">d</button>
        <button class="key" data-key="F">f</button>
        <button class="key" data-key="G">g</button>
        <button class="key" data-key="H">h</button>
        <button class="key" data-key="J">j</button>
        <button class="key" data-key="K">k</button>
        <button class="key" data-key="L">l</button>
    </div>
    <div class="keyboard-row">
        <button class="key special" data-action="settings">‚öôÔ∏è</button>
        <button class="key" data-key="Z">z</button>
        <button class="key" data-key="X">x</button>
        <button class="key" data-key="C">c</button>
        <button class="key" data-key="V">v</button>
        <button class="key" data-key="B">b</button>
        <button class="key" data-key="N">n</button>
        <button class="key" data-key="M">m</button>
        <button class="key special backspace" data-action="backspace">‚å´</button>
    </div>
</div>

<!-- Modal para imagen ampliada -->
<div id="imageModal" class="image-modal" onclick="closeImageModal()">
    <span class="close-modal" onclick="closeImageModal()">&times;</span>
    <img id="modalImage" class="modal-image" src="" alt="Fruta ampliada">
</div>


    <script>
// A√±adir esta funci√≥n despu√©s de la funci√≥n resetGame()
// ...existing code...
function showAllFruits() {
    console.log('Mostrando todas las frutas en el crucigrama...');
    
    const grid = document.getElementById('crossword');
    grid.innerHTML = '';
    
    // CORREGIR: Usar las mismas dimensiones
    const gridRows = 19;
    const gridCols = 18;
    const gridData = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
    
    // Marcar todas las posiciones de frutas
    fruits.forEach(fruit => {
        const pos = fruit.position;
        for (let i = 0; i < fruit.name.length; i++) {
            let row, col;
            if (pos.direction === 'horizontal') {
                row = pos.row;
                col = pos.col + i;
            } else {
                row = pos.row + i;
                col = pos.col;
            }
            
            // CORREGIR: Usar gridRows y gridCols
            if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                gridData[row][col] = {
                    type: 'white',
                    letter: fruit.name[i],
                    fruitName: fruit.name,
                    number: fruit.number
                };
            }
        }
    });
    
    // Crear el grid HTML - CORREGIR: Usar gridRows y gridCols
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const cell = document.createElement('div');
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (gridData[row][col] && gridData[row][col].type === 'white') {
                // Casilla blanca con letra
                cell.className = 'cell white';
                cell.textContent = gridData[row][col].letter;
                cell.style.backgroundColor = '#c8e6c9';
                cell.style.color = '#1f2937';
                
                // Agregar n√∫meros si es la primera casilla de una palabra
                fruits.forEach(fruit => {
                    if (fruit.position.row === row && fruit.position.col === col) {
                        const numberSpan = document.createElement('span');
                        numberSpan.textContent = fruit.number;
                        numberSpan.style.position = 'absolute';
                        numberSpan.style.top = '2px';
                        numberSpan.style.left = '2px';
                        numberSpan.style.fontSize = '8px';
                        numberSpan.style.fontWeight = 'bold';
                        numberSpan.style.color = '#000';
                        numberSpan.style.zIndex = '10';
                        cell.appendChild(numberSpan);
                    }
                });
            } else {
                // Casilla negra
                cell.className = 'cell black';
                cell.style.backgroundColor = '#000';
            }
            
            grid.appendChild(cell);
        }
    }
    
    console.log('Todas las frutas mostradas en el crucigrama');
}

// Funci√≥n para volver al modo de juego normal
function returnToGame() {
    console.log('Regresando al modo de juego normal...');
    updateFruitDisplay();
    generateGrid();
    
    // Solo reiniciar timer si no hay uno activo
    if (!timer) {
        startTimer();
    }
}

// Funci√≥n para mostrar estad√≠sticas de las frutas
function showFruitsStats() {
    console.log('=== ESTAD√çSTICAS DE FRUTAS ===');
    
    const horizontalFruits = fruits.filter(f => f.position.direction === 'horizontal');
    const verticalFruits = fruits.filter(f => f.position.direction === 'vertical');
    const fruitsWithSpaces = fruits.filter(f => f.name.includes(' '));
    
    console.log(`Total de frutas: ${fruits.length}`);
    console.log(`Horizontales: ${horizontalFruits.length}`);
    console.log(`Verticales: ${verticalFruits.length}`);
    console.log(`Con espacios: ${fruitsWithSpaces.length}`);
    
    console.log('\n=== FRUTAS HORIZONTALES ===');
    horizontalFruits.forEach((fruit, i) => {
        console.log(`${i+1}. ${fruit.name} - Fila ${fruit.position.row}, Col ${fruit.position.col}`);
    });
    
    console.log('\n=== FRUTAS VERTICALES ===');
    verticalFruits.forEach((fruit, i) => {
        console.log(`${i+1}. ${fruit.name} - Fila ${fruit.position.row}, Col ${fruit.position.col}`);
    });
    
    if (fruitsWithSpaces.length > 0) {
        console.log('\n=== FRUTAS CON ESPACIOS ===');
        fruitsWithSpaces.forEach(fruit => {
            console.log(`- ${fruit.name}`);
        });
    }
}

// Funci√≥n para verificar intersecciones entre frutas
function checkIntersections() {
    console.log('=== VERIFICANDO INTERSECCIONES ===');
    
    const intersections = [];
    
    for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
            const fruit1 = fruits[i];
            const fruit2 = fruits[j];
            
            // Solo verificar si tienen direcciones diferentes
            if (fruit1.position.direction !== fruit2.position.direction) {
                const intersection = findIntersection(fruit1, fruit2);
                if (intersection) {
                    intersections.push({
                        fruit1: fruit1.name,
                        fruit2: fruit2.name,
                        position: intersection.position,
                        letter: intersection.letter
                    });
                }
            }
        }
    }
    
    console.log(`Total de intersecciones encontradas: ${intersections.length}`);
    intersections.forEach(int => {
        console.log(`${int.fruit1} ‚à© ${int.fruit2} = "${int.letter}" en (${int.position.row}, ${int.position.col})`);
    });
    
    return intersections;
}

// Funci√≥n auxiliar para encontrar intersecci√≥n entre dos frutas
function findIntersection(fruit1, fruit2) {
    const pos1 = fruit1.position;
    const pos2 = fruit2.position;
    
    for (let i = 0; i < fruit1.name.length; i++) {
        for (let j = 0; j < fruit2.name.length; j++) {
            let row1, col1, row2, col2;
            
            if (pos1.direction === 'horizontal') {
                row1 = pos1.row;
                col1 = pos1.col + i;
            } else {
                row1 = pos1.row + i;
                col1 = pos1.col;
            }
            
            if (pos2.direction === 'horizontal') {
                row2 = pos2.row;
                col2 = pos2.col + j;
            } else {
                row2 = pos2.row + j;
                col2 = pos2.col;
            }
            
            // Si las posiciones coinciden y las letras son iguales
            if (row1 === row2 && col1 === col2 && fruit1.name[i] === fruit2.name[j]) {
                return {
                    position: { row: row1, col: col1 },
                    letter: fruit1.name[i]
                };
            }
        }
    }
    
    return null;
}


// ...existing code...
// ...existing code...
// ...existing code...
const fruits = [
    // Palabras Horizontales (14 palabras)
    {
        name: 'NECTARINA',
        image: 'https://fawzinoo.github.io/Fotos/nectarina.png',
        audio: 'https://fawzinoo.github.io/audios/La nectarina.mp3',
        position: { row: 0, col: 0, direction: 'horizontal' },
        number: 1
    },
    {
        name: 'LIMON',
        image: 'https://fawzinoo.github.io/Fotos/limon.png',
        audio: 'https://fawzinoo.github.io/audios/El limon.mp3',
        position: { row: 0, col: 11, direction: 'horizontal' },
        number: 4
    },
    {
        name: 'SANDIA',
        image: 'https://fawzinoo.github.io/Fotos/sand√≠a.png',
        audio: 'https://fawzinoo.github.io/audios/La sandia.mp3',
        position: { row: 2, col: 11, direction: 'horizontal' },
        number: 6
    },
    {
        name: 'UVA',
        image: 'https://fawzinoo.github.io/Fotos/uva.png',
        audio: 'https://fawzinoo.github.io/audios/Las uvas.mp3',
        position: { row: 3, col: 2, direction: 'horizontal' },
        number: 7
    },
    {
        name: 'CHIRIMOYA',
        image: 'https://fawzinoo.github.io/Fotos/chirimoya.png',
        audio: 'https://fawzinoo.github.io/audios/La chirimoya.mp3',
        position: { row: 4, col: 5, direction: 'horizontal' },
        number: 8
    },
    {
        name: 'KIWI',
        image: 'https://fawzinoo.github.io/Fotos/kiwi.png',
        audio: 'https://fawzinoo.github.io/audios/El kiwi.mp3',
        position: { row: 6, col: 12, direction: 'horizontal' },
        number: 11
    },
    {
        name: 'PERA',
        image: 'https://fawzinoo.github.io/Fotos/pera.png',
        audio: 'https://fawzinoo.github.io/audios/La pera.mp3',
        position: { row: 7, col: 2, direction: 'horizontal' },
        number: 12
    },
    {
        name: 'AGUACATE',
        image: 'https://fawzinoo.github.io/Fotos/aguacate.png',
        audio: 'https://fawzinoo.github.io/audios/El aguacate.mp3',
        position: { row: 8, col: 10, direction: 'horizontal' },
        number: 14
    },
    {
        name: 'FRAMBUESA',
        image: 'https://fawzinoo.github.io/Fotos/frambuesa.png',
        audio: 'https://fawzinoo.github.io/audios/La frambuesa.mp3',
        position: { row: 10, col: 2, direction: 'horizontal' },
        number: 16
    },
    {
        name: 'MANZANA',
        image: 'https://fawzinoo.github.io/Fotos/manzana.png',
        audio: 'https://fawzinoo.github.io/audios/La manzana.mp3',
        position: { row: 12, col: 4, direction: 'horizontal' },
        number: 17
    },
    {
        name: 'PLATANO',
        image: 'https://fawzinoo.github.io/Fotos/platano.png',
        audio: 'https://fawzinoo.github.io/audios/El platano.mp3',
        position: { row: 14, col: 10, direction: 'horizontal' },
        number: 21
    },
    {
        name: 'CEREZA',
        image: 'https://fawzinoo.github.io/Fotos/cereza.png',
        audio: 'https://fawzinoo.github.io/audios/La cereza.mp3',
        position: { row: 15, col: 1, direction: 'horizontal' },
        number: 22
    },
    {
        name: 'PAPAYA',
        image: 'https://fawzinoo.github.io/Fotos/papaya.png',
        audio: 'https://fawzinoo.github.io/audios/La papaya.mp3',
        position: { row: 18, col: 3, direction: 'horizontal' },
        number: 24
    },
    {
        name: 'MANGO',
        image: 'https://fawzinoo.github.io/Fotos/mango.png',
        audio: 'https://fawzinoo.github.io/audios/El mango.mp3',
        position: { row: 18, col: 12, direction: 'horizontal' },
        number: 25
    },

    // Palabras Verticales (11 palabras)
    {
        name: 'NARANJA',
        image: 'https://fawzinoo.github.io/Fotos/naranja.png',
        audio: 'https://fawzinoo.github.io/audios/La naranja.mp3',
        position: { row: 12, col: 6, direction: 'vertical' },
        number: 1
    },
    {
        name: 'CAQUI',
        image: 'https://fawzinoo.github.io/Fotos/caqui.png',
        audio: 'https://fawzinoo.github.io/audios/El Caqui.mp3',
        position: { row: 0, col: 2, direction: 'vertical' },
        number: 2
    },
    {
        name: 'ALBARICOQUE',
        image: 'https://fawzinoo.github.io/Fotos/albaricoque.png',
        audio: 'https://fawzinoo.github.io/audios/El albaricoque.mp3',
        position: { row: 0, col: 8, direction: 'vertical' },
        number: 3
    },
    {
        name: 'MANDARINA',
        image: 'https://fawzinoo.github.io/Fotos/mandarina.png',
        audio: 'https://fawzinoo.github.io/audios/La mandarina.mp3',
        position: { row: 0, col: 13, direction: 'vertical' },
        number: 5
    },
    {
        name: 'FRESA',
        image: 'https://fawzinoo.github.io/Fotos/fresa.png',
        audio: 'https://fawzinoo.github.io/audios/La fresa.mp3',
        position: { row: 6, col: 4, direction: 'vertical' },
        number: 9
    },
    {
        name: 'GRANADA',
        image: 'https://fawzinoo.github.io/Fotos/granada.png',
        audio: 'https://fawzinoo.github.io/audios/La granada.mp3',
        position: { row: 6, col: 10, direction: 'vertical' },
        number: 10
    },
    {
        name: 'MELON',
        image: 'https://fawzinoo.github.io/Fotos/melon.png',
        audio: 'https://fawzinoo.github.io/audios/El melon.mp3',
        position: { row: 7, col: 17, direction: 'vertical' },
        number: 13
    },
    
    {
        name: 'CIRUELA',
        image: 'https://fawzinoo.github.io/Fotos/ciruela.png',
        audio: 'https://fawzinoo.github.io/audios/La ciruela.mp3',
        position: { row: 8, col: 14, direction: 'vertical' },
        number: 18
    },
    {
        name: 'COCO',
        image: 'https://fawzinoo.github.io/Fotos/coco.png',
        audio: 'https://fawzinoo.github.io/audios/El coco.mp3',
        position: { row: 13, col: 1, direction: 'vertical' },
        number: 19
    },
    {
        name: 'POMELO',
        image: 'https://fawzinoo.github.io/Fotos/pomelo.png',
        audio: 'https://fawzinoo.github.io/audios/El pomelo.mp3',
        position: { row: 13, col: 16, direction: 'vertical' },
        number: 20
    },
    {
        name: 'PI√ëA',
        image: 'https://fawzinoo.github.io/Fotos/pi√±a.png',
        audio: 'https://fawzinoo.github.io/audios/La pina.mp3',
        position: { row: 15, col: 8, direction: 'vertical' },
        number: 23
    }
];
// ...existing code...
// ...existing code...




        let currentFruitIndex = 0;
        let currentFruit = fruits[currentFruitIndex];
        let completedFruits = new Set();
        let availableFruits = []; 
         let incompleteFruits = [];

                // Variables del timer
        let timer = null;
        let timeLeft = 30;
        let currentRound = 1;
        let totalRounds = 0;

   function playAudio(audioUrl) {
    try {
        // Detener cualquier audio previo que pueda estar reproduci√©ndose
        if (window.currentAudio) {
            window.currentAudio.pause();
            window.currentAudio.currentTime = 0;
        }
        
        const audio = new Audio(audioUrl);
        window.currentAudio = audio; // Guardar referencia global
        
        audio.volume = 0.6; // Reducir volumen para evitar saturaci√≥n
        audio.preload = 'auto';
        
        // Manejar errores de carga
        audio.onerror = function() {
            console.log('Error al cargar el audio:', audioUrl);
            window.currentAudio = null;
        };
        
        // Limpiar referencia cuando termine
        audio.onended = function() {
            window.currentAudio = null;
        };
        
        // Reproducir cuando est√© listo
        const playPromise = audio.play();
        
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log('Audio reproducido correctamente');
            }).catch(error => {
                console.log('Error al reproducir audio:', error);
                window.currentAudio = null;
            });
        }
        
    } catch (error) {
        console.log('Error creando objeto Audio:', error);
    }
}
function stopAllAudio() {
    // Detener audio de frutas
    if (window.currentAudio) {
        try {
            window.currentAudio.pause();
            window.currentAudio.currentTime = 0;
        } catch(e) {}
        window.currentAudio = null;
    }
    
    // Detener oscilador de √©xito
    if (window.currentOscillator) {
        try {
            window.currentOscillator.stop();
            window.currentOscillator.disconnect();
        } catch(e) {}
        window.currentOscillator = null;
    }
}

// A√±adir funci√≥n para verificar elementos DOM
function verifyDOMElements() {
    const timerMini = document.getElementById('timerMini');
    const timerDisplay = document.getElementById('timerDisplay');
    
    console.log('Verificando elementos DOM:');
    console.log('timerMini:', timerMini ? 'OK' : 'NO ENCONTRADO');
    console.log('timerDisplay:', timerDisplay ? 'OK' : 'NO ENCONTRADO');
    
    return timerMini && timerDisplay;
}

        // Funci√≥n para iniciar el timer
function startTimer() {
    console.log('Iniciando timer para:', currentFruit.name);
    
    // Limpiar timer anterior si existe
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    
    timeLeft = 30;
    updateTimerDisplay();
    
    timer = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        console.log(`Timer: ${timeLeft} segundos restantes para ${currentFruit.name}`);
        
        // Cambiar color cuando quedan 10 segundos
        const timerMini = document.getElementById('timerMini');
        if (timerMini) {
            if (timeLeft <= 10) {
                timerMini.classList.add('warning');
            } else {
                timerMini.classList.remove('warning');
            }
        }
        
        // Tiempo agotado
        if (timeLeft <= 0) {
            console.log('¬°TIEMPO AGOTADO! Ejecutando timeout...');
            clearInterval(timer);
            timer = null;
            
            // Ejecutar inmediatamente sin setTimeout
            handleTimeOut();
        }
    }, 1000);
    
    console.log('Timer iniciado correctamente');
}
        // Funci√≥n para actualizar la visualizaci√≥n del timer
function updateTimerDisplay() {
    const timerDisplay = document.getElementById('timerDisplay');
    if (timerDisplay) {
        timerDisplay.textContent = timeLeft;
    } else {
        console.error('Elemento timerDisplay no encontrado');
    }
}

        // Funci√≥n para detener el timer
  function stopTimer() {
    console.log('Deteniendo timer...');
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    
    const timerMini = document.getElementById('timerMini');
    if (timerMini) {
        timerMini.classList.remove('warning');
    }
    console.log('Timer detenido');
}

function initializeVirtualKeyboard() {
    const keys = document.querySelectorAll('.key');
    
    keys.forEach(key => {
        key.addEventListener('click', function() {
            const keyValue = this.dataset.key;
            const action = this.dataset.action;
            
            // Encontrar el input activo
            const activeInput = document.activeElement;
            
            if (action === 'backspace') {
                if (activeInput && activeInput.tagName === 'INPUT') {
                    if (activeInput.value) {
                        activeInput.value = '';
                    } else {
                        const prevInput = getPreviousInput(activeInput);
                        if (prevInput) {
                            prevInput.focus();
                            prevInput.value = '';
                        }
                    }
                    setTimeout(checkAnswerAutomatic, 100);
                }
            } else if (action === 'settings') {
                // Puedes a√±adir funcionalidad de configuraci√≥n aqu√≠
                console.log('Configuraci√≥n del teclado');
            } else if (keyValue) {
                // Insertar letra
                if (activeInput && activeInput.tagName === 'INPUT') {
                    activeInput.value = keyValue.toUpperCase();
                    
                    // Mover al siguiente input
                    const nextInput = getNextInput(activeInput);
                    if (nextInput) {
                        nextInput.focus();
                        setTimeout(() => {
                            ensureInputVisible(nextInput);
                        }, 50);
                    }
                    
                    setTimeout(checkAnswerAutomatic, 100);
                } else {
                    // Si no hay input activo, enfocar el primero disponible
                    const firstInput = document.querySelector('.green input');
                    if (firstInput) {
                        firstInput.focus();
                        firstInput.value = keyValue.toUpperCase();
                        
                        const nextInput = getNextInput(firstInput);
                        if (nextInput) {
                            nextInput.focus();
                        }
                        setTimeout(checkAnswerAutomatic, 100);
                    }
                }
            }
            
            // Efecto visual de pulsaci√≥n
            this.style.transform = 'translateY(2px)';
            setTimeout(() => {
                this.style.transform = '';
            }, 100);
        });
    });
}

// Modificar la funci√≥n initializeGame para incluir el teclado
function initializeGame() {
    console.log('=== INICIALIZANDO JUEGO ===');
    
    if (!verifyDOMElements()) {
        console.error('Error: Elementos del DOM no encontrados');
        return;
    }
    
    initializeRandomFruits();
    updateFruitDisplay();
    generateGrid();
    startTimer();
    initializeVirtualKeyboard(); // A√±adir esta l√≠nea
    
    console.log('=== JUEGO INICIALIZADO ===');
}

// Cambiar la inicializaci√≥n al final del script de:
// initializeRandomFruits();
// updateFruitDisplay();
// generateGrid();
// startTimer();

// A:
// Esperar a que el DOM est√© completamente cargado
document.addEventListener('DOMContentLoaded', function() {
    initializeGame();
});

// Como respaldo, tambi√©n ejecutar despu√©s de un peque√±o delay
setTimeout(() => {
    if (!timer) {
        console.log('Respaldo: inicializando juego...');
        initializeGame();
    }
}, 500);

        // Funci√≥n cuando se agota el tiempo
function handleTimeOut() {
    console.log('=== TIMEOUT EJECUTADO ===');
    console.log(`Tiempo agotado para: ${currentFruit.name}`);
    console.log(`Fruta actual index: ${currentFruitIndex}`);
    console.log(`Completadas: ${Array.from(completedFruits)}`);
    console.log(`Disponibles: ${availableFruits}`);
    
    // A√±adir a frutas incompletas si no est√° completada
    if (!completedFruits.has(currentFruitIndex)) {
        incompleteFruits.push(currentFruitIndex);
        console.log(`A√±adida ${currentFruit.name} (${currentFruitIndex}) a incompletas`);
    }
    
    console.log(`Frutas incompletas total: ${incompleteFruits}`);
    
    // Buscar siguiente fruta inmediatamente
    console.log('Buscando siguiente fruta...');
    findNextAvailableFruit();
}


// Nueva funci√≥n para encontrar la siguiente fruta de forma m√°s directa
function findNextAvailableFruit() {
    console.log('=== BUSCANDO SIGUIENTE FRUTA ===');
    
    let nextIndex = -1;
    let currentIndexInArray = availableFruits.indexOf(currentFruitIndex);
    
    console.log(`Posici√≥n actual en array: ${currentIndexInArray}`);
    
    // Buscar desde la siguiente posici√≥n en adelante
    for (let i = currentIndexInArray + 1; i < availableFruits.length; i++) {
        if (!completedFruits.has(availableFruits[i])) {
            nextIndex = availableFruits[i];
            console.log(`Siguiente fruta encontrada: ${fruits[nextIndex].name} (index: ${nextIndex})`);
            break;
        }
    }
    
    // Si no encontr√≥ nada, buscar desde el principio
    if (nextIndex === -1) {
        for (let i = 0; i < currentIndexInArray; i++) {
            if (!completedFruits.has(availableFruits[i])) {
                nextIndex = availableFruits[i];
                console.log(`Fruta encontrada al principio: ${fruits[nextIndex].name} (index: ${nextIndex})`);
                break;
            }
        }
    }
    
    if (nextIndex !== -1) {
        console.log(`Cambiando a fruta: ${fruits[nextIndex].name}`);
        currentFruitIndex = nextIndex;
        currentFruit = fruits[currentFruitIndex];
        
        updateFruitDisplay();
        generateGrid();
        startTimer();
        
        console.log('=== CAMBIO COMPLETADO ===');
    } else {
        console.log('No hay m√°s frutas disponibles, iniciando nueva ronda...');
        checkForIncompleteRounds();
    }
}


        // Funci√≥n para mezclar array aleatoriamente (algoritmo Fisher-Yates)
 function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

// Inicializar frutas disponibles de forma aleatoria
function initializeRandomFruits() {
    console.log('Inicializando frutas aleatorias...');
    availableFruits = shuffleArray(fruits.map((_, index) => index));
    currentFruitIndex = availableFruits[0];
    currentFruit = fruits[currentFruitIndex];
    console.log('Primera fruta:', currentFruit.name);
    console.log('Orden aleatorio:', availableFruits.map(i => fruits[i].name));
}



  function openImageModal() {
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const fruitImage = document.getElementById('fruitImage');
            
            modalImage.src = fruitImage.src;
            modal.style.display = 'flex';
            
            // Prevenir scroll del body cuando el modal est√° abierto
            document.body.style.overflow = 'hidden';
        }

        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            modal.style.display = 'none';
            
            // Restaurar scroll del body
            document.body.style.overflow = 'auto';
        }
         // Cerrar modal con tecla Escape
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeImageModal();
            }
        });
         // Prevenir que el clic en la imagen cierre el modal
        document.getElementById('modalImage').addEventListener('click', function(event) {
            event.stopPropagation();
        });

        function updateFruitDisplay() {
            document.getElementById('fruitImage').src = currentFruit.image;

        }
        // Generar sonido de √©xito
 function playSuccessSound() {
    try {
        // Detener cualquier oscilador previo
        if (window.currentOscillator) {
            try {
                window.currentOscillator.stop();
                window.currentOscillator.disconnect();
            } catch(e) {}
            window.currentOscillator = null;
        }
        
        // Usar un solo contexto de audio global
        if (!window.audioContext) {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const audioContext = window.audioContext;
        
        // Asegurar que el contexto est√© activo
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // Crear oscilador
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // Guardar referencia para poder detenerlo
        window.currentOscillator = oscillator;
        
        // Conectar
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Configurar
        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
        oscillator.type = 'sine';
        
        // Volumen con fade
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
        
        // Reproducir
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
        
        // Limpiar cuando termine
        oscillator.onended = function() {
            try {
                oscillator.disconnect();
                gainNode.disconnect();
            } catch(e) {}
            window.currentOscillator = null;
        };
        
    } catch (e) {
        console.log('Error en audio:', e);
    }
}

function generateGrid() {
    const grid = document.getElementById('crossword');
    grid.innerHTML = '';
    
    const gridRows = 19;
    const gridCols = 18;
    const gridData = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
    
    // Marcar casillas que deben ser blancas (donde van las letras)
    fruits.forEach(fruit => {
        const pos = fruit.position;
        for (let i = 0; i < fruit.name.length; i++) {
            let row, col;
            if (pos.direction === 'horizontal') {
                row = pos.row;
                col = pos.col + i;
            } else {
                row = pos.row + i;
                col = pos.col;
            }
            
            if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                if (!gridData[row][col]) {
                    gridData[row][col] = { type: 'white', letters: [] };
                }
                gridData[row][col].letters.push({
                    letter: fruit.name[i],
                    fruitIndex: fruits.indexOf(fruit),
                    letterIndex: i
                });
            }
        }
    });
    
    // Crear el grid HTML
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const cell = document.createElement('div');
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (gridData[row][col] && gridData[row][col].type === 'white') {
                cell.className = 'cell white';
                
                const belongsToCurrentFruit = gridData[row][col].letters.some(
                    letterData => letterData.fruitIndex === currentFruitIndex
                );
                
                if (belongsToCurrentFruit) {
                    cell.classList.add('green');
                    
                    const completedLetter = gridData[row][col].letters.find(
                        letterData => completedFruits.has(letterData.fruitIndex)
                    );
                    
                    if (completedLetter) {
                        cell.textContent = completedLetter.letter;
                        cell.style.backgroundColor = '#fef3c7'; // Amarillo suave
                        cell.style.color = '#1f2937';
                        cell.classList.add('filled-intersection');
                    } else {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.addEventListener('input', handleInput);
                        input.addEventListener('keydown', handleKeyDown);
                        cell.appendChild(input);
                    }
                } else {
                    const completedLetter = gridData[row][col].letters.find(
                        letterData => completedFruits.has(letterData.fruitIndex)
                    );
                    
                    if (completedLetter) {
                        cell.textContent = completedLetter.letter;
                        cell.style.backgroundColor = '#fef3c7'; // Amarillo suave
                        cell.style.color = '#1f2937';
                        cell.classList.add('filled');
                    }
                }
       
            } else {
                cell.className = 'cell black';
                cell.style.backgroundColor = '#000';
            }
            
            grid.appendChild(cell);
        }
    }
    
    const firstInput = document.querySelector('.green input');
    if (firstInput) {
        firstInput.focus();
    }
    
    setTimeout(() => {
        centerOnGreenWord();
    }, 100);
}
function centerOnGreenWord() {
    const gridContainer = document.querySelector('.grid-container');
    const greenCells = document.querySelectorAll('.green');
    
    if (greenCells.length === 0 || !gridContainer) {
        return;
    }
    
    // Calcular los l√≠mites de la palabra verde
    let minLeft = Infinity;
    let maxRight = -Infinity;
    let minTop = Infinity;
    let maxBottom = -Infinity;
    
    greenCells.forEach(cell => {
        const rect = cell.getBoundingClientRect();
        const containerRect = gridContainer.getBoundingClientRect();
        
        // Posici√≥n relativa al contenedor
        const cellLeft = rect.left - containerRect.left + gridContainer.scrollLeft;
        const cellRight = cellLeft + rect.width;
        const cellTop = rect.top - containerRect.top + gridContainer.scrollTop;
        const cellBottom = cellTop + rect.height;
        
        minLeft = Math.min(minLeft, cellLeft);
        maxRight = Math.max(maxRight, cellRight);
        minTop = Math.min(minTop, cellTop);
        maxBottom = Math.max(maxBottom, cellBottom);
    });
    
    // Calcular el centro de la palabra
    const wordCenterX = (minLeft + maxRight) / 2;
    const wordCenterY = (minTop + maxBottom) / 2;
    
    // Calcular la posici√≥n de scroll para centrar la palabra
    const containerWidth = gridContainer.clientWidth;
    const containerHeight = gridContainer.clientHeight;
    
    // Calcular scroll horizontal
    let targetScrollLeft = wordCenterX - (containerWidth / 2);
    const maxScrollLeft = gridContainer.scrollWidth - containerWidth;
    targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
    
    // Calcular scroll vertical - AHORA FUNCIONAL
    let targetScrollTop = wordCenterY - (containerHeight / 2);
    const maxScrollTop = gridContainer.scrollHeight - containerHeight;
    targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop));
    
    // Aplicar scroll suave en ambas direcciones
    gridContainer.scrollTo({
        left: targetScrollLeft,
        top: targetScrollTop,
        behavior: 'smooth'
    });
}



function shouldCellHaveSeparator(row, col) {
    const pos = currentFruit.position;
    
    // Solo aplicar a la fruta actual
    if (!isCurrentFruitCell(row, col)) {
        return false;
    }
    
    // Calcular la posici√≥n relativa en el nombre de la fruta
    let relativeIndex;
    if (pos.direction === 'horizontal') {
        relativeIndex = col - pos.col;
    } else {
        relativeIndex = row - pos.row;
    }
    
    // Buscar espacios en el nombre de la fruta y verificar si esta posici√≥n corresponde a un espacio
    const fruitName = currentFruit.name;
    let letterCount = 0;
    
    for (let i = 0; i < fruitName.length; i++) {
        if (fruitName[i] === ' ') {
            // Si encontramos un espacio y coincide con la posici√≥n relativa
            if (letterCount === relativeIndex) {
                return true;
            }
        } else {
            letterCount++;
        }
    }
    
    return false;
}

 function isCurrentFruitCell(row, col) {
    const pos = currentFruit.position;
    const nameWithoutSpaces = currentFruit.name.replace(/\s/g, '');
    const nameLength = nameWithoutSpaces.length + (currentFruit.name.split(' ').length - 1); // Contar espacios como posiciones
    
    if (pos.direction === 'horizontal') {
        return row === pos.row && col >= pos.col && col < pos.col + nameLength;
    } else {
        return col === pos.col && row >= pos.row && row < pos.row + nameLength;
    }
}

        function isCompletedFruitCell(row, col) {
            return fruits.some((fruit, index) => {
                if (!completedFruits.has(index)) return false;
                
                const pos = fruit.position;
                if (pos.direction === 'horizontal') {
                    return row === pos.row && col >= pos.col && col < pos.col + fruit.name.length;
                } else {
                    return col === pos.col && row >= pos.row && row < pos.row + fruit.name.length;
                }
            });
        }

        function getLetterAt(row, col) {
            for (let i = 0; i < fruits.length; i++) {
                if (completedFruits.has(i)) {
                    const fruit = fruits[i];
                    const pos = fruit.position;
                    
                    if (pos.direction === 'horizontal') {
                        if (row === pos.row && col >= pos.col && col < pos.col + fruit.name.length) {
                            return fruit.name[col - pos.col];
                        }
                    } else {
                        if (col === pos.col && row >= pos.row && row < pos.row + fruit.name.length) {
                            return fruit.name[row - pos.row];
                        }
                    }
                }
            }
            return '';
        }

      function handleInput(event) {
    const input = event.target;
    const value = input.value.toUpperCase();
    input.value = value;
    
    if (value && value.length === 1) {
        const nextInput = getNextInput(input);
        if (nextInput) {
            nextInput.focus();
            // Centrar en el nuevo input si est√° cerca del borde
            setTimeout(() => {
                ensureInputVisible(nextInput);
            }, 50);
        }
    }
    
    setTimeout(checkAnswerAutomatic, 100);
}



function ensureInputVisible(input) {
    const gridContainer = document.querySelector('.grid-container');
    const cell = input.parentElement;
    const cellRect = cell.getBoundingClientRect();
    const containerRect = gridContainer.getBoundingClientRect();
    
    // Verificar si el input est√° cerca de los bordes
    const marginBuffer = 50; // p√≠xeles de margen
    
    const cellLeft = cellRect.left - containerRect.left + gridContainer.scrollLeft;
    const cellRight = cellLeft + cellRect.width;
    const cellTop = cellRect.top - containerRect.top + gridContainer.scrollTop;
    const cellBottom = cellTop + cellRect.height;
    
    const visibleLeft = gridContainer.scrollLeft;
    const visibleRight = visibleLeft + gridContainer.clientWidth;
    const visibleTop = gridContainer.scrollTop;
    const visibleBottom = visibleTop + gridContainer.clientHeight;
    
    let needsScroll = false;
    let targetScrollLeft = gridContainer.scrollLeft;
    let targetScrollTop = gridContainer.scrollTop;
    
    // Verificar scroll horizontal
    if (cellLeft < visibleLeft + marginBuffer) {
        targetScrollLeft = cellLeft - marginBuffer;
        needsScroll = true;
    } else if (cellRight > visibleRight - marginBuffer) {
        targetScrollLeft = cellRight - gridContainer.clientWidth + marginBuffer;
        needsScroll = true;
    }
    
    // Verificar scroll vertical
    if (cellTop < visibleTop + marginBuffer) {
        targetScrollTop = cellTop - marginBuffer;
        needsScroll = true;
    } else if (cellBottom > visibleBottom - marginBuffer) {
        targetScrollTop = cellBottom - gridContainer.clientHeight + marginBuffer;
        needsScroll = true;
    }
    
    if (needsScroll) {
        // Limitar el scroll
        const maxScrollLeft = gridContainer.scrollWidth - gridContainer.clientWidth;
        const maxScrollTop = gridContainer.scrollHeight - gridContainer.clientHeight;
        
        targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
        targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop));
        
        gridContainer.scrollTo({
            left: targetScrollLeft,
            top: targetScrollTop,
            behavior: 'smooth'
        });
    }
}

        function handleKeyDown(event) {
            const input = event.target;
            
            // Manejar tecla Backspace (borrar hacia atr√°s)
            if (event.key === 'Backspace') {
                event.preventDefault();
                
                if (input.value) {
                    // Si hay contenido, borrarlo
                    input.value = '';
                } else {
                    // Si no hay contenido, ir al campo anterior
                    const prevInput = getPreviousInput(input);
                    if (prevInput) {
                        prevInput.focus();
                        prevInput.value = '';
                    }
                }
            }
            
            // Manejar tecla Delete (borrar hacia adelante)
            if (event.key === 'Delete') {
                event.preventDefault();
                input.value = '';
                
                // Opcional: ir al siguiente campo
                const nextInput = getNextInput(input);
                if (nextInput) {
                    nextInput.focus();
                }
            }
            
            // Manejar flechas para navegaci√≥n
            if (event.key === 'ArrowLeft') {
                event.preventDefault();
                const prevInput = getPreviousInput(input);
                if (prevInput) {
                    prevInput.focus();
                }
            }
            
            if (event.key === 'ArrowRight') {
                event.preventDefault();
                const nextInput = getNextInput(input);
                if (nextInput) {
                    nextInput.focus();
                }
            }
            
            // Verificar autom√°ticamente despu√©s de cualquier cambio
            setTimeout(checkAnswerAutomatic, 100);
        }

 function getNextInput(currentInput) {
    const cell = currentInput.parentElement;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const pos = currentFruit.position;
    
    let nextRow, nextCol;
    if (pos.direction === 'horizontal') {
        nextRow = row;
        nextCol = col + 1;
    } else {
        nextRow = row + 1;
        nextCol = col;
    }
    
    // Buscar la siguiente casilla que sea un input (no una intersecci√≥n pre-llenada)
    let attempts = 0;
    while (attempts < currentFruit.name.length) {
        const nextCell = document.querySelector(`[data-row="${nextRow}"][data-col="${nextCol}"]`);
        const nextInput = nextCell ? nextCell.querySelector('input') : null;
        
        if (nextInput) {
            return nextInput;
        }
        
        // Si no hay input, continuar a la siguiente posici√≥n
        if (pos.direction === 'horizontal') {
            nextCol++;
        } else {
            nextRow++;
        }
        attempts++;
    }
    
    return null;
}

function getPreviousInput(currentInput) {
    const cell = currentInput.parentElement;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const pos = currentFruit.position;
    
    let prevRow, prevCol;
    if (pos.direction === 'horizontal') {
        prevRow = row;
        prevCol = col - 1;
    } else {
        prevRow = row - 1;
        prevCol = col;
    }
    
    // Buscar la casilla anterior que sea un input (no una intersecci√≥n pre-llenada)
    let attempts = 0;
    while (attempts < currentFruit.name.length) {
        const prevCell = document.querySelector(`[data-row="${prevRow}"][data-col="${prevCol}"]`);
        const prevInput = prevCell ? prevCell.querySelector('input') : null;
        
        if (prevInput) {
            return prevInput;
        }
        
        // Si no hay input, continuar a la posici√≥n anterior
        if (pos.direction === 'horizontal') {
            prevCol--;
        } else {
            prevRow--;
        }
        attempts++;
    }
    
    return null;
}

function checkAnswerAutomatic() {
      if (window.checkingAnswer) {
        return; // Si ya est√° verificando, salir inmediatamente
    }
    
    const inputs = document.querySelectorAll('.green input');
    let userAnswer = '';
    let isComplete = true;
    
    // Construir la respuesta considerando inputs, intersecciones pre-llenadas y separadores
    const pos = currentFruit.position;
    const nameWithoutSpaces = currentFruit.name.replace(/\s/g, '');
    
    for (let i = 0; i < currentFruit.name.length; i++) {
        if (currentFruit.name[i] === ' ') {
            userAnswer += ' '; // A√±adir espacio en la respuesta
            continue;
        }
        
        let letterFound = false;
        let currentRow, currentCol;
        
        // Calcular posici√≥n considerando espacios
        let visualIndex = i;
        if (pos.direction === 'horizontal') {
            currentRow = pos.row;
            currentCol = pos.col + visualIndex;
        } else {
            currentRow = pos.row + visualIndex;
            currentCol = pos.col;
        }
        
        // Buscar si es una intersecci√≥n pre-llenada
        const intersectionCell = document.querySelector(`[data-row="${currentRow}"][data-col="${currentCol}"].filled-intersection`);
        if (intersectionCell) {
            userAnswer += intersectionCell.textContent;
            letterFound = true;
        } else {
            // Buscar si es un input
            const inputCell = document.querySelector(`[data-row="${currentRow}"][data-col="${currentCol}"] input`);
            if (inputCell && inputCell.value) {
                userAnswer += inputCell.value;
                letterFound = true;
            }
        }
        
        if (!letterFound) {
            isComplete = false;
            break;
        }
    }
    
    if (isComplete && userAnswer === currentFruit.name) {
        stopTimer();
        playSuccessSound();
        
        inputs.forEach(input => {
            input.parentElement.classList.add('correct');
        });
        
        completedFruits.add(currentFruitIndex);
        incompleteFruits = incompleteFruits.filter(index => index !== currentFruitIndex);
        
        setTimeout(() => {
            playAudio(currentFruit.audio);
        }, 800);
        
        setTimeout(() => {
            nextFruit();
        }, 3000);
    }
}
function nextFruit() {
    console.log('nextFruit() llamada (palabra completada)');
    stopTimer();
    stopAllAudio();
    
    // Usar la misma l√≥gica que para timeout
    setTimeout(() => {
        findNextAvailableFruit();
    }, 100);
}
function checkForIncompleteRounds() {
    if (incompleteFruits.length > 0) {
        currentRound++;
        console.log(`Iniciando ronda ${currentRound} con ${incompleteFruits.length} frutas pendientes`);
        
        // Reiniciar con las frutas incompletas
        availableFruits = shuffleArray([...incompleteFruits]);
        incompleteFruits = [];
        
        currentFruitIndex = availableFruits[0];
        currentFruit = fruits[currentFruitIndex];
        updateFruitDisplay();
        generateGrid();
        startTimer();
    } else {
        // Todas las frutas completadas
        showCompletionMessage();
    }
}

       function showCompletionMessage() {
            const completedCount = completedFruits.size;
            const totalFruits = fruits.length;
            
            let message = `¬°Felicidades! Has completado ${completedCount} de ${totalFruits} frutas del crucigrama üéâ`;
            
            if (currentRound > 1) {
                message += `\n\nN√∫mero de rondas: ${currentRound}`;
            }
            
            if (completedCount === totalFruits) {
                message += '\n¬°Completaste todas las frutas! üèÜ';
            }
            
            alert(message);
            
            // Opcional: Reiniciar el juego
            if (confirm('¬øQuieres jugar otra vez con un orden diferente?')) {
                resetGame();
            }
        }

    function resetGame() {
            stopTimer();
            completedFruits.clear();
            incompleteFruits = [];
            currentRound = 1;
            initializeRandomFruits();
            updateFruitDisplay();
            generateGrid();
            startTimer();
        }

  // Inicializaci√≥n
        initializeRandomFruits();
        updateFruitDisplay();
        generateGrid();
        startTimer(); // Iniciar el primer timer
    </script>
</body>
</html>
