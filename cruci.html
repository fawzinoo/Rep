<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crucigrama de Frutas</title>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>  
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(to bottom, #6366f1, #a5b4fc);
            min-height: 100vh;
            
        }

       .header {
            background-color: #4338ca;
            color: white;
            padding: 10px 15px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
      .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

          .timer-mini {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .timer-mini.warning {
            background-color: #f59e0b;
            border-color: #f59e0b;
            animation: pulse 1s infinite;
        }

/* ESTILOS PARA EL CONTADOR DE PUNTOS FIJO */
          .score-display-fixed {
            position: fixed; /* Esto lo fija en la pantalla */
            top: 70px;       /* Ajusta según la posición vertical deseada */
            left: -8px;     /* Pegado a la derecha con un pequeño margen */
            z-index: 100;    /* Para que esté por encima de otros elementos */
            background-color: rgba(255, 255, 255, 5); /* MISMO COLOR QUE .timer-mini */
            color: black;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3); /* MISMO BORDE QUE .timer-mini */
        }
        .score-icon {
            font-size: 12px;
        }
               @keyframes scorePulseAnimation {
            0% {
                transform: scale(1);
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.5); /* Sombra amarilla suave */
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 0 15px rgba(255, 255, 0, 0.8); /* Sombra amarilla más intensa */
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
            }
        }

        .score-display-fixed.animate-score {
            animation: scorePulseAnimation 0.6s ease-in-out;
        }

.timer-mini-icon {
            font-size: 12px;
        }
.crossword-container {
    background-color: #e0f2fe;
    padding: 15px;
    border-radius: 10px;
    margin: 0 auto;
    max-width: 600px; /* Reducido de 800px a 600px para ver mejor la foto */
}

.grid-container {
    overflow-x: auto;
    overflow-y: auto; /* Cambiado de hidden a auto para permitir scroll vertical */
    padding: 15px;
    margin: 20px 0;
    border-radius: 8px;
    background-color: rgba(255, 255, 255, 0.1);
    max-height: 500px; /* Añadido límite de altura para activar scroll vertical */
    border: 2px solid rgba(255, 255, 255, 0.2); /* Borde sutil */
      scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE y Edge */
}

/* Personalizar la barra de scroll horizontal */
.grid-container::-webkit-scrollbar:horizontal {
    height: 10px;
}

.grid-container::-webkit-scrollbar-track:horizontal {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:horizontal {
    background: #4338ca;
    border-radius: 5px;
}

/* Personalizar la barra de scroll vertical */
.grid-container::-webkit-scrollbar:vertical {
    width: 10px;
}

.grid-container::-webkit-scrollbar-track:vertical {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:vertical {
    background: #4338ca;
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:hover {
    background: #3730a3;
}

/* Esquina del scroll */
.grid-container::-webkit-scrollbar-corner {
    background: rgba(0, 0, 0, 0.1);
}

        .fruit-display {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #4338ca;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            gap: 20px;
        }

       .fruit-image {
            width: 100px;
            height: 100px;
            border-radius: 10px;
            object-fit: cover;
            border: 3px solid white;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

 .fruit-image:hover {
            transform: scale(1.05);
        }

          .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }
        
         .modal-image {
            max-width: 90%;
            max-height: 90%;
            border-radius: 15px;
            border: 5px solid white;
            object-fit: contain;
            animation: zoomIn 0.3s ease;
        }

            @keyframes zoomIn {
            from {
                transform: scale(0.3);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
        }

        .close-modal:hover {
            color: #ff6b6b;
        }

        .zoom-hint {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            pointer-events: none;
        }

        .fruit-info {
            text-align: center;
        }

        .fruit-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .fruit-instruction {
            font-size: 16px;
            opacity: 0.9;
        }

.grid {
    display: grid;
    grid-template-columns: repeat(18, 40px);
    grid-template-rows: repeat(19, 40px);
    gap: 2px;
    margin: 0;
    justify-content: start;
    min-width: calc(18 * 40px + 34px);
    min-height: calc(19 * 40px + 36px); /* Añadido altura mínima */
}

.cell {
    width: 40px;
    height: 40px;
    border: 2px solid #333;
    text-align: center;
    font-weight: bold;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}


       .white {
    background-color: #f8fafc;
}

        .green {
            background-color: #86efac;
            border: 3px solid #22c55e;
        }

        .blue {
            background-color: #93c5fd;
        }

        .blocked {
            background-color: #64748b;
        }

        .filled {
            background-color: #f3f4f6;
            color: #374151;
            font-weight: bold;
        }


input[type="text"] {
    width: 100%;
    height: 100%;
    border: none;
    text-align: center;
    font-weight: bold;
    font-size: 14px;
    background: transparent;
    text-transform: uppercase;
    /* QUITAR ESTAS LÍNEAS QUE BLOQUEAN LA INTERACCIÓN */
    /* pointer-events: none; */
    caret-color: transparent;
    cursor: default;
    /* Añadir estas propiedades para móviles */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
    inputmode: none;
}

input[type="text"]:focus {
    outline: none;
    box-shadow: 0 0 0 2px #4338ca;
}

        .green input[type="text"] {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .correct {
            background-color: #f3f70f !important;
            color: white;
        }

  @media (max-width: 1024px) {
    .crossword-container {
        max-width: 95%;
        padding: 12px;
    }
    
    .grid-container {
        max-height: 450px; /* Reducido para tablets */
        padding: 12px;
    }
    
    .grid {
        grid-template-columns: repeat(18, 35px);
        grid-template-rows: repeat(19, 35px);
        gap: 1px;
        min-width: calc(18 * 35px + 17px);
        min-height: calc(19 * 35px + 18px);
    }
    
    .cell {
        width: 35px;
        height: 35px;
        font-size: 13px;
    }
    
    input[type="text"] {
        font-size: 13px;
    }
}
@media (max-width: 768px) {

      input[type="text"] {
        font-size: 12px;
        /* Forzar que no aparezca el teclado en móviles */
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    /* Asegurar que el teclado virtual sea más prominente en móvil */
    .virtual-keyboard {
        position: sticky;
        bottom: 0;
        z-index: 100;
        background-color: #2d3748;
        border-top: 3px solid #4338ca;
    }

    body {
        padding: 5px;
    }
    
    .crossword-container {
        padding: 10px;
        max-width: 100%;
    }

    .header-right {
        gap: 5px;
    }

    .timer-mini {
        font-size: 10px;
        padding: 3px 6px;
    }

    .grid-container {
        margin: 10px 0;
        padding: 8px;
        max-height: 350px; /* Reducido para móviles */
    }

    .grid {
        grid-template-columns: repeat(18, 28px);
        grid-template-rows: repeat(19, 28px);
        gap: 1px;
        min-width: calc(18 * 28px + 17px);
        min-height: calc(19 * 28px + 18px);
    }
    
    .cell {
        width: 28px;
        height: 28px;
        font-size: 12px;
    }
    
    input[type="text"] {
        font-size: 12px;
    }
    
    .fruit-display {
        flex-direction: column;
        gap: 10px;
        padding: 15px;
    }
    
    .fruit-image {
        width: 80px;
        height: 80px;
    }

    .modal-image {
        max-width: 95%;
        max-height: 95%;
    }

    .close-modal {
        top: 10px;
        right: 15px;
        font-size: 30px;
    }
    
    .fruit-name {
        font-size: 20px;
    }

    /* Barras de scroll más delgadas en móvil */
    .grid-container::-webkit-scrollbar:horizontal {
        height: 8px;
    }
    
    .grid-container::-webkit-scrollbar:vertical {
        width: 8px;
    }
}
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .timer-icon {
            font-size: 20px;
        }

   faouzielhilali/Documents/cruci.html */
/* ...existing code... */

/* Teclado Virtual */
.virtual-keyboard {
    background-color: #2d3748;
    padding: 15px;
    border-radius: 15px;
    margin: 20px auto;
    max-width: 600px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    border: 2px solid #4a5568;
}

.keyboard-row {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 8px;
}

.keyboard-row:last-child {
    margin-bottom: 0;
}

.key {
    background: linear-gradient(145deg, #4a5568, #2d3748);
    color: white;
    border: 2px solid #4a5568;
    border-radius: 8px;
    width: 50px;
    height: 50px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    text-transform: lowercase;
    user-select: none;
}

.key:hover {
    background: linear-gradient(145deg, #5a6478, #3d4758);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

.key:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    background: linear-gradient(145deg, #3d4758, #2d3748);
}

.key.special {
    background: linear-gradient(145deg, #6366f1, #4338ca);
    border-color: #4338ca;
    font-size: 18px;
}

.key.special:hover {
    background: linear-gradient(145deg, #7c3aed, #5b21b6);
}

.key.backspace {
    width: 60px;
}

/* Responsive para teclado */
@media (max-width: 768px) {
     .keyboard-selection-popup {
        width: 90% !important;
        margin: 0 auto !important;
    }
    
    .keyboard-selection-popup .swal2-title {
        font-size: 1.5rem !important;
    }
    
    .keyboard-selection-popup .swal2-content {
        font-size: 1rem !important;
    }
    .virtual-keyboard {
        max-width: 95%;
        padding: 12px;
    }
    
    .keyboard-row {
        gap: 6px;
        margin-bottom: 6px;
    }
    
    .key {
        width: 40px;
        height: 40px;
        font-size: 14px;
    }
    
    .key.backspace {
        width: 50px;
    }
}

@media (max-width: 480px) {
    .key {
        width: 35px;
        height: 35px;
        font-size: 12px;
    }
    
    .key.backspace {
        width: 45px;
    }
}

/* ...existing code... */     
        /* Añadir este estilo para la clase separator */
.separator {
    background-color: #1f2937 !important;
    color: white !important;
    border: 3px solid #374151 !important;
}
.keyboard-selection-popup {
    border-radius: 15px !important;
    font-family: Arial, sans-serif !important;
}

.keyboard-selection-popup .swal2-title {
    color: #1f2937 !important;
    font-weight: bold !important;
}

.keyboard-selection-popup .swal2-content {
    color: #4b5563 !important;
}

    </style>
</head>
<body>
   <div class="header">
    <span>←</span>
    <span style="font-size: 24px; font-weight: bold;">Crucigrama</span>
    <div class="header-right">
        <div id="timerMini" class="timer-mini">
            <span class="timer-mini-icon">⏰</span>
            <span id="timerDisplay">30</span>
        </div>
        
        <span>🍎 Frutas</span>
    </div>
</div>
 <div id="scoreDisplayContainer" class="score-display-fixed"> 
            <span class="score-icon">⭐</span>
            <span id="scorePoints">0</span>
        </div>
<div class="crossword-container">
    <div class="fruit-display" id="fruitDisplay">
        <div style="position: relative;">
            <img id="fruitImage" class="fruit-image" src="" alt="Fruta" onclick="openImageModal()">
            <div class="zoom-hint">🔍</div>
        </div>
    
    </div>
    
    <!-- Nuevo contenedor con scroll horizontal -->
    <div class="grid-container">
        <div class="grid" id="crossword">
            <!-- La cuadrícula se generará con JavaScript -->
        </div>
    </div>
</div>

<div class="virtual-keyboard">
    
</div>

<!-- Modal para imagen ampliada -->
<div id="imageModal" class="image-modal" onclick="closeImageModal()">
    <span class="close-modal" onclick="closeImageModal()">&times;</span>
    <img id="modalImage" class="modal-image" src="" alt="Fruta ampliada">
</div>


    <script>
// Añadir esta función después de la función resetGame()
// ...existing code...
function showAllFruits() {
    console.log('Mostrando todas las frutas en el crucigrama...');
    
    const grid = document.getElementById('crossword');
    grid.innerHTML = '';
    
    // CORREGIR: Usar las mismas dimensiones
    const gridRows = 19;
    const gridCols = 18;
    const gridData = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
    
    // Marcar todas las posiciones de frutas
    fruits.forEach(fruit => {
        const pos = fruit.position;
        for (let i = 0; i < fruit.name.length; i++) {
            let row, col;
            if (pos.direction === 'horizontal') {
                row = pos.row;
                col = pos.col + i;
            } else {
                row = pos.row + i;
                col = pos.col;
            }
            
            // CORREGIR: Usar gridRows y gridCols
            if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                gridData[row][col] = {
                    type: 'white',
                    letter: fruit.name[i],
                    fruitName: fruit.name,
                    number: fruit.number
                };
            }
        }
    });
    
    // Crear el grid HTML - CORREGIR: Usar gridRows y gridCols
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const cell = document.createElement('div');
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (gridData[row][col] && gridData[row][col].type === 'white') {
                // Casilla blanca con letra
                cell.className = 'cell white';
                cell.textContent = gridData[row][col].letter;
                cell.style.backgroundColor = '#c8e6c9';
                cell.style.color = '#1f2937';
                
                // Agregar números si es la primera casilla de una palabra
                fruits.forEach(fruit => {
                    if (fruit.position.row === row && fruit.position.col === col) {
                        const numberSpan = document.createElement('span');
                        numberSpan.textContent = fruit.number;
                        numberSpan.style.position = 'absolute';
                        numberSpan.style.top = '2px';
                        numberSpan.style.left = '2px';
                        numberSpan.style.fontSize = '8px';
                        numberSpan.style.fontWeight = 'bold';
                        numberSpan.style.color = '#000';
                        numberSpan.style.zIndex = '10';
                        cell.appendChild(numberSpan);
                    }
                });
            } else {
                // Casilla negra
                cell.className = 'cell black';
                cell.style.backgroundColor = '#000';
            }
            
            grid.appendChild(cell);
        }
    }
    
    console.log('Todas las frutas mostradas en el crucigrama');
}

// Función para volver al modo de juego normal
function returnToGame() {
    console.log('Regresando al modo de juego normal...');
    updateFruitDisplay();
    generateGrid();
    
    // Solo reiniciar timer si no hay uno activo
    if (!timer) {
        startTimer();
    }
}

// Función para mostrar estadísticas de las frutas
function showFruitsStats() {
    console.log('=== ESTADÍSTICAS DE FRUTAS ===');
    
    const horizontalFruits = fruits.filter(f => f.position.direction === 'horizontal');
    const verticalFruits = fruits.filter(f => f.position.direction === 'vertical');
    const fruitsWithSpaces = fruits.filter(f => f.name.includes(' '));
    
    console.log(`Total de frutas: ${fruits.length}`);
    console.log(`Horizontales: ${horizontalFruits.length}`);
    console.log(`Verticales: ${verticalFruits.length}`);
    console.log(`Con espacios: ${fruitsWithSpaces.length}`);
    
    console.log('\n=== FRUTAS HORIZONTALES ===');
    horizontalFruits.forEach((fruit, i) => {
        console.log(`${i+1}. ${fruit.name} - Fila ${fruit.position.row}, Col ${fruit.position.col}`);
    });
    
    console.log('\n=== FRUTAS VERTICALES ===');
    verticalFruits.forEach((fruit, i) => {
        console.log(`${i+1}. ${fruit.name} - Fila ${fruit.position.row}, Col ${fruit.position.col}`);
    });
    
    if (fruitsWithSpaces.length > 0) {
        console.log('\n=== FRUTAS CON ESPACIOS ===');
        fruitsWithSpaces.forEach(fruit => {
            console.log(`- ${fruit.name}`);
        });
    }
}

// Función para verificar intersecciones entre frutas
function checkIntersections() {
    console.log('=== VERIFICANDO INTERSECCIONES ===');
    
    const intersections = [];
    
    for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
            const fruit1 = fruits[i];
            const fruit2 = fruits[j];
            
            // Solo verificar si tienen direcciones diferentes
            if (fruit1.position.direction !== fruit2.position.direction) {
                const intersection = findIntersection(fruit1, fruit2);
                if (intersection) {
                    intersections.push({
                        fruit1: fruit1.name,
                        fruit2: fruit2.name,
                        position: intersection.position,
                        letter: intersection.letter
                    });
                }
            }
        }
    }
    
    console.log(`Total de intersecciones encontradas: ${intersections.length}`);
    intersections.forEach(int => {
        console.log(`${int.fruit1} ∩ ${int.fruit2} = "${int.letter}" en (${int.position.row}, ${int.position.col})`);
    });
    
    return intersections;
}

// Función auxiliar para encontrar intersección entre dos frutas
function findIntersection(fruit1, fruit2) {
    const pos1 = fruit1.position;
    const pos2 = fruit2.position;
    
    for (let i = 0; i < fruit1.name.length; i++) {
        for (let j = 0; j < fruit2.name.length; j++) {
            let row1, col1, row2, col2;
            
            if (pos1.direction === 'horizontal') {
                row1 = pos1.row;
                col1 = pos1.col + i;
            } else {
                row1 = pos1.row + i;
                col1 = pos1.col;
            }
            
            if (pos2.direction === 'horizontal') {
                row2 = pos2.row;
                col2 = pos2.col + j;
            } else {
                row2 = pos2.row + j;
                col2 = pos2.col;
            }
            
            // Si las posiciones coinciden y las letras son iguales
            if (row1 === row2 && col1 === col2 && fruit1.name[i] === fruit2.name[j]) {
                return {
                    position: { row: row1, col: col1 },
                    letter: fruit1.name[i]
                };
            }
        }
    }
    
    return null;
}


// ...existing code...
// ...existing code...
// ...existing code...
const fruits = [
    // Palabras Horizontales (14 palabras)
    {
        name: 'NECTARINA',
        image: 'https://fawzinoo.github.io/Fotos/nectarina.png',
        audio: 'https://fawzinoo.github.io/audios/La nectarina.mp3',
        position: { row: 0, col: 0, direction: 'horizontal' },
        number: 1
    },
    {
        name: 'LIMON',
        image: 'https://fawzinoo.github.io/Fotos/limon.png',
        audio: 'https://fawzinoo.github.io/audios/El limon.mp3',
        position: { row: 0, col: 11, direction: 'horizontal' },
        number: 4
    },
    {
        name: 'SANDIA',
        image: 'https://fawzinoo.github.io/Fotos/sandía.png',
        audio: 'https://fawzinoo.github.io/audios/La sandia.mp3',
        position: { row: 2, col: 11, direction: 'horizontal' },
        number: 6
    },
    {
        name: 'UVA',
        image: 'https://fawzinoo.github.io/Fotos/uva.png',
        audio: 'https://fawzinoo.github.io/audios/Las uvas.mp3',
        position: { row: 3, col: 2, direction: 'horizontal' },
        number: 7
    },
    {
        name: 'CHIRIMOYA',
        image: 'https://fawzinoo.github.io/Fotos/chirimoya.png',
        audio: 'https://fawzinoo.github.io/audios/La chirimoya.mp3',
        position: { row: 4, col: 5, direction: 'horizontal' },
        number: 8
    },
    {
        name: 'KIWI',
        image: 'https://fawzinoo.github.io/Fotos/kiwi.png',
        audio: 'https://fawzinoo.github.io/audios/El kiwi.mp3',
        position: { row: 6, col: 12, direction: 'horizontal' },
        number: 11
    },
    {
        name: 'PERA',
        image: 'https://fawzinoo.github.io/Fotos/pera.png',
        audio: 'https://fawzinoo.github.io/audios/La pera.mp3',
        position: { row: 7, col: 2, direction: 'horizontal' },
        number: 12
    },
    {
        name: 'AGUACATE',
        image: 'https://fawzinoo.github.io/Fotos/aguacate.png',
        audio: 'https://fawzinoo.github.io/audios/El aguacate.mp3',
        position: { row: 8, col: 10, direction: 'horizontal' },
        number: 14
    },
    {
        name: 'FRAMBUESA',
        image: 'https://fawzinoo.github.io/Fotos/frambuesa.png',
        audio: 'https://fawzinoo.github.io/audios/La frambuesa.mp3',
        position: { row: 10, col: 2, direction: 'horizontal' },
        number: 16
    },
    {
        name: 'MANZANA',
        image: 'https://fawzinoo.github.io/Fotos/manzana.png',
        audio: 'https://fawzinoo.github.io/audios/La manzana.mp3',
        position: { row: 12, col: 4, direction: 'horizontal' },
        number: 17
    },
    {
        name: 'PLATANO',
        image: 'https://fawzinoo.github.io/Fotos/platano.png',
        audio: 'https://fawzinoo.github.io/audios/El platano.mp3',
        position: { row: 14, col: 10, direction: 'horizontal' },
        number: 21
    },
    {
        name: 'CEREZA',
        image: 'https://fawzinoo.github.io/Fotos/cereza.png',
        audio: 'https://fawzinoo.github.io/audios/La cereza.mp3',
        position: { row: 15, col: 1, direction: 'horizontal' },
        number: 22
    },
    {
        name: 'PAPAYA',
        image: 'https://fawzinoo.github.io/Fotos/papaya.png',
        audio: 'https://fawzinoo.github.io/audios/La papaya.mp3',
        position: { row: 18, col: 3, direction: 'horizontal' },
        number: 24
    },
    {
        name: 'MANGO',
        image: 'https://fawzinoo.github.io/Fotos/mango.png',
        audio: 'https://fawzinoo.github.io/audios/El mango.mp3',
        position: { row: 18, col: 12, direction: 'horizontal' },
        number: 25
    },

    // Palabras Verticales (11 palabras)
    {
        name: 'NARANJA',
        image: 'https://fawzinoo.github.io/Fotos/naranja.png',
        audio: 'https://fawzinoo.github.io/audios/La naranja.mp3',
        position: { row: 12, col: 6, direction: 'vertical' },
        number: 1
    },
    {
        name: 'CAQUI',
        image: 'https://fawzinoo.github.io/Fotos/caqui.png',
        audio: 'https://fawzinoo.github.io/audios/El Caqui.mp3',
        position: { row: 0, col: 2, direction: 'vertical' },
        number: 2
    },
    {
        name: 'ALBARICOQUE',
        image: 'https://fawzinoo.github.io/Fotos/albaricoque.png',
        audio: 'https://fawzinoo.github.io/audios/El albaricoque.mp3',
        position: { row: 0, col: 8, direction: 'vertical' },
        number: 3
    },
    {
        name: 'MANDARINA',
        image: 'https://fawzinoo.github.io/Fotos/mandarina.png',
        audio: 'https://fawzinoo.github.io/audios/La mandarina.mp3',
        position: { row: 0, col: 13, direction: 'vertical' },
        number: 5
    },
    {
        name: 'FRESA',
        image: 'https://fawzinoo.github.io/Fotos/fresa.png',
        audio: 'https://fawzinoo.github.io/audios/La fresa.mp3',
        position: { row: 6, col: 4, direction: 'vertical' },
        number: 9
    },
    {
        name: 'GRANADA',
        image: 'https://fawzinoo.github.io/Fotos/granada.png',
        audio: 'https://fawzinoo.github.io/audios/La granada.mp3',
        position: { row: 6, col: 10, direction: 'vertical' },
        number: 10
    },
    {
        name: 'MELON',
        image: 'https://fawzinoo.github.io/Fotos/melon.png',
        audio: 'https://fawzinoo.github.io/audios/El melon.mp3',
        position: { row: 7, col: 17, direction: 'vertical' },
        number: 13
    },
    
    {
        name: 'CIRUELA',
        image: 'https://fawzinoo.github.io/Fotos/ciruela.png',
        audio: 'https://fawzinoo.github.io/audios/La ciruela.mp3',
        position: { row: 8, col: 14, direction: 'vertical' },
        number: 18
    },
    {
        name: 'COCO',
        image: 'https://fawzinoo.github.io/Fotos/coco.png',
        audio: 'https://fawzinoo.github.io/audios/El coco.mp3',
        position: { row: 13, col: 1, direction: 'vertical' },
        number: 19
    },
    {
        name: 'POMELO',
        image: 'https://fawzinoo.github.io/Fotos/pomelo.png',
        audio: 'https://fawzinoo.github.io/audios/El pomelo.mp3',
        position: { row: 13, col: 16, direction: 'vertical' },
        number: 20
    },
    {
        name: 'PIÑA',
        image: 'https://fawzinoo.github.io/Fotos/piña.png',
        audio: 'https://fawzinoo.github.io/audios/La pina.mp3',
        position: { row: 15, col: 8, direction: 'vertical' },
        number: 23
    }
];
// ...existing code...
// ...existing code...




        let currentFruitIndex = 0;
        let currentFruit = fruits[currentFruitIndex];
        let completedFruits = new Set();
        let availableFruits = []; 
         let incompleteFruits = [];

                // Variables del timer
        let timer = null;
        let timeLeft = 20;
        let currentRound = 1;
        let totalRounds = 0;

   function playAudio(audioUrl) {
    try {
        // Detener cualquier audio previo que pueda estar reproduciéndose
        if (window.currentAudio) {
            window.currentAudio.pause();
            window.currentAudio.currentTime = 0;
        }
        
        const audio = new Audio(audioUrl);
        window.currentAudio = audio; // Guardar referencia global
        
        audio.volume = 0.6; // Reducir volumen para evitar saturación
        audio.preload = 'auto';
        
        // Manejar errores de carga
        audio.onerror = function() {
            console.log('Error al cargar el audio:', audioUrl);
            window.currentAudio = null;
        };
        
        // Limpiar referencia cuando termine
        audio.onended = function() {
            window.currentAudio = null;
        };
        
        // Reproducir cuando esté listo
        const playPromise = audio.play();
        
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log('Audio reproducido correctamente');
            }).catch(error => {
                console.log('Error al reproducir audio:', error);
                window.currentAudio = null;
            });
        }
        
    } catch (error) {
        console.log('Error creando objeto Audio:', error);
    }
}
function stopAllAudio() {
    // Detener audio de frutas
    if (window.currentAudio) {
        try {
            window.currentAudio.pause();
            window.currentAudio.currentTime = 0;
        } catch(e) {}
        window.currentAudio = null;
    }
    
    // Detener oscilador de éxito
    if (window.currentOscillator) {
        try {
            window.currentOscillator.stop();
            window.currentOscillator.disconnect();
        } catch(e) {}
        window.currentOscillator = null;
    }
}

// Añadir función para verificar elementos DOM
function verifyDOMElements() {
    const timerMini = document.getElementById('timerMini');
    const timerDisplay = document.getElementById('timerDisplay');
    
    console.log('Verificando elementos DOM:');
    console.log('timerMini:', timerMini ? 'OK' : 'NO ENCONTRADO');
    console.log('timerDisplay:', timerDisplay ? 'OK' : 'NO ENCONTRADO');
    
    return timerMini && timerDisplay;
}

        // Función para iniciar el timer
function startTimer() {
    console.log('Iniciando timer para:', currentFruit.name);
    
    // Limpiar timer anterior si existe
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    
    timeLeft = 20;
    updateTimerDisplay();
    
    timer = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        console.log(`Timer: ${timeLeft} segundos restantes para ${currentFruit.name}`);
        
        // Cambiar color cuando quedan 10 segundos
        const timerMini = document.getElementById('timerMini');
        if (timerMini) {
            if (timeLeft <= 10) {
                timerMini.classList.add('warning');
            } else {
                timerMini.classList.remove('warning');
            }
        }
        
        // Tiempo agotado
        if (timeLeft <= 0) {
            console.log('¡TIEMPO AGOTADO! Ejecutando timeout...');
            clearInterval(timer);
            timer = null;
            
            // Ejecutar inmediatamente sin setTimeout
            handleTimeOut();
        }
    }, 1000);
    
    console.log('Timer iniciado correctamente');
}
        // Función para actualizar la visualización del timer
function updateTimerDisplay() {
    const timerDisplay = document.getElementById('timerDisplay');
    if (timerDisplay) {
        timerDisplay.textContent = timeLeft;
    } else {
        console.error('Elemento timerDisplay no encontrado');
    }
}

function updateScoreDisplay() {
    const scorePointsElement = document.getElementById('scorePoints');
    if (scorePointsElement) {
        scorePointsElement.textContent = completedFruits.size; // Usamos el tamaño del Set de frutas completadas
    } else {
        console.error('Elemento scorePoints no encontrado');
    }
}

        // Función para detener el timer
  function stopTimer() {
    console.log('Deteniendo timer...');
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    
    const timerMini = document.getElementById('timerMini');
    if (timerMini) {
        timerMini.classList.remove('warning');
    }
    console.log('Timer detenido');
}

// ... (código existente) ...
// ... (código existente) ...

// ... (código existente como keyboardLayouts, loadKeyboardLayoutPreference, saveKeyboardLayoutPreference, buildVirtualKeyboardHTML) ...
// ... (código existente como keyboardLayouts, loadKeyboardLayoutPreference, saveKeyboardLayoutPreference, buildVirtualKeyboardHTML) ...
// ... (asegúrate que las funciones keyboardLayouts, loadKeyboardLayoutPreference, saveKeyboardLayoutPreference, buildVirtualKeyboardHTML están definidas ANTES de esta función) ...

function initializeVirtualKeyboard() {
    console.log('=== INICIALIZANDO TECLADO VIRTUAL ===');
    
    loadKeyboardLayoutPreference();
    buildVirtualKeyboardHTML(currentKeyboardLayout);

    const keys = document.querySelectorAll('.virtual-keyboard .key');
    console.log('Teclas encontradas:', keys.length);
    
    const LONG_PRESS_DURATION = 600;
    let pressTimer = null;
    let isLongPress = false;

    keys.forEach((keyNode, index) => {
        const key = keyNode.cloneNode(true);
        keyNode.parentNode.replaceChild(key, keyNode);

        const keyChar = key.dataset.key;
        const action = key.dataset.action;
        
        console.log(`Tecla ${index}: char="${keyChar}", action="${action}"`);

        const handleStartPress = (event) => {
            event.preventDefault();
            isLongPress = false;
            key.style.transform = 'translateY(2px)';
            
            console.log(`Tecla presionada: char="${keyChar}", action="${action}"`);

            if (action === 'backspace') {
                console.log('BACKSPACE detectado');
                processVirtualBackspace();
                return;
            }

           // ... (dentro de handleStartPress en initializeVirtualKeyboard) ...

         // ... (dentro de handleStartPress en initializeVirtualKeyboard) ...

            if (action === 'settings') {
                console.log('SETTINGS detectado - Mostrando SweetAlert');
                
                Swal.fire({
                    title: '⚙️ Teclado',
                    html: `
                        <div style="text-align: left; margin: 10px 0;">
                            <label style="display: block; margin: 8px 0; cursor: pointer;">
                                <input type="radio" name="keyboard" value="qwerty" ${currentKeyboardLayout === 'qwerty' ? 'checked' : ''} style="margin-right: 8px;">
                                <strong>QWERTY</strong>
                            </label>
                            <label style="display: block; margin: 8px 0; cursor: pointer;">
                                <input type="radio" name="keyboard" value="azerty" ${currentKeyboardLayout === 'azerty' ? 'checked' : ''} style="margin-right: 8px;">
                                <strong>AZERTY</strong>
                            </label>
                        </div>
                    `,
                    showCancelButton: true,
                    confirmButtonText: 'Aplicar',
                    cancelButtonText: 'Cancelar',
                    confirmButtonColor: '#4338ca',
                    cancelButtonColor: '#6b7280',
                    background: '#f8fafc',
                    customClass: {
                        popup: 'keyboard-selection-popup'
                    },
                    preConfirm: () => {
                        const selectedRadio = document.querySelector('input[name="keyboard"]:checked');
                        if (selectedRadio) {
                            return selectedRadio.value;
                        }
                        return null;
                    }
                }).then((result) => {
                    if (result.isConfirmed && result.value) {
                        const chosenLayout = result.value;
                        
                        if (currentKeyboardLayout !== chosenLayout) {
                            console.log(`Cambiando teclado a ${chosenLayout}`);
                            currentKeyboardLayout = chosenLayout;
                            saveKeyboardLayoutPreference();
                            initializeVirtualKeyboard();
                            
                            // Mostrar confirmación con SweetAlert2
                            Swal.fire({
                                title: '✅ ¡Listo!',
                                text: `Teclado cambiado a ${currentKeyboardLayout.toUpperCase()}`,
                                icon: 'success',
                                timer: 2000,
                                showConfirmButton: false,
                                toast: true,
                                position: 'top-end',
                                background: '#10b981',
                                color: 'white'
                            });
                        } else {
                            // Ya está en esa distribución
                            Swal.fire({
                                title: 'ℹ️ Sin cambios',
                                text: `El teclado ya está en ${currentKeyboardLayout.toUpperCase()}`,
                                icon: 'info',
                                timer: 1500,
                                showConfirmButton: false,
                                toast: true,
                                position: 'top-end'
                            });
                        }
                    }
                    
                    key.style.transform = '';
                });
                return;
            }
            
            if (!keyChar) return;

            pressTimer = setTimeout(() => {
                isLongPress = true;
                if (keyChar === 'N') {
                    console.log('Pulsación larga en N -> Ñ');
                    processVirtualKeyPress('Ñ');
                }
            }, LONG_PRESS_DURATION);
        };

        const handleEndPress = (event) => {
            event.preventDefault();
            clearTimeout(pressTimer);
            key.style.transform = '';

            if (action === 'backspace' || action === 'settings') {
                return;
            }
            
            if (!keyChar) return;

            if (!isLongPress) {
                if (keyChar === 'N') {
                    processVirtualKeyPress('N');
                } else {
                    processVirtualKeyPress(keyChar);
                }
            }
        };

        key.addEventListener('mousedown', handleStartPress);
        key.addEventListener('mouseup', handleEndPress);
        key.addEventListener('mouseleave', () => {
            clearTimeout(pressTimer);
            key.style.transform = '';
        });

        key.addEventListener('touchstart', handleStartPress, { passive: false });
        key.addEventListener('touchend', handleEndPress);
        key.addEventListener('touchcancel', () => {
            clearTimeout(pressTimer);
            key.style.transform = '';
        });
    });
    
    console.log(`Teclado virtual (${currentKeyboardLayout.toUpperCase()}) inicializado correctamente.`);
    console.log('=== FIN INICIALIZACIÓN TECLADO ===');
}
// Modificar la función initializeGame para incluir el teclado
function initializeGame() {
    console.log('=== INICIALIZANDO JUEGO ===');
    
    if (!verifyDOMElements()) {
        console.error('Error: Elementos del DOM no encontrados');
        return;
    }
    
    initializeRandomFruits();
    updateFruitDisplay();
    generateGrid();
    startTimer();
    initializeVirtualKeyboard(); 
    updateScoreDisplay(); 
    
    
    console.log('=== JUEGO INICIALIZADO ===');
}

// Cambiar la inicialización al final del script de:
// initializeRandomFruits();
// updateFruitDisplay();
// generateGrid();
// startTimer();

// A:
// Esperar a que el DOM esté completamente cargado
document.addEventListener('DOMContentLoaded', function() {
    initializeGame();
});



        // Función cuando se agota el tiempo
function handleTimeOut() {
    console.log('=== TIMEOUT EJECUTADO ===');
    console.log(`Tiempo agotado para: ${currentFruit.name}`);
    console.log(`Fruta actual index: ${currentFruitIndex}`);
    console.log(`Completadas: ${Array.from(completedFruits)}`);
    console.log(`Disponibles: ${availableFruits}`);
    
    // Añadir a frutas incompletas si no está completada
    if (!completedFruits.has(currentFruitIndex)) {
        incompleteFruits.push(currentFruitIndex);
        console.log(`Añadida ${currentFruit.name} (${currentFruitIndex}) a incompletas`);
    }
    
    console.log(`Frutas incompletas total: ${incompleteFruits}`);
    
    // Buscar siguiente fruta inmediatamente
    console.log('Buscando siguiente fruta...');
    findNextAvailableFruit();
}


// Nueva función para encontrar la siguiente fruta de forma más directa
function findNextAvailableFruit() {
    console.log('=== BUSCANDO SIGUIENTE FRUTA ===');
    
    let nextIndex = -1;
    let currentIndexInArray = availableFruits.indexOf(currentFruitIndex);
    
    // Buscar desde la siguiente posición en adelante
    for (let i = currentIndexInArray + 1; i < availableFruits.length; i++) {
        if (!completedFruits.has(availableFruits[i])) {
            nextIndex = availableFruits[i];
            break;
        }
    }
    
    // Si no encontró nada, buscar desde el principio
    if (nextIndex === -1) {
        for (let i = 0; i < currentIndexInArray; i++) {
            if (!completedFruits.has(availableFruits[i])) {
                nextIndex = availableFruits[i];
                break;
            }
        }
    }
    
    if (nextIndex !== -1) {
        currentFruitIndex = nextIndex;
        currentFruit = fruits[currentFruitIndex];
        
        updateFruitDisplay();
        generateGrid();
        initializeVirtualKeyboard(); // AÑADIR
        startTimer();
    } else {
        checkForIncompleteRounds();
    }
}

        // Función para mezclar array aleatoriamente (algoritmo Fisher-Yates)
 function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

// Inicializar frutas disponibles de forma aleatoria
function initializeRandomFruits() {
    console.log('Inicializando frutas aleatorias...');
    availableFruits = shuffleArray(fruits.map((_, index) => index));
    currentFruitIndex = availableFruits[0];
    currentFruit = fruits[currentFruitIndex];
    console.log('Primera fruta:', currentFruit.name);
    console.log('Orden aleatorio:', availableFruits.map(i => fruits[i].name));
}



  function openImageModal() {
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const fruitImage = document.getElementById('fruitImage');
            
            modalImage.src = fruitImage.src;
            modal.style.display = 'flex';
            
            // Prevenir scroll del body cuando el modal está abierto
            document.body.style.overflow = 'hidden';
        }

        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            modal.style.display = 'none';
            
            // Restaurar scroll del body
            document.body.style.overflow = 'auto';
        }
         // Cerrar modal con tecla Escape
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeImageModal();
            }
        });
         // Prevenir que el clic en la imagen cierre el modal
        document.getElementById('modalImage').addEventListener('click', function(event) {
            event.stopPropagation();
        });

        function updateFruitDisplay() {
            document.getElementById('fruitImage').src = currentFruit.image;

        }
        // Generar sonido de éxito
 function playSuccessSound() {
    try {
        // Detener cualquier oscilador previo
        if (window.currentOscillator) {
            try {
                window.currentOscillator.stop();
                window.currentOscillator.disconnect();
            } catch(e) {}
            window.currentOscillator = null;
        }
        
        // Usar un solo contexto de audio global
        if (!window.audioContext) {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const audioContext = window.audioContext;
        
        // Asegurar que el contexto esté activo
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // Crear oscilador
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // Guardar referencia para poder detenerlo
        window.currentOscillator = oscillator;
        
        // Conectar
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Configurar
        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
        oscillator.type = 'sine';
        
        // Volumen con fade
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
        
        // Reproducir
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
        
        // Limpiar cuando termine
        oscillator.onended = function() {
            try {
                oscillator.disconnect();
                gainNode.disconnect();
            } catch(e) {}
            window.currentOscillator = null;
        };
        
    } catch (e) {
        console.log('Error en audio:', e);
    }
}


function playPointScoredSound() {
    try {
        if (!window.audioContext) {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const audioContext = window.audioContext;
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        // Sonido de triunfo: una nota más alta, más brillante y con más volumen
        oscillator.frequency.setValueAtTime(880.00, audioContext.currentTime); // A5 - una nota más alta y brillante
        oscillator.type = 'sawtooth'; // 'sawtooth' o 'square' pueden sonar más "brillantes" o "electrónicos" que 'triangle' o 'sine'

        // Ajustar la envolvente de ganancia para más volumen y un decaimiento ligeramente más largo
        const peakVolume = 0.5; // Aumentar el volumen máximo (rango 0.0 a 1.0)
        const attackTime = 0.02; // Tiempo rápido para alcanzar el volumen máximo
        const decayTime = 0.3;   // Tiempo para que el sonido decaiga
        const totalDuration = 0.4; // Duración total del sonido

        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(peakVolume, audioContext.currentTime + attackTime);
        // Mantener el volumen pico por un momento antes de decaer
        gainNode.gain.setValueAtTime(peakVolume, audioContext.currentTime + attackTime + 0.05); 
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + totalDuration);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + totalDuration);

        oscillator.onended = function() {
            try {
                oscillator.disconnect();
                gainNode.disconnect();
            } catch(e) {}
        };
    } catch (e) {
        console.log('Error en audio de punto ganado:', e);
    }
}


function triggerPointScoredEffects() {
    const scoreDisplayElement = document.getElementById('scoreDisplayContainer'); // El contenedor principal
    
    if (scoreDisplayElement) {
        playPointScoredSound(); // Reproducir sonido

        scoreDisplayElement.classList.add('animate-score'); // Añadir clase para animación

        // Quitar la clase después de que la animación termine para poder reutilizarla
        setTimeout(() => {
            scoreDisplayElement.classList.remove('animate-score');
        }, 600); // Duración de la animación (0.6s)
    }
}

function processVirtualKeyPress(keyValue) {
    let currentTargetInput = logicallyActiveInput;

    if (!currentTargetInput || !currentTargetInput.closest('.green input')) {
        const firstGreenInput = document.querySelector('.green input');
        if (firstGreenInput) {
            firstGreenInput.focus(); // Esto actualizará logicallyActiveInput a través del listener 'focusin'
            currentTargetInput = logicallyActiveInput;
        }
    }

    if (!currentTargetInput) {
        console.log('No hay input activo para el teclado virtual.');
        return;
    }

    virtualKeyboardIsWriting = true; // Indicar que el teclado virtual va a operar
    currentTargetInput.readOnly = false;
    currentTargetInput.value = keyValue.toUpperCase();
    currentTargetInput.readOnly = true;
    virtualKeyboardIsWriting = false; // El teclado virtual ha terminado de operar en ESTE input

    const nextInput = getNextInput(currentTargetInput);
    if (nextInput) {
        setTimeout(() => {
            // Cuando el foco se mueva, virtualKeyboardIsWriting será false,
            // permitiendo que el listener 'focusin' global configure readOnly.
            nextInput.focus();
            ensureInputVisible(nextInput);
        }, 10); // Timeout corto para asegurar que el DOM se actualice
    }
    setTimeout(checkAnswerAutomatic, 100);
}
// ... (código existente) ...

function processVirtualBackspace() {
    let currentTargetInput = logicallyActiveInput;

    // Asegurarse de tener un input objetivo
    if (!currentTargetInput || !currentTargetInput.closest('.green input')) {
        const firstGreenInput = document.querySelector('.green input');
        if (firstGreenInput) {
            // Al enfocar, el listener 'focusin' global actualizará logicallyActiveInput
            // y se encargará de la visibilidad y el estado readOnly inicial.
            firstGreenInput.focus();
            currentTargetInput = logicallyActiveInput; // Actualizar currentTargetInput después del foco
        }
    }

    if (!currentTargetInput) {
        console.log('No hay input activo para el backspace virtual.');
        return; // Salir si no hay dónde operar
    }

    if (currentTargetInput.value) {
        // Caso 1: El input actual tiene contenido, borrarlo.
        virtualKeyboardIsWriting = true; // Indicar operación del teclado virtual
        currentTargetInput.readOnly = false; // Permitir modificación
        currentTargetInput.value = '';       // Borrar contenido
        currentTargetInput.readOnly = true;  // Restaurar solo lectura
        virtualKeyboardIsWriting = false; // Terminar operación del teclado virtual
    } else {
        // Caso 2: El input actual está vacío. Intentar moverse al anterior y borrar su contenido.
        const prevInput = getPreviousInput(currentTargetInput);
        if (prevInput) {
            // Mover el foco al input anterior.
            // El listener 'focusin' global se activará, actualizará logicallyActiveInput,
            // y llamará a ensureInputVisible.
            // En este punto, virtualKeyboardIsWriting es false, por lo que focusin
            // pondrá prevInput en readOnly=true.
            prevInput.focus();

            // Usar un micro-timeout para permitir que el evento de foco se procese completamente
            // (incluyendo la actualización de logicallyActiveInput por el listener 'focusin')
            // antes de intentar borrar el contenido del nuevo input activo.
            setTimeout(() => {
                // Ahora, logicallyActiveInput debería ser el prevInput.
                // Verificar que el foco se haya movido correctamente y que el nuevo input tenga valor.
                if (logicallyActiveInput && logicallyActiveInput === prevInput && logicallyActiveInput.value) {
                    virtualKeyboardIsWriting = true; // Indicar operación del teclado virtual
                    logicallyActiveInput.readOnly = false; // Permitir modificación
                    logicallyActiveInput.value = '';       // Borrar contenido del (ahora) input activo
                    logicallyActiveInput.readOnly = true;  // Restaurar solo lectura
                    virtualKeyboardIsWriting = false; // Terminar operación del teclado virtual
                }
                // ensureInputVisible ya es llamado por el listener 'focusin' global
                // con su propio setTimeout, por lo que no es estrictamente necesario aquí
                // a menos que se necesite un ajuste de visibilidad inmediato post-borrado.
            }, 10); // Un timeout muy corto (10ms) es usualmente suficiente.
        }
        // Si no hay prevInput, no se hace nada más.
    }
    setTimeout(checkAnswerAutomatic, 100); // Verificar respuesta después de la operación
}

function generateGrid() {
    const grid = document.getElementById('crossword');
    grid.innerHTML = '';
    
    const gridRows = 19;
    const gridCols = 18;
    const gridData = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
    
    fruits.forEach(fruit => {
        const pos = fruit.position;
        for (let i = 0; i < fruit.name.length; i++) {
            let row, col;
            if (pos.direction === 'horizontal') {
                row = pos.row;
                col = pos.col + i;
            } else {
                row = pos.row + i;
                col = pos.col;
            }
            
            if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                if (!gridData[row][col]) {
                    gridData[row][col] = { type: 'white', letters: [] };
                }
                gridData[row][col].letters.push({
                    letter: fruit.name[i],
                    fruitIndex: fruits.indexOf(fruit),
                    letterIndex: i
                });
            }
        }
    });
    
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const cell = document.createElement('div');
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (gridData[row][col] && gridData[row][col].type === 'white') {
                cell.className = 'cell white';
                
                const belongsToCurrentFruit = gridData[row][col].letters.some(
                    letterData => letterData.fruitIndex === currentFruitIndex
                );
                
                if (belongsToCurrentFruit) {
                    cell.classList.add('green');
                    
                    const completedLetter = gridData[row][col].letters.find(
                        letterData => completedFruits.has(letterData.fruitIndex)
                    );
                    
                    if (completedLetter) {
                        cell.textContent = completedLetter.letter;
                        cell.style.backgroundColor = '#fef3c7';
                        cell.style.color = '#1f2937';
                        cell.classList.add('filled-intersection');
                    } else {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        // input.readOnly = true; // El listener focusin global se encargará de esto
                        input.inputMode = 'none'; // Para móviles
                        input.autocomplete = 'off';
                        input.style.caretColor = 'transparent'; // Ocultar cursor nativo
                        
                        // QUITAR ESTOS LISTENERS BLOQUEANTES:
                        // input.addEventListener('keydown', function(e) {
                        //     e.preventDefault();
                        //     e.stopPropagation();
                        //     return false;
                        // });
                        // 
                        // input.addEventListener('input', function(e) {
                        //     e.preventDefault();
                        //     return false;
                        // });
                        
                        cell.appendChild(input);
                    }
                } else {
                    const completedLetter = gridData[row][col].letters.find(
                        letterData => completedFruits.has(letterData.fruitIndex)
                    );
                    
                    if (completedLetter) {
                        cell.textContent = completedLetter.letter;
                        cell.style.backgroundColor = '#fef3c7';
                        cell.style.color = '#1f2937';
                        cell.classList.add('filled');
                    }
                }
       
            } else {
                cell.className = 'cell black';
                cell.style.backgroundColor = '#000';
            }
            
            grid.appendChild(cell);
        }
    }
    
     setTimeout(() => {
        const firstInput = document.querySelector('.green input');
        if (firstInput) {
            firstInput.focus();
            ensureInputVisible(firstInput); // Añadir aquí
        }
        centerOnGreenWord(); // centerOnGreenWord también podría hacer scroll, revisa si hay conflicto
    }, 100);
}
// ... (código existente) ...

// ... (reemplaza la función centerOnGreenWord existente) ...

function centerOnGreenWord() {
    const gridContainer = document.querySelector('.grid-container');
    const greenCells = document.querySelectorAll('.green');
    
    if (greenCells.length === 0 || !gridContainer) {
        console.log('No hay celdas verdes o contenedor del grid');
        return;
    }
    
    console.log(`Centrando palabra con ${greenCells.length} celdas verdes`);
    
    // Obtener las coordenadas de grid de todas las celdas verdes
    const greenPositions = Array.from(greenCells).map(cell => ({
        row: parseInt(cell.dataset.row),
        col: parseInt(cell.dataset.col),
        element: cell
    }));
    
    // Ordenar las posiciones según la dirección de la palabra
    const pos = currentFruit.position;
    if (pos.direction === 'horizontal') {
        greenPositions.sort((a, b) => a.col - b.col);
    } else {
        greenPositions.sort((a, b) => a.row - b.row);
    }
    
    // Obtener la primera y última celda de la palabra
    const firstCell = greenPositions[0].element;
    const lastCell = greenPositions[greenPositions.length - 1].element;
    
    // Calcular las dimensiones del grid completo
    const allCells = document.querySelectorAll('.cell');
    const cellWidth = firstCell.offsetWidth + 2; // +2 por el gap
    const cellHeight = firstCell.offsetHeight + 2; // +2 por el gap
    
    // Calcular posiciones absolutas de la primera y última celda
    const firstCellRect = firstCell.getBoundingClientRect();
    const lastCellRect = lastCell.getBoundingClientRect();
    const containerRect = gridContainer.getBoundingClientRect();
    
    // Posiciones relativas al contenido scrolleable
    const firstCellLeft = firstCellRect.left - containerRect.left + gridContainer.scrollLeft;
    const firstCellTop = firstCellRect.top - containerRect.top + gridContainer.scrollTop;
    const lastCellRight = lastCellRect.right - containerRect.left + gridContainer.scrollLeft;
    const lastCellBottom = lastCellRect.bottom - containerRect.top + gridContainer.scrollTop;
    
    // Calcular los límites de toda la palabra
    const wordLeft = firstCellLeft;
    const wordTop = firstCellTop;
    const wordRight = lastCellRight;
    const wordBottom = lastCellBottom;
    const wordWidth = wordRight - wordLeft;
    const wordHeight = wordBottom - wordTop;
    
    console.log(`Palabra completa: left=${wordLeft}, top=${wordTop}, right=${wordRight}, bottom=${wordBottom}`);
    console.log(`Dimensiones palabra: ancho=${wordWidth}, alto=${wordHeight}`);
    
    // Dimensiones del contenedor visible
    const containerWidth = gridContainer.clientWidth;
    const containerHeight = gridContainer.clientHeight;
    
    // Margen mínimo alrededor de la palabra
    const margin = 30;
    
    // Calcular scroll horizontal
    let targetScrollLeft = gridContainer.scrollLeft;
    
    if (wordWidth + (margin * 2) <= containerWidth) {
        // La palabra cabe completa con margen - centrarla
        const wordCenter = wordLeft + (wordWidth / 2);
        targetScrollLeft = wordCenter - (containerWidth / 2);
    } else {
        // La palabra es más ancha que el contenedor - mostrar desde el inicio
        targetScrollLeft = wordLeft - margin;
    }
    
    // Calcular scroll vertical
    let targetScrollTop = gridContainer.scrollTop;
    
    if (wordHeight + (margin * 2) <= containerHeight) {
        // La palabra cabe completa con margen - centrarla
        const wordCenter = wordTop + (wordHeight / 2);
        targetScrollTop = wordCenter - (containerHeight / 2);
    } else {
        // La palabra es más alta que el contenedor - mostrar desde el inicio
        targetScrollTop = wordTop - margin;
    }
    
    // Asegurar que el scroll esté dentro de los límites válidos
    const maxScrollLeft = Math.max(0, gridContainer.scrollWidth - containerWidth);
    const maxScrollTop = Math.max(0, gridContainer.scrollHeight - containerHeight);
    
    targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
    targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop));
    
    console.log(`Scroll objetivo: left=${targetScrollLeft} (actual=${gridContainer.scrollLeft}), top=${targetScrollTop} (actual=${gridContainer.scrollTop})`);
    console.log(`Límites máximos: maxLeft=${maxScrollLeft}, maxTop=${maxScrollTop}`);
    
    // Verificar si realmente necesitamos hacer scroll
    const scrollThreshold = 10;
    const needsHorizontalScroll = Math.abs(gridContainer.scrollLeft - targetScrollLeft) > scrollThreshold;
    const needsVerticalScroll = Math.abs(gridContainer.scrollTop - targetScrollTop) > scrollThreshold;
    
    if (needsHorizontalScroll || needsVerticalScroll) {
        gridContainer.scrollTo({
            left: targetScrollLeft,
            top: targetScrollTop,
            behavior: 'smooth'
        });
        console.log(`✅ Scroll aplicado - Nueva posición: left=${targetScrollLeft}, top=${targetScrollTop}`);
    } else {
        console.log('ℹ️ No es necesario hacer scroll, la palabra ya está bien posicionada');
    }
    
    // Verificación adicional después del scroll
    setTimeout(() => {
        const updatedFirstRect = firstCell.getBoundingClientRect();
        const updatedLastRect = lastCell.getBoundingClientRect();
        const updatedContainerRect = gridContainer.getBoundingClientRect();
        
        const isFirstVisible = updatedFirstRect.left >= updatedContainerRect.left && 
                              updatedFirstRect.right <= updatedContainerRect.right &&
                              updatedFirstRect.top >= updatedContainerRect.top && 
                              updatedFirstRect.bottom <= updatedContainerRect.bottom;
                              
        const isLastVisible = updatedLastRect.left >= updatedContainerRect.left && 
                             updatedLastRect.right <= updatedContainerRect.right &&
                             updatedLastRect.top >= updatedContainerRect.top && 
                             updatedLastRect.bottom <= updatedContainerRect.bottom;
        
        if (!isFirstVisible || !isLastVisible) {
            console.warn('⚠️ Algunas celdas aún no están completamente visibles después del scroll');
            console.log('Primera celda visible:', isFirstVisible);
            console.log('Última celda visible:', isLastVisible);
        } else {
            console.log('✅ Toda la palabra está visible correctamente');
        }
    }, 300); // Esperar a que termine la animación de scroll
}


function shouldCellHaveSeparator(row, col) {
    const pos = currentFruit.position;
    
    // Solo aplicar a la fruta actual
    if (!isCurrentFruitCell(row, col)) {
        return false;
    }
    
    // Calcular la posición relativa en el nombre de la fruta
    let relativeIndex;
    if (pos.direction === 'horizontal') {
        relativeIndex = col - pos.col;
    } else {
        relativeIndex = row - pos.row;
    }
    
    // Buscar espacios en el nombre de la fruta y verificar si esta posición corresponde a un espacio
    const fruitName = currentFruit.name;
    let letterCount = 0;
    
    for (let i = 0; i < fruitName.length; i++) {
        if (fruitName[i] === ' ') {
            // Si encontramos un espacio y coincide con la posición relativa
            if (letterCount === relativeIndex) {
                return true;
            }
        } else {
            letterCount++;
        }
    }
    
    return false;
}

 function isCurrentFruitCell(row, col) {
    const pos = currentFruit.position;
    const nameWithoutSpaces = currentFruit.name.replace(/\s/g, '');
    const nameLength = nameWithoutSpaces.length + (currentFruit.name.split(' ').length - 1); // Contar espacios como posiciones
    
    if (pos.direction === 'horizontal') {
        return row === pos.row && col >= pos.col && col < pos.col + nameLength;
    } else {
        return col === pos.col && row >= pos.row && row < pos.row + nameLength;
    }
}

        function isCompletedFruitCell(row, col) {
            return fruits.some((fruit, index) => {
                if (!completedFruits.has(index)) return false;
                
                const pos = fruit.position;
                if (pos.direction === 'horizontal') {
                    return row === pos.row && col >= pos.col && col < pos.col + fruit.name.length;
                } else {
                    return col === pos.col && row >= pos.row && row < pos.row + fruit.name.length;
                }
            });
        }

        function getLetterAt(row, col) {
            for (let i = 0; i < fruits.length; i++) {
                if (completedFruits.has(i)) {
                    const fruit = fruits[i];
                    const pos = fruit.position;
                    
                    if (pos.direction === 'horizontal') {
                        if (row === pos.row && col >= pos.col && col < pos.col + fruit.name.length) {
                            return fruit.name[col - pos.col];
                        }
                    } else {
                        if (col === pos.col && row >= pos.row && row < pos.row + fruit.name.length) {
                            return fruit.name[row - pos.row];
                        }
                    }
                }
            }
            return '';
        }

function handleInput(event) {
    // Bloquear completamente los eventos de input del teclado físico
    event.preventDefault();
    return false;
}


// ... (código existente) ...
// ... (código existente) ...
function ensureInputVisible(input) {
    const gridContainer = document.querySelector('.grid-container');
    const virtualKeyboard = document.querySelector('.virtual-keyboard');
    let keyboardHeight = 0;

    if (virtualKeyboard && getComputedStyle(virtualKeyboard).display !== 'none') {
        keyboardHeight = virtualKeyboard.offsetHeight;
    }

    const cell = input.parentElement;
    const cellRect = cell.getBoundingClientRect();
    const containerRect = gridContainer.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const effectiveViewportBottom = viewportHeight - keyboardHeight;

    let scrollAmountPage = 0;

    // Si la parte inferior de la celda está debajo del borde visible (considerando el teclado)
    if (cellRect.bottom > effectiveViewportBottom) {
        scrollAmountPage = cellRect.bottom - effectiveViewportBottom + 20; // +20px de margen
        
        if (!pageScrolledDueToKeyboard) { // Solo guardar si no hemos forzado el scroll antes
            previousScrollY = window.scrollY;
        }
        pageScrolledDueToKeyboard = true; // Marcamos que hemos forzado el scroll de página

        window.scrollBy({
            top: scrollAmountPage,
            left: 0,
            behavior: 'smooth'
        });
        console.log(`Página desplazada por teclado: ${scrollAmountPage}px`);

    } else {
        // La celda NO está oculta por el teclado.
        // Si previamente desplazamos la página POR EL TECLADO, intentamos revertir.
        if (pageScrolledDueToKeyboard && previousScrollY !== null) {
            // Comprobamos si la celda actual estaría visible si volvemos al scroll anterior
            // Esto es una heurística: si la parte superior de la celda está razonablemente visible
            const wouldBeVisibleTop = cellRect.top - (window.scrollY - previousScrollY);
            const wouldBeVisibleBottom = cellRect.bottom - (window.scrollY - previousScrollY);

            // Solo revertir si la celda seguiría estando mayormente visible y no debajo del teclado
            // y si el scroll actual es mayor que el previo (es decir, bajamos la página)
            if (window.scrollY > previousScrollY && wouldBeVisibleTop > 0 && wouldBeVisibleBottom < effectiveViewportBottom) {
                 window.scrollTo({
                    top: previousScrollY,
                    left: window.scrollX,
                    behavior: 'smooth'
                });
                console.log(`Página revertida a scroll anterior: ${previousScrollY}px`);
            }
            // Una vez que intentamos revertir (o decidimos no hacerlo), reseteamos.
            pageScrolledDueToKeyboard = false; 
            previousScrollY = null;
        } else if (pageScrolledDueToKeyboard) {
            // Si pageScrolledDueToKeyboard es true pero previousScrollY es null (no debería pasar mucho)
            // o si la condición de reversión no se cumple, simplemente reseteamos la bandera.
            pageScrolledDueToKeyboard = false;
            previousScrollY = null;
        }
    }

    // --- Lógica de scroll interno del grid-container (sin cambios) ---
    const marginBuffer = 20;
    const cellLeftInContainer = cellRect.left - containerRect.left;
    const cellRightInContainer = cellLeftInContainer + cellRect.width;
    const visibleRightInContainer = gridContainer.clientWidth;
    let needsInternalScroll = false;
    let targetScrollLeft = gridContainer.scrollLeft;

    if (cellLeftInContainer < marginBuffer) { // Ajustado para usar solo marginBuffer
        targetScrollLeft = gridContainer.scrollLeft + cellLeftInContainer - marginBuffer;
        needsInternalScroll = true;
    } else if (cellRightInContainer > visibleRightInContainer - marginBuffer) {
        targetScrollLeft = gridContainer.scrollLeft + cellRightInContainer - gridContainer.clientWidth + marginBuffer;
        needsInternalScroll = true;
    }
    
    if (needsInternalScroll) {
        const maxScrollLeft = gridContainer.scrollWidth - gridContainer.clientWidth;
        targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
        
        gridContainer.scrollTo({
            left: targetScrollLeft,
            behavior: 'smooth'
        });
        console.log(`Scroll interno del grid ajustado a: ${targetScrollLeft}px`);
    }
}


 function handleKeyDown(event) {
    // Bloquear completamente todos los eventos de teclado físico/móvil
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    
    // No procesar ninguna tecla física
    return false;
}


 function getNextInput(currentInput) {
    const cell = currentInput.parentElement;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const pos = currentFruit.position;
    
    let nextRow, nextCol;
    if (pos.direction === 'horizontal') {
        nextRow = row;
        nextCol = col + 1;
    } else {
        nextRow = row + 1;
        nextCol = col;
    }
    
    // Buscar la siguiente casilla que sea un input (no una intersección pre-llenada)
    let attempts = 0;
    while (attempts < currentFruit.name.length) {
        const nextCell = document.querySelector(`[data-row="${nextRow}"][data-col="${nextCol}"]`);
        const nextInput = nextCell ? nextCell.querySelector('input') : null;
        
        if (nextInput) {
            return nextInput;
        }
        
        // Si no hay input, continuar a la siguiente posición
        if (pos.direction === 'horizontal') {
            nextCol++;
        } else {
            nextRow++;
        }
        attempts++;
    }
    
    return null;
}

function getPreviousInput(currentInput) {
    const cell = currentInput.parentElement;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const pos = currentFruit.position;
    
    let prevRow, prevCol;
    if (pos.direction === 'horizontal') {
        prevRow = row;
        prevCol = col - 1;
    } else {
        prevRow = row - 1;
        prevCol = col;
    }
    
    // Buscar la casilla anterior que sea un input (no una intersección pre-llenada)
    let attempts = 0;
    while (attempts < currentFruit.name.length) {
        const prevCell = document.querySelector(`[data-row="${prevRow}"][data-col="${prevCol}"]`);
        const prevInput = prevCell ? prevCell.querySelector('input') : null;
        
        if (prevInput) {
            return prevInput;
        }
        
        // Si no hay input, continuar a la posición anterior
        if (pos.direction === 'horizontal') {
            prevCol--;
        } else {
            prevRow--;
        }
        attempts++;
    }
    
    return null;
}

function checkAnswerAutomatic() {
      if (window.checkingAnswer) {
        return; // Si ya está verificando, salir inmediatamente
    }
    
    const inputs = document.querySelectorAll('.green input');
    let userAnswer = '';
    let isComplete = true;
    
    // Construir la respuesta considerando inputs, intersecciones pre-llenadas y separadores
    const pos = currentFruit.position;
    const nameWithoutSpaces = currentFruit.name.replace(/\s/g, '');
    
    for (let i = 0; i < currentFruit.name.length; i++) {
        if (currentFruit.name[i] === ' ') {
            userAnswer += ' '; // Añadir espacio en la respuesta
            continue;
        }
        
        let letterFound = false;
        let currentRow, currentCol;
        
        // Calcular posición considerando espacios
        let visualIndex = i;
        if (pos.direction === 'horizontal') {
            currentRow = pos.row;
            currentCol = pos.col + visualIndex;
        } else {
            currentRow = pos.row + visualIndex;
            currentCol = pos.col;
        }
        
        // Buscar si es una intersección pre-llenada
        const intersectionCell = document.querySelector(`[data-row="${currentRow}"][data-col="${currentCol}"].filled-intersection`);
        if (intersectionCell) {
            userAnswer += intersectionCell.textContent;
            letterFound = true;
        } else {
            // Buscar si es un input
            const inputCell = document.querySelector(`[data-row="${currentRow}"][data-col="${currentCol}"] input`);
            if (inputCell && inputCell.value) {
                userAnswer += inputCell.value;
                letterFound = true;
            }
        }
        
        if (!letterFound) {
            isComplete = false;
            break;
        }
    }
    
    if (isComplete && userAnswer === currentFruit.name) {
        stopTimer();
        playSuccessSound();
        playSuccessSound(); 
        
        inputs.forEach(input => {
            input.parentElement.classList.add('correct');
        });

        const previousScore = completedFruits.size; // Guardar puntaje anterior
        completedFruits.add(currentFruitIndex);
        
        if (completedFruits.size > previousScore) { // Solo si realmente se añadió un nuevo punto
            triggerPointScoredEffects(); // ACTIVAR NUEVOS EFECTOS AQUÍ
        }
        
        updateScoreDisplay();
        incompleteFruits = incompleteFruits.filter(index => index !== currentFruitIndex);
        
        setTimeout(() => {
            playAudio(currentFruit.audio);
        }, 800);
        
        setTimeout(() => {
            nextFruit();
        }, 3000);
    }
}
function nextFruit() {
    console.log('nextFruit() llamada (palabra completada)');
    stopTimer();
    stopAllAudio();
    
    // Usar la misma lógica que para timeout
    setTimeout(() => {
        findNextAvailableFruit();
    }, 100);
}
function checkForIncompleteRounds() {
    if (incompleteFruits.length > 0) {
        currentRound++;
        
        availableFruits = shuffleArray([...incompleteFruits]);
        incompleteFruits = [];
        
        currentFruitIndex = availableFruits[0];
        currentFruit = fruits[currentFruitIndex];
        updateFruitDisplay();
        generateGrid();
        initializeVirtualKeyboard(); // AÑADIR
        startTimer();
    } else {
        showCompletionMessage();
    }
}

       function showCompletionMessage() {
            const completedCount = completedFruits.size;
            const totalFruits = fruits.length;
            
            let message = `¡Felicidades! Has completado ${completedCount} de ${totalFruits} frutas del crucigrama 🎉`;
            
            if (currentRound > 1) {
                message += `\n\nNúmero de rondas: ${currentRound}`;
            }
            
            if (completedCount === totalFruits) {
                message += '\n¡Completaste todas las frutas! 🏆';
            }
            
            alert(message);
            
            // Opcional: Reiniciar el juego
            if (confirm('¿Quieres jugar otra vez con un orden diferente?')) {
                resetGame();
            }
        }

   function resetGame() {
    stopTimer();
    completedFruits.clear();
    updateScoreDisplay();
    incompleteFruits = [];
    currentRound = 1;
    initializeRandomFruits();
    updateFruitDisplay();
    generateGrid();
    startTimer();
    initializeVirtualKeyboard(); // AÑADIR
}

let logicallyActiveInput = null;
let virtualKeyboardIsWriting = false;
let previousScrollY = null; // Para guardar la posición de scroll antes de un ajuste
let pageScrolledDueToKeyboard = false; // Bandera para indicar si ajustamos el scroll de la página

// ...
document.addEventListener('focusin', function(e) {
    if (e.target.tagName === 'INPUT' && e.target.closest('.cell.white')) {
        const inputField = e.target;
        // ... (lógica de readOnly y logicallyActiveInput) ...
        logicallyActiveInput = inputField;
        
        // Asegurar visibilidad después de que el foco se haya establecido
        // y logicallyActiveInput esté actualizado.
        // Usar un pequeño timeout para permitir que el DOM se estabilice
        // y que virtualKeyboardIsWriting se haya reseteado si es relevante.
        setTimeout(() => {
            if (logicallyActiveInput === inputField) { // Solo si el foco no cambió de nuevo rápidamente
                 ensureInputVisible(inputField);
            }
        }, 50); // 50ms puede ser un buen compromiso

        console.log('Input enfocado (focusin global):', logicallyActiveInput, 'readOnly:', inputField.readOnly);
    }
});
// ... (antes de initializeVirtualKeyboard) ...
const keyboardLayouts = {
    qwerty: [
        ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
        ['SETTINGS', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'BACKSPACE']
    ],
    azerty: [
        ['A', 'Z', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        ['Q', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M'],
        ['SETTINGS', 'W', 'X', 'C', 'V', 'B', 'N', 'BACKSPACE']
    ]
};
let currentKeyboardLayout = 'qwerty';

function loadKeyboardLayoutPreference() {
    const savedLayout = localStorage.getItem('crosswordKeyboardLayout');
    if (savedLayout && keyboardLayouts[savedLayout]) {
        currentKeyboardLayout = savedLayout;
    }
}

function saveKeyboardLayoutPreference() {
    localStorage.setItem('crosswordKeyboardLayout', currentKeyboardLayout);
}

function buildVirtualKeyboardHTML(layoutName) {
    const keyboardContainer = document.querySelector('.virtual-keyboard');
    if (!keyboardContainer) {
        console.error('Contenedor del teclado virtual no encontrado.');
        return;
    }
    keyboardContainer.innerHTML = '';

    const layout = keyboardLayouts[layoutName];
    if (!layout) {
        console.error(`Layout ${layoutName} no encontrado. Usando QWERTY por defecto.`);
        layout = keyboardLayouts.qwerty;
    }

    layout.forEach(rowKeys => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'keyboard-row';
        rowKeys.forEach(keySymbol => {
            const button = document.createElement('button');
            button.className = 'key';

            if (keySymbol === 'BACKSPACE') {
                button.innerHTML = '⌫';
                button.dataset.action = 'backspace';
                button.classList.add('special', 'backspace');
            } else if (keySymbol === 'SETTINGS') {
                button.innerHTML = '⚙️';
                button.dataset.action = 'settings';
                button.classList.add('special');
            } else {
                button.textContent = keySymbol.toLowerCase();
                button.dataset.key = keySymbol.toUpperCase();
            }
            rowDiv.appendChild(button);
        });
        keyboardContainer.appendChild(rowDiv);
    });
}
// ... (Ahora sigue tu función initializeVirtualKeyboard) ...
 
    </script>
</body>
</html>
