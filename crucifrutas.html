<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Frutas</title>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>  
  <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #6366f1, #a5b4fc);
            min-height: 100vh;
            
        }

       .header {
            background-color: #4338ca;
            color: white;
            padding: 10px 15px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
      .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

          .timer-mini {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .timer-mini.warning {
            background-color: #f59e0b;
            border-color: #f59e0b;
            animation: pulse 1s infinite;
        }

/* ESTILOS PARA EL CONTADOR DE PUNTOS FIJO */
.score-display-fixed {
    position: static; /* Cambiar de fixed a static para que esté en el header */
    background-color: rgba(255, 255, 255, 0.2); /* Mismo que timer y back */
    color: white; /* Cambiar a blanco */
    padding: 10px 12px;
    border-radius: 8px; /* Mismo que timer y back */
    font-size: 14px;
    font-weight: bold;
    display: inline-flex; /* Cambiar a inline-flex */
    align-items: center;
    gap: 6px;
    border: 1px solid rgba(255, 255, 255, 0.3); /* Mismo borde que timer y back */
    box-shadow: none; /* Quitar sombra para que sea igual */
    margin-right: 2px; /* 2px de separación con el timer */
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    transition: all 0.2s ease;
}
.score-button:hover {
    background-color: rgba(255, 255, 255, 0.25);
    border-color: rgba(255, 255, 255, 0.4);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}
        .score-icon {
            font-size: 16px;
        }
               @keyframes scorePulseAnimation {
            0% {
                transform: scale(1);
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.5); /* Sombra amarilla suave */
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 0 15px rgba(255, 255, 0, 0.8); /* Sombra amarilla más intensa */
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
            }
        }

        .score-display-fixed.animate-score {
            animation: scorePulseAnimation 0.6s ease-in-out;
        }

.timer-mini-icon {
            font-size: 12px;
        }
.crossword-container {
    background-color: #e0f2fe;
    padding: 15px;
    border-radius: 10px;
    margin: 0 auto;
    max-width: 600px; /* Reducido de 800px a 600px para ver mejor la foto */
}

.grid-container {
    overflow-x: auto;
    overflow-y: auto; /* Cambiado de hidden a auto para permitir scroll vertical */
    padding: 15px;
    margin: 2px 0;
    border-radius: 8px;
    background-color: rgba(255, 255, 255, 0.1);
    max-height: 500px; /* Añadido límite de altura para activar scroll vertical */
    border: 2px solid rgba(255, 255, 255, 0.2); /* Borde sutil */
      scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE y Edge */
}

/* Personalizar la barra de scroll horizontal */
.grid-container::-webkit-scrollbar:horizontal {
    height: 10px;
}

.grid-container::-webkit-scrollbar-track:horizontal {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:horizontal {
    background: #4338ca;
    border-radius: 5px;
}

/* Personalizar la barra de scroll vertical */
.grid-container::-webkit-scrollbar:vertical {
    width: 10px;
}

.grid-container::-webkit-scrollbar-track:vertical {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:vertical {
    background: #4338ca;
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:hover {
    background: #3730a3;
}

/* Esquina del scroll */
.grid-container::-webkit-scrollbar-corner {
    background: rgba(0, 0, 0, 0.1);
}

        .fruit-display {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #4338ca;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 2px;
            gap: 20px;
        }

       .fruit-image {
            width: 100px;
            height: 100px;
            border-radius: 10px;
            object-fit: cover;
            border: 3px solid white;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

 .fruit-image:hover {
            transform: scale(1.05);
        }

          .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }
        
         .modal-image {
            max-width: 90%;
            max-height: 90%;
            border-radius: 15px;
            border: 5px solid white;
            object-fit: contain;
            animation: zoomIn 0.3s ease;
        }

            @keyframes zoomIn {
            from {
                transform: scale(0.3);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
        }

        .close-modal:hover {
            color: #ff6b6b;
        }

        .zoom-hint {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            pointer-events: none;
        }

        .fruit-info {
            text-align: center;
        }

        .fruit-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .fruit-instruction {
            font-size: 16px;
            opacity: 0.9;
        }

.grid {
    display: grid;
    grid-template-columns: repeat(18, 45px); /* Cambiado de 40px a 45px */
    grid-template-rows: repeat(19, 45px); /* Cambiado de 40px a 45px */
    gap: 0;
    margin: 0;
    justify-content: start;
    min-width: calc(18 * 45px + 34px); /* Actualizado el cálculo */
    min-height: calc(19 * 45px + 36px); /* Actualizado el cálculo */
}

.cell {
    width: 45px; /* Cambiado de 40px a 45px */
    height: 45px; /* Cambiado de 40px a 45px */
    border: 1px solid #333;
    text-align: center;
    font-weight: 600;
    font-size: 20px; /* Aumentado de 18px a 20px */
    font-family: 'Georgia', 'Times New Roman', serif;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    letter-spacing: 0.5px;
}


       .white {
    background-color: #f8fafc;
}

        .green {
            background-color: #86efac;
            border: 1px solid #22c55e;
        }

        .blue {
            background-color: #93c5fd;
        }

        .blocked {
            background-color: #64748b;
        }

        .filled {
            background-color: #f3f4f6;
            color: #374151;
            font-weight: bold;
        }


input[type="text"] {
    width: 100%;
    height: 100%;
    border: none;
    text-align: center;
    font-weight: 600;
    font-size: 20px; /* Aumentado de 18px a 20px */
    font-family: 'Georgia', 'Times New Roman', serif;
    background: transparent;
    text-transform: uppercase;
    letter-spacing: 1px;
    caret-color: transparent;
    cursor: default;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
    inputmode: none;
}

input[type="text"]:focus {
    outline: none;
    box-shadow: 0 0 0 2px #4338ca;
}

        .green input[type="text"] {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .correct {
            background-color: #f3f70f !important;
            color: white;
        }

  @media (max-width: 1024px) {

 
    .grid-container {
        max-height: 600px; /* Reducido para tablets */
         margin: 0 auto;
        padding: 1px;
        justify-content: center;
        text-align: center;
    }
    
    .grid {
        grid-template-columns: repeat(18, 40px); /* Cambiado de 35px a 40px */
        grid-template-rows: repeat(19, 40px); /* Cambiado de 35px a 40px */
        gap: 0;
        min-width: calc(18 * 40px + 17px);
        min-height: calc(19 * 40px + 18px);
    }
    
    
      .cell {
        width: 40px; /* Cambiado de 35px a 40px */
        height: 40px; /* Cambiado de 35px a 40px */
        font-size: 19px; /* Cambiado de 17px a 19px */
        font-family: 'Georgia', 'Times New Roman', serif;
    }
    
     input[type="text"] {
        font-size: 19px; /* Cambiado de 17px a 19px */
        font-family: 'Georgia', 'Times New Roman', serif;
    }
     body {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
    }
       .header {
        width: 92%;

        max-width: 600px; /* Que coincida con el contenedor del crucigrama */
    }
    .crossword-container {
    background-color: #e0f2fe;
    padding: 15px;
    border-radius: 10px;
    margin: 0 auto; /* Esto ya está bien */
    max-width: 600px;
    width: 100%; /* Añadir para que ocupe el ancho disponible */
}
}
@media (max-width: 768px) {

    #rankingContainer {
        right: 0px !important; /* Ranking total a la derecha */
        width: 110px;
        height: 85px;
    }
    
    #rankingCurrentContainer {
        left: 0px !important; /* Ranking partida a la izquierda */
        width: 110px;
        height: 85px;
    }
    
    .ranking-container .ranking-header {
        font-size: 9px;
        padding: 2px 4px;
    }
    
    .ranking-container .ranking-item {
        padding: 2px 4px;
        font-size: 8px;
    }
    
    .ranking-container .ranking-position {
        font-size: 7px;
    }
    
    .ranking-container .ranking-user {
        font-size: 7px;
    }
    
    .ranking-container .ranking-score {
        font-size: 6px;
    }

    .total-points-button {
        padding: 10px 12px;
        font-size: 12px;
        border-radius: 6px;
        gap: 4px;
        margin-right: 2px;
    }

      .timer-button {
        padding: 10px 8px;
        font-size: 12px;
        border-radius: 6px;
        gap: 4px;
        margin-right: 3px;
    }
     .back-button {
        padding: 6px 10px;
        font-size: 18px;
        border-radius: 6px;
        margin-left: -8px; /* Reduce el espacio en móviles */
    }
    .score-display-fixed {
        padding: 10px 12px;
        font-size: 12px;
        border-radius: 6px;
        gap: 4px;
        margin-right: 2px;
    }
    
    .score-icon {
        font-size: 12px;
    }

      input[type="text"] {
        font-size: 12px;
        /* Forzar que no aparezca el teclado en móviles */
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    /* Asegurar que el teclado virtual sea más prominente en móvil */
    .virtual-keyboard {
        position: sticky;
        bottom: 0;
        z-index: 100;
        background-color: #2d3748;
        border-top: 3px solid #4338ca;
    }

    body {
        padding: 0;
    }
    
    .crossword-container {
        padding: 1px;
        max-width: 100%;
    }

    .header-right {
        gap: 5px;
    }

    .timer-mini {
        font-size: 10px;
        padding: 3px 6px;
    }

    .grid-container {
        margin: 1px 0;
        padding: 1px;
        max-height: 350px; /* Reducido para móviles */
    }

     .grid {
        grid-template-columns: repeat(18, 32px); /* Cambiado de 28px a 32px */
        grid-template-rows: repeat(19, 32px); /* Cambiado de 28px a 32px */
        gap: 0;
        min-width: calc(18 * 32px + 17px);
        min-height: calc(19 * 32px + 18px);
    }
    
     .cell {
        width: 32px; /* Cambiado de 28px a 32px */
        height: 32px; /* Cambiado de 28px a 32px */
        font-size: 18px; /* Cambiado de 16px a 18px */
        font-family: 'Georgia', 'Times New Roman', serif;
        letter-spacing: 0.3px;
    }
    
    input[type="text"] {
        font-size: 18px; /* Cambiado de 16px a 18px */
        font-family: 'Georgia', 'Times New Roman', serif;
        letter-spacing: 0.8px;
    }
    
    .fruit-display {
        flex-direction: column;
        gap: 10px;
        padding: 15px;
    }
    
    .fruit-image {
        width: 80px;
        height: 80px;
    }

    .modal-image {
        max-width: 95%;
        max-height: 95%;
    }

    .close-modal {
        top: 10px;
        right: 15px;
        font-size: 30px;
    }
    
    .fruit-name {
        font-size: 20px;
    }

    /* Barras de scroll más delgadas en móvil */
    .grid-container::-webkit-scrollbar:horizontal {
        height: 8px;
    }
    
    .grid-container::-webkit-scrollbar:vertical {
        width: 8px;
    }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .timer-icon {
            font-size: 20px;
        }



/* Teclado Virtual */
.virtual-keyboard {
    background-color: #2d3748;
    padding: 5px 0; /* Cambiado de "padding: 5px;" a "padding: 5px 0;" para quitar padding lateral */
    border-radius: 0; /* Cambiado de "border-radius: 15px;" a "border-radius: 0;" */
    margin: 0;
    max-width: 100%;
    width: 100%;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    border: none; /* Cambiado de "border: 2px solid #4a5568;" a "border: none;" */
    border-top: 2px solid #4a5568; /* Solo borde superior */
}

.keyboard-row {
    display: flex;
    justify-content: center;
    gap:2px;
    margin-bottom: 2px;
}

.keyboard-row:last-child {
    margin-bottom: 0;
}

.key {
    background: linear-gradient(145deg, #4a5568, #2d3748);
    color: white;
    border: 2px solid #4a5568;
    border-radius: 8px;
    width: 70px;
    height: 70px;
    font-size: 24px; /* Cambiado de 20px a 24px */
    font-weight: 500; /* Mantener elegante */
    font-family: 'Georgia', 'Times New Roman', serif; /* Fuente elegante */
    cursor: pointer;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    text-transform: lowercase;
    user-select: none;
    letter-spacing: 0.5px; /* Espaciado elegante */
}

.key:hover {
    background: linear-gradient(145deg, #5a6478, #3d4758);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

.key:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    background: linear-gradient(145deg, #3d4758, #2d3748);
}

.key.special {
    background: linear-gradient(145deg, #6366f1, #4338ca);
    border-color: #4338ca;
    font-size: 24px; /* Cambiado de 20px a 24px */
    font-family: 'Georgia', 'Times New Roman', serif; /* Fuente elegante */
}

.key.special:hover {
    background: linear-gradient(145deg, #7c3aed, #5b21b6);
}

.key.backspace {
    width: 60px;
}
}
/* Responsive para teclado */
@media (max-width: 768px) {
     body {
        padding: 0; /* Cambiado de "padding: 5px;" a "padding: 0;" */
        
    }
     .keyboard-selection-popup {
        width: 90% !important;
        margin: 0 auto !important;
    }
    
    .keyboard-selection-popup .swal2-title {
        font-size: 1.5rem !important;
    }
    
    .keyboard-selection-popup .swal2-content {
        font-size: 1rem !important;
    }
  .virtual-keyboard {
        max-width: 100%;
        padding: 2px;
        margin-bottom: 10px;
    }
    
    .keyboard-row {
        gap: 2px;
        margin-bottom: 2px;
    }
    
    .key {
        width: 60px;
        height: 60px;
        font-size: 20px; /* Cambiado de 18px a 20px */
        font-family: 'Georgia', 'Times New Roman', serif;
    }
    
    .key.backspace {
        width: 65px;
    }
    .cell {
        width: 28px;
        height: 28px;
        font-size: 16px; /* Cambiado de 12px a 16px */
        font-family: 'Georgia', 'Times New Roman', serif;
        letter-spacing: 0.3px;
    }
    
    input[type="text"] {
        font-size: 16px; /* Cambiado de 12px a 16px */
        font-family: 'Georgia', 'Times New Roman', serif;
        letter-spacing: 0.8px;
    } 
    
}

@media (max-width: 480px) {
    
  .key {
        width: 45px;
        height: 45px;
        font-size: 16px; /* Cambiado de 14px a 16px */
        font-family: 'Georgia', 'Times New Roman', serif;
    }
    
    .key.backspace {
        width: 55px;
    }
}

/* ...existing code... */     
        /* Añadir este estilo para la clase separator */
.separator {
    background-color: #1f2937 !important;
    color: white !important;
    border: 3px solid #374151 !important;
}
.keyboard-selection-popup {
    border-radius: 15px !important;
    font-family: Arial, sans-serif !important;
}

.keyboard-selection-popup .swal2-title {
    color: #1f2937 !important;
    font-weight: bold !important;
}

.keyboard-selection-popup .swal2-content {
    color: #4b5563 !important;
}
.cell.black {
    background-color: rgba(0, 0, 0, 0.1); /* Ligeramente transparente */
    border: 1px solid rgba(255, 255, 255, 0.1); /* Borde muy sutil */
}

.ranking-container {
    width: 140px; /* Aumentado para acomodar los puntos */
    height: 100px;
    background: linear-gradient(145deg, #ffffff, #f8fafc);
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 2px solid rgba(67, 56, 202, 0.2);
    overflow: hidden;
    font-family: 'Georgia', 'Times New Roman', serif;
}

.ranking-header {
    background: linear-gradient(145deg, #4338ca, #6366f1);
    color: white;
    padding: 4px 8px;
    text-align: center;
    font-size: 12px;
    font-weight: bold;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.ranking-list {
    max-height: 250px;
    overflow-y: auto;
    padding: 0;
    margin: 0;
}

.ranking-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 8px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    font-size: 10px;
    transition: background-color 0.2s ease;
}

.ranking-item:hover {
    background-color: rgba(67, 56, 202, 0.1);
}

.ranking-item:last-child {
    border-bottom: none;
}

.ranking-position {
    font-weight: bold;
    color: #4338ca;
    min-width: 15px;
    font-size: 9px;
}

.ranking-user {
    flex: 1;
    margin: 0 4px;
    font-weight: 500;
    color: #1f2937;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 9px;
}

.ranking-score {
    font-weight: bold;
    color: #059669;
    font-size: 8px;
    white-space: nowrap;
}

.ranking-item.current-user {
    background-color: rgba(251, 191, 36, 0.2);
    border-left: 3px solid #f59e0b;
}

.ranking-empty {
    text-align: center;
    padding: 15px 8px;
    color: #6b7280;
    font-size: 10px;
    font-style: italic;
}

.ranking-update {
    text-align: center;
    padding: 4px;
    font-size: 9px;
    color: #6b7280;
    background-color: rgba(0, 0, 0, 0.02);
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}

/* ...existing code... */

/* Estilos para el diálogo de bienvenida */
.welcome-dialog-popup {
    border-radius: 15px !important;
    font-family: Arial, sans-serif !important;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3) !important;
}

.welcome-dialog-title {
    color: #1f2937 !important;
    font-weight: bold !important;
    font-size: 1.8rem !important;
}

.welcome-dialog-content {
    color: #4b5563 !important;
    font-size: 1.1rem !important;
}

/* Responsive para el diálogo de bienvenida */
@media (max-width: 768px) {
    .welcome-dialog-popup {
        width: 90% !important;
        margin: 0 auto !important;
    }
    
    .welcome-dialog-title {
        font-size: 1.5rem !important;
    }
    
    .welcome-dialog-content {
        font-size: 1rem !important;
    }
}

.oculto-por-dialogo > *:not(.swal2-container) {
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
}

.oculto-por-dialogo {
    overflow: hidden !important;
}

.swal2-container {
    visibility: visible !important;
    opacity: 1 !important;
    pointer-events: auto !important;
    z-index: 999999 !important;
}
@media (min-width: 1025px) {
    .score-display-fixed {
        padding: 10px 15px; /* Aún más grande en PC */
        font-size: 18px;
        border-radius: 22px;
        gap: 8px;
        top: 75px;
        left: -15px;
    }
    
    .score-icon {
        font-size: 18px;
    }
}
.back-button {
    cursor: pointer;
    background-color: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 20px;
    font-weight: bold;
    color: white;
    transition: all 0.2s ease;
    display: inline-block;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    margin-left: -10px; /* NUEVO - Reduce el espacio a la izquierda */
}

.back-button:hover {
    background-color: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.back-button:active {
    transform: translateY(1px);
    background-color: rgba(255, 255, 255, 0.4);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}
.timer-button {
    cursor: default;
    background-color: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    padding: 10px 8px;
    font-size: 14px;
    font-weight: bold;
    color: white;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    margin-right: 3px;
}

.timer-button:hover {
    background-color: rgba(255, 255, 255, 0.25);
    border-color: rgba(255, 255, 255, 0.4);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.total-points-button {
    background-color: rgba(255, 215, 0, 0.2); /* Fondo dorado para diferenciarlo */
    border: 1px solid rgba(255, 215, 0, 0.4); /* Borde dorado */
}

.total-points-button:hover {
    background-color: rgba(255, 215, 0, 0.3);
    border-color: rgba(255, 215, 0, 0.6);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(255, 215, 0, 0.2);
}

.ranking-current .ranking-header {
    background: linear-gradient(145deg, #059669, #10b981);
    color: white;
}

.ranking-current .ranking-position {
    color: #059669;
}

.ranking-current .ranking-score {
    color: #dc2626; /* Rojo para diferenciarlo */
}
    </style>
</head>
<body>
     <body class="oculto-por-dialogo">
   <div class="header">
    <span id="backButton" class="back-button" onclick="handleBackButton()">←</span>
    <div class="header-right">
         <div id="scoreDisplayContainer" class="score-display-fixed"> 
            <span class="score-icon">⭐</span>
            <span id="scorePoints">0</span>
        </div>

       <div id="totalPointsContainer" class="score-display-fixed total-points-button">
            <span class="score-icon">🏆</span>
            <span id="totalPoints">0</span>
        </div> 

       <div id="timerMini" class="timer-mini timer-button">
            <span class="timer-mini-icon">⏰</span>
            <span id="timerDisplay">20</span>
        </div>
    </div>
</div>

<div class="crossword-container">
    <div class="fruit-display" id="fruitDisplay">

<span style="display: flex; justify-content: center; align-items: center; width: 100%; position: relative;">
    <!-- RANKING PARTIDO ACTUAL (izquierda de la foto) -->
    <div id="rankingCurrentContainer" class="ranking-container ranking-current"
         style="position: absolute; left: 0px; top: 50%; transform: translateY(-50%);">
      <div class="ranking-header">
        🎮 Partida
      </div>
      <div id="rankingCurrentList" class="ranking-list">
        <div class="ranking-empty">Cargando...</div>
      </div>
    </div>

    <!-- fruitImage container, will be centered by the span's flex properties -->
    <div style="position: relative;"> <!-- This div wraps the image and its zoom hint -->
        <img id="fruitImage" class="fruit-image" src="" alt="Fruta" onclick="openImageModal()">
        <div class="zoom-hint">🔍</div>
    </div>

    <!-- RANKING TOTAL (derecha de la foto - donde estaba originalmente) -->
    <div id="rankingContainer" class="ranking-container"
         style="position: absolute; right: 0px; top: 50%; transform: translateY(-50%);">
      <div class="ranking-header">
        🏆 Total
      </div>
      <div id="rankingList" class="ranking-list">
        <div class="ranking-empty">Cargando...</div>
      </div>
    </div>
</span>

    
    </div>
    
    <!-- Nuevo contenedor con scroll horizontal -->
    <div class="grid-container">
        <div class="grid" id="crossword">
            <!-- La cuadrícula se generará con JavaScript -->
        </div>
    </div>
</div>

<div class="virtual-keyboard">
    
</div>

<!-- Modal para imagen ampliada -->
<div id="imageModal" class="image-modal" onclick="closeImageModal()">
    <span class="close-modal" onclick="closeImageModal()">&times;</span>
    <img id="modalImage" class="modal-image" src="" alt="Fruta ampliada">

</div>

</div>
 <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
 <audio id="button-sound" src="https://www.myinstants.com/media/sounds/geometry-dash-click-sound.mp3"></audio>
 <audio id="winner-sound" src="https://fawzinoo.github.io/audios/winn.mp3"></audio> 
<script>

  const sound = document.getElementById('button-sound');

  document.addEventListener('click', function(e) {
    // Excluir botones del teclado de crucigrama
    if (e.target.classList.contains('teclado-crucigrama') || 
        e.target.closest('.teclado-crucigrama')) {
      return;
    }

    // Excluir tecla ESC/borrar (por contenido o clase)
    if (e.target.textContent.trim() === 'ESC' ||
        e.target.textContent.trim() === '⌫' ||
        e.target.classList.contains('tecla-borrar') ||
        e.target.classList.contains('tecla-esc')) {
      return;
    }

    // Excluir botones que contienen una sola letra (si no tienes clases específicas)
    if (e.target.tagName === 'BUTTON' && 
        e.target.textContent.length === 1 && 
        /^[A-Za-z]$/.test(e.target.textContent)) {
      return;
    }

    // Resto de botones (normales y SweetAlert2)
    if (
      e.target.tagName === 'BUTTON' ||
      e.target.classList.contains('swal2-confirm') ||
      e.target.classList.contains('swal2-cancel') ||
      e.target.classList.contains('swal2-deny')
    ) {
      sound.currentTime = 0;
      sound.play();
    }
  });


  window.onload = function() {
      history.pushState(null, '', location.href);
    };
    window.addEventListener('popstate', function() {
      window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
    });








    const scriptURL = 'https://script.google.com/macros/s/AKfycbyeoDytTQgiXAbnDJMzYVZMlx-IxpSHWidk_V5lgzbYDOszgrjKaDG9UYX9HufGJTFayA/exec';
let hasShownAutoWinner = false;
    let hasShownLoserMessage = false;
    let isAbandoning = false;

    async function getSessionNameFromServer() {
    const sessionBaseName = document.title;
    const scriptURL = 'TU_SCRIPT_URL'; // Cambia por tu URL real
    const postData = {
        action: 'getOrCreateSession',
        sessionBaseName: sessionBaseName
    };
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        const data = await response.json();
        return data.sessionName; // Ejemplo: "Frutas_1"
    } catch (e) {
        console.error('Error obteniendo nombre de sesión:', e);
        return sessionBaseName + "_1"; // fallback
    }
}

function launchConfetti() {
    if (typeof confetti === 'function') {
        confetti({
            particleCount: 180,
            spread: 100,
            origin: { y: 0.6 },
            zIndex: 9999
        });
        setTimeout(() => { // Un segundo estallido
             confetti({ particleCount: 100, spread: 120, origin: { y: 0.5 }, angle: 60, zIndex: 9999});
             confetti({ particleCount: 100, spread: 120, origin: { y: 0.5 }, angle: 120, zIndex: 9999});
        }, 250);
    } else {
        console.warn('Confetti no está definido.');
    }
}

function playWinnerSound() {
    console.log("Intentando reproducir sonido de ganador..."); // NUEVO LOG
    const winnerSound = document.getElementById('winner-sound');
    if (winnerSound) {
        console.log("Elemento de audio 'winner-sound' encontrado:", winnerSound); // NUEVO LOG
        winnerSound.currentTime = 0;
        winnerSound.play().then(() => {
            console.log("Reproducción de sonido de ganador iniciada."); // NUEVO LOG
        }).catch(error => {
            console.error("Error al reproducir sonido de ganador:", error); // ERROR LOG MEJORADO
        });
    } else {
        console.error("Elemento de audio 'winner-sound' NO encontrado."); // NUEVO LOG
    }
}

// Añadir esta función después de la función resetGame()
// ...existing code...
function showAllFruits() {
    console.log('Mostrando todas las frutas en el crucigrama...');
    
    const grid = document.getElementById('crossword');
    grid.innerHTML = '';
    
    // CORREGIR: Usar las mismas dimensiones
    const gridRows = 19;
    const gridCols = 18;
    const gridData = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
    
    // Marcar todas las posiciones de frutas
    fruits.forEach(fruit => {
        const pos = fruit.position;
        for (let i = 0; i < fruit.name.length; i++) {
            let row, col;
            if (pos.direction === 'horizontal') {
                row = pos.row;
                col = pos.col + i;
            } else {
                row = pos.row + i;
                col = pos.col;
            }
            
            // CORREGIR: Usar gridRows y gridCols
            if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                gridData[row][col] = {
                    type: 'white',
                    letter: fruit.name[i],
                    fruitName: fruit.name,
                    number: fruit.number
                };
            }
        }
    });
    
    // Crear el grid HTML - CORREGIR: Usar gridRows y gridCols
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const cell = document.createElement('div');
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (gridData[row][col] && gridData[row][col].type === 'white') {
                // Casilla blanca con letra
                 cell.className = 'cell white';
                cell.style.backgroundColor = 'transparent';
                cell.textContent = gridData[row][col].letter;
                cell.style.backgroundColor = '#c8e6c9';
                cell.style.color = '#1f2937';
                
                // Agregar números si es la primera casilla de una palabra
                fruits.forEach(fruit => {
                    if (fruit.position.row === row && fruit.position.col === col) {
                        const numberSpan = document.createElement('span');
                        numberSpan.textContent = fruit.number;
                        numberSpan.style.position = 'absolute';
                        numberSpan.style.top = '2px';
                        numberSpan.style.left = '2px';
                        numberSpan.style.fontSize = '8px';
                        numberSpan.style.fontWeight = 'bold';
                        numberSpan.style.color = '#000';
                        numberSpan.style.zIndex = '10';
                        cell.appendChild(numberSpan);
                    }
                });
} else {
    cell.className = 'cell white';
    cell.style.backgroundColor = 'transparent'; // Cambiado de '#000' a 'transparent'
}
            
            grid.appendChild(cell);
        }
    }
    
    console.log('Todas las frutas mostradas en el crucigrama');
}

// Función para volver al modo de juego normal
function returnToGame() {
    console.log('Regresando al modo de juego normal...');
    updateFruitDisplay();
    generateGrid();
    
    // Solo reiniciar timer si no hay uno activo
    if (!timer) {
        startTimer();
    }
}

// Función para mostrar estadísticas de las frutas
function showFruitsStats() {
    console.log('=== ESTADÍSTICAS DE FRUTAS ===');
    
    const horizontalFruits = fruits.filter(f => f.position.direction === 'horizontal');
    const verticalFruits = fruits.filter(f => f.position.direction === 'vertical');
    const fruitsWithSpaces = fruits.filter(f => f.name.includes(' '));
    
    console.log(`Total de frutas: ${fruits.length}`);
    console.log(`Horizontales: ${horizontalFruits.length}`);
    console.log(`Verticales: ${verticalFruits.length}`);
    console.log(`Con espacios: ${fruitsWithSpaces.length}`);
    
    console.log('\n=== FRUTAS HORIZONTALES ===');
    horizontalFruits.forEach((fruit, i) => {
        console.log(`${i+1}. ${fruit.name} - Fila ${fruit.position.row}, Col ${fruit.position.col}`);
    });
    
    console.log('\n=== FRUTAS VERTICALES ===');
    verticalFruits.forEach((fruit, i) => {
        console.log(`${i+1}. ${fruit.name} - Fila ${fruit.position.row}, Col ${fruit.position.col}`);
    });
    
    if (fruitsWithSpaces.length > 0) {
        console.log('\n=== FRUTAS CON ESPACIOS ===');
        fruitsWithSpaces.forEach(fruit => {
            console.log(`- ${fruit.name}`);
        });
    }
}

// Función para verificar intersecciones entre frutas
function checkIntersections() {
    console.log('=== VERIFICANDO INTERSECCIONES ===');
    
    const intersections = [];
    
    for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
            const fruit1 = fruits[i];
            const fruit2 = fruits[j];
            
            // Solo verificar si tienen direcciones diferentes
            if (fruit1.position.direction !== fruit2.position.direction) {
                const intersection = findIntersection(fruit1, fruit2);
                if (intersection) {
                    intersections.push({
                        fruit1: fruit1.name,
                        fruit2: fruit2.name,
                        position: intersection.position,
                        letter: intersection.letter
                    });
                }
            }
        }
    }
    
    console.log(`Total de intersecciones encontradas: ${intersections.length}`);
    intersections.forEach(int => {
        console.log(`${int.fruit1} ∩ ${int.fruit2} = "${int.letter}" en (${int.position.row}, ${int.position.col})`);
    });
    
    return intersections;
}

// Función auxiliar para encontrar intersección entre dos frutas
function findIntersection(fruit1, fruit2) {
    const pos1 = fruit1.position;
    const pos2 = fruit2.position;
    
    for (let i = 0; i < fruit1.name.length; i++) {
        for (let j = 0; j < fruit2.name.length; j++) {
            let row1, col1, row2, col2;
            
            if (pos1.direction === 'horizontal') {
                row1 = pos1.row;
                col1 = pos1.col + i;
            } else {
                row1 = pos1.row + i;
                col1 = pos1.col;
            }
            
            if (pos2.direction === 'horizontal') {
                row2 = pos2.row;
                col2 = pos2.col + j;
            } else {
                row2 = pos2.row + j;
                col2 = pos2.col;
            }
            
            // Si las posiciones coinciden y las letras son iguales
            if (row1 === row2 && col1 === col2 && fruit1.name[i] === fruit2.name[j]) {
                return {
                    position: { row: row1, col: col1 },
                    letter: fruit1.name[i]
                };
            }
        }
    }
    
    return null;
}

const fruits = [
    // Palabras Horizontales (14 palabras)
    {
        name: 'NECTARINA',
        image: 'https://fawzinoo.github.io/Fotos/nectarina.png',
        audio: 'https://fawzinoo.github.io/audios/La nectarina.mp3',
        position: { row: 0, col: 0, direction: 'horizontal' },
        number: 1
    },
    {
        name: 'LIMON',
        image: 'https://fawzinoo.github.io/Fotos/limon.png',
        audio: 'https://fawzinoo.github.io/audios/El limon.mp3',
        position: { row: 0, col: 11, direction: 'horizontal' },
        number: 4
    },
    {
        name: 'SANDIA',
        image: 'https://fawzinoo.github.io/Fotos/sandía.png',
        audio: 'https://fawzinoo.github.io/audios/La sandia.mp3',
        position: { row: 2, col: 11, direction: 'horizontal' },
        number: 6
    },
    {
        name: 'UVA',
        image: 'https://fawzinoo.github.io/Fotos/uva.png',
        audio: 'https://fawzinoo.github.io/audios/Las uvas.mp3',
        position: { row: 3, col: 2, direction: 'horizontal' },
        number: 7
    },
    {
        name: 'CHIRIMOYA',
        image: 'https://fawzinoo.github.io/Fotos/chirimoya.png',
        audio: 'https://fawzinoo.github.io/audios/La chirimoya.mp3',
        position: { row: 4, col: 5, direction: 'horizontal' },
        number: 8
    },
    {
        name: 'KIWI',
        image: 'https://fawzinoo.github.io/Fotos/kiwi.png',
        audio: 'https://fawzinoo.github.io/audios/El kiwi.mp3',
        position: { row: 6, col: 12, direction: 'horizontal' },
        number: 11
    },
    {
        name: 'PERA',
        image: 'https://fawzinoo.github.io/Fotos/pera.png',
        audio: 'https://fawzinoo.github.io/audios/La pera.mp3',
        position: { row: 7, col: 2, direction: 'horizontal' },
        number: 12
    },
    {
        name: 'AGUACATE',
        image: 'https://fawzinoo.github.io/Fotos/aguacate.png',
        audio: 'https://fawzinoo.github.io/audios/El aguacate.mp3',
        position: { row: 8, col: 10, direction: 'horizontal' },
        number: 14
    },
    {
        name: 'FRAMBUESA',
        image: 'https://fawzinoo.github.io/Fotos/frambuesa.png',
        audio: 'https://fawzinoo.github.io/audios/La frambuesa.mp3',
        position: { row: 10, col: 2, direction: 'horizontal' },
        number: 16
    },
    {
        name: 'MANZANA',
        image: 'https://fawzinoo.github.io/Fotos/manzana.png',
        audio: 'https://fawzinoo.github.io/audios/La manzana.mp3',
        position: { row: 12, col: 4, direction: 'horizontal' },
        number: 17
    },
    {
        name: 'PLATANO',
        image: 'https://fawzinoo.github.io/Fotos/platano.png',
        audio: 'https://fawzinoo.github.io/audios/El platano.mp3',
        position: { row: 14, col: 10, direction: 'horizontal' },
        number: 21
    },
    {
        name: 'CEREZA',
        image: 'https://fawzinoo.github.io/Fotos/cereza.png',
        audio: 'https://fawzinoo.github.io/audios/La cereza.mp3',
        position: { row: 15, col: 1, direction: 'horizontal' },
        number: 22
    },
    {
        name: 'PAPAYA',
        image: 'https://fawzinoo.github.io/Fotos/papaya.png',
        audio: 'https://fawzinoo.github.io/audios/La papaya.mp3',
        position: { row: 18, col: 3, direction: 'horizontal' },
        number: 24
    },
    {
        name: 'MANGO',
        image: 'https://fawzinoo.github.io/Fotos/mango.png',
        audio: 'https://fawzinoo.github.io/audios/El mango.mp3',
        position: { row: 18, col: 12, direction: 'horizontal' },
        number: 25
    },

    // Palabras Verticales (11 palabras)
    {
        name: 'NARANJA',
        image: 'https://fawzinoo.github.io/Fotos/naranja.png',
        audio: 'https://fawzinoo.github.io/audios/La naranja.mp3',
        position: { row: 12, col: 6, direction: 'vertical' },
        number: 1
    },
    {
        name: 'CAQUI',
        image: 'https://fawzinoo.github.io/Fotos/caqui.png',
        audio: 'https://fawzinoo.github.io/audios/El Caqui.mp3',
        position: { row: 0, col: 2, direction: 'vertical' },
        number: 2
    },
    {
        name: 'ALBARICOQUE',
        image: 'https://fawzinoo.github.io/Fotos/albaricoque.png',
        audio: 'https://fawzinoo.github.io/audios/El albaricoque.mp3',
        position: { row: 0, col: 8, direction: 'vertical' },
        number: 3
    },
    {
        name: 'MANDARINA',
        image: 'https://fawzinoo.github.io/Fotos/mandarina.png',
        audio: 'https://fawzinoo.github.io/audios/La mandarina.mp3',
        position: { row: 0, col: 13, direction: 'vertical' },
        number: 5
    },
    {
        name: 'FRESA',
        image: 'https://fawzinoo.github.io/Fotos/fresa.png',
        audio: 'https://fawzinoo.github.io/audios/La fresa.mp3',
        position: { row: 6, col: 4, direction: 'vertical' },
        number: 9
    },
    {
        name: 'GRANADA',
        image: 'https://fawzinoo.github.io/Fotos/granada.png',
        audio: 'https://fawzinoo.github.io/audios/La granada.mp3',
        position: { row: 6, col: 10, direction: 'vertical' },
        number: 10
    },
    {
        name: 'MELON',
        image: 'https://fawzinoo.github.io/Fotos/melon.png',
        audio: 'https://fawzinoo.github.io/audios/El melon.mp3',
        position: { row: 7, col: 17, direction: 'vertical' },
        number: 13
    },
    
    {
        name: 'CIRUELA',
        image: 'https://fawzinoo.github.io/Fotos/ciruela.png',
        audio: 'https://fawzinoo.github.io/audios/La ciruela.mp3',
        position: { row: 8, col: 14, direction: 'vertical' },
        number: 18
    },
    {
        name: 'COCO',
        image: 'https://fawzinoo.github.io/Fotos/coco.png',
        audio: 'https://fawzinoo.github.io/audios/El coco.mp3',
        position: { row: 13, col: 1, direction: 'vertical' },
        number: 19
    },
    {
        name: 'POMELO',
        image: 'https://fawzinoo.github.io/Fotos/pomelo.png',
        audio: 'https://fawzinoo.github.io/audios/El pomelo.mp3',
        position: { row: 13, col: 16, direction: 'vertical' },
        number: 20
    },
    {
        name: 'PIÑA',
        image: 'https://fawzinoo.github.io/Fotos/piña.png',
        audio: 'https://fawzinoo.github.io/audios/La pina.mp3',
        position: { row: 15, col: 8, direction: 'vertical' },
        number: 23
    }
];


        let currentFruitIndex = 0;
        let currentFruit = fruits[currentFruitIndex];
        let completedFruits = new Set();
        let availableFruits = []; 
         let incompleteFruits = [];

                // Variables del timer
        let timer = null;
        let timeLeft = 20;
        let currentRound = 1;
        let totalRounds = 0;

   function playAudio(audioUrl) {
    try {
        // Detener cualquier audio previo que pueda estar reproduciéndose
        if (window.currentAudio) {
            window.currentAudio.pause();
            window.currentAudio.currentTime = 0;
        }
        
        const audio = new Audio(audioUrl);
        window.currentAudio = audio; // Guardar referencia global
        
        audio.volume = 0.6; // Reducir volumen para evitar saturación
        audio.preload = 'auto';
        
        // Manejar errores de carga
        audio.onerror = function() {
            console.log('Error al cargar el audio:', audioUrl);
            window.currentAudio = null;
        };
        
        // Limpiar referencia cuando termine
        audio.onended = function() {
            window.currentAudio = null;
        };
        
        // Reproducir cuando esté listo
        const playPromise = audio.play();
        
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log('Audio reproducido correctamente');
            }).catch(error => {
                console.log('Error al reproducir audio:', error);
                window.currentAudio = null;
            });
        }
        
    } catch (error) {
        console.log('Error creando objeto Audio:', error);
    }
}
function stopAllAudio() {
    // Detener audio de frutas
    if (window.currentAudio) {
        try {
            window.currentAudio.pause();
            window.currentAudio.currentTime = 0;
        } catch(e) {}
        window.currentAudio = null;
    }
    
    // Detener oscilador de éxito
    if (window.currentOscillator) {
        try {
            window.currentOscillator.stop();
            window.currentOscillator.disconnect();
        } catch(e) {}
        window.currentOscillator = null;
    }
}

// Añadir función para verificar elementos DOM
function verifyDOMElements() {
    const timerMini = document.getElementById('timerMini');
    const timerDisplay = document.getElementById('timerDisplay');
    
    console.log('Verificando elementos DOM:');
    console.log('timerMini:', timerMini ? 'OK' : 'NO ENCONTRADO');
    console.log('timerDisplay:', timerDisplay ? 'OK' : 'NO ENCONTRADO');
    
    return timerMini && timerDisplay;
}

        // Función para iniciar el timer
function startTimer() {
    console.log('Iniciando timer para:', currentFruit.name);

    // Limpiar timer anterior si existe
    if (timer) {
        clearInterval(timer);
        timer = null;
    }

    timeLeft = 20;
    updateTimerDisplay();

    timer = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        console.log(`Timer: ${timeLeft} segundos restantes para ${currentFruit.name}`);

        // Cambiar color cuando quedan 10 segundos
        const timerMini = document.getElementById('timerMini');
        if (timerMini) {
            if (timeLeft <= 10) {
                timerMini.classList.add('warning');
            } else {
                timerMini.classList.remove('warning');
            }
        }

        // Tiempo agotado
        if (timeLeft <= 0) {
            console.log('¡TIEMPO AGOTADO! Ejecutando timeout...');
            clearInterval(timer);
            timer = null;

            // Ejecutar inmediatamente sin setTimeout
            handleTimeOut();
        }
    }, 1000);

    console.log('Timer iniciado correctamente');
}
        // Función para actualizar la visualización del timer
function updateTimerDisplay() {
    const timerDisplay = document.getElementById('timerDisplay');
    if (timerDisplay) {
        timerDisplay.textContent = timeLeft;
    } else {
        console.error('Elemento timerDisplay no encontrado');
    }
}

function updateScoreDisplay() {
    const scorePointsElement = document.getElementById('scorePoints');
    if (scorePointsElement) {
        scorePointsElement.textContent = completedFruits.size; // Usamos el tamaño del Set de frutas completadas
    } else {
        console.error('Elemento scorePoints no encontrado');
    }
}

        // Función para detener el timer
  function stopTimer() {
    console.log('Deteniendo timer...');
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    
    const timerMini = document.getElementById('timerMini');
    if (timerMini) {
        timerMini.classList.remove('warning');
    }
    console.log('Timer detenido');
}




function initializeVirtualKeyboard() {
    console.log('=== INICIALIZANDO TECLADO VIRTUAL ===');
    
    loadKeyboardLayoutPreference();
    buildVirtualKeyboardHTML(currentKeyboardLayout);

    const keys = document.querySelectorAll('.virtual-keyboard .key');
    console.log('Teclas encontradas:', keys.length);
    
    const LONG_PRESS_DURATION = 600;
    let pressTimer = null;
    let isLongPress = false;

    keys.forEach((keyNode, index) => {
        const key = keyNode.cloneNode(true);
        keyNode.parentNode.replaceChild(key, keyNode);

        const keyChar = key.dataset.key;
        const action = key.dataset.action;
        
        console.log(`Tecla ${index}: char="${keyChar}", action="${action}"`);

        const handleStartPress = (event) => {
            event.preventDefault();
            playKeySound(keyChar || action);
            isLongPress = false;
            key.style.transform = 'translateY(2px)';
            
            console.log(`Tecla presionada: char="${keyChar}", action="${action}"`);

            if (action === 'backspace') {
                console.log('BACKSPACE detectado');
                processVirtualBackspace();
                return;
            }


   if (action === 'settings') {
    console.log('SETTINGS detectado - Mostrando SweetAlert');
    
    Swal.fire({
        title: '⚙️ Configuración del Teclado',
        html: `
            <div style="text-align: left; margin: 10px 0;">
                <h4 style="margin: 15px 0 10px 0; color: #1f2937;">Distribución del teclado:</h4>
                <label style="display: block; margin: 8px 0; cursor: pointer;">
                    <input type="radio" name="keyboard" value="qwerty" ${currentKeyboardLayout === 'qwerty' ? 'checked' : ''} style="margin-right: 8px;">
                    <strong>QWERTY</strong>
                </label>
                <label style="display: block; margin: 8px 0; cursor: pointer;">
                    <input type="radio" name="keyboard" value="azerty" ${currentKeyboardLayout === 'azerty' ? 'checked' : ''} style="margin-right: 8px;">
                    <strong>AZERTY</strong>
                </label>
                
                <h4 style="margin: 20px 0 10px 0; color: #1f2937;">Sonido del teclado:</h4>
                <label style="display: block; margin: 8px 0; cursor: pointer;">
                    <input type="radio" name="sound" value="enabled" ${keyboardSoundEnabled ? 'checked' : ''} style="margin-right: 8px;">
                    <span>🔊 <strong>Activado</strong></span>
                </label>
                <label style="display: block; margin: 8px 0; cursor: pointer;">
                    <input type="radio" name="sound" value="disabled" ${!keyboardSoundEnabled ? 'checked' : ''} style="margin-right: 8px;">
                    <span>🔇 <strong>Silenciado</strong></span>
                </label>
            </div>
        `,
        showCancelButton: true,
        confirmButtonText: 'Aplicar',
        cancelButtonText: 'Cancelar',
        confirmButtonColor: '#4338ca',
        cancelButtonColor: '#6b7280',
        background: '#f8fafc',
        customClass: {
            popup: 'keyboard-selection-popup'
        },
        preConfirm: () => {
            const selectedKeyboard = document.querySelector('input[name="keyboard"]:checked');
            const selectedSound = document.querySelector('input[name="sound"]:checked');
            
            return {
                keyboard: selectedKeyboard ? selectedKeyboard.value : null,
                sound: selectedSound ? selectedSound.value : null
            };
        }
}).then((result) => {
        if (result.isConfirmed && result.value) {
            const { keyboard, sound } = result.value;
            let hasChanges = false;
            
            // Verificar cambios en distribución del teclado
            if (keyboard && currentKeyboardLayout !== keyboard) {
                currentKeyboardLayout = keyboard;
                hasChanges = true;
            }
            
            // Verificar cambios en sonido
            if (sound) {
                const newSoundEnabled = sound === 'enabled';
                if (keyboardSoundEnabled !== newSoundEnabled) {
                    keyboardSoundEnabled = newSoundEnabled;
                    hasChanges = true;
                }
            }
            
            if (hasChanges) {
                saveKeyboardLayoutPreference();
                
                // Reconstruir teclado si cambió la distribución
                if (keyboard && currentKeyboardLayout === keyboard) {
                    initializeVirtualKeyboard();
                }
                
                // Mostrar confirmación
                const soundStatus = keyboardSoundEnabled ? 'activado' : 'silenciado';
                Swal.fire({
                    title: '✅ ¡Configuración aplicada!',
                    text: `Teclado: ${currentKeyboardLayout.toUpperCase()}, Sonido: ${soundStatus}`,
                    icon: 'success',
                    timer: 2000,
                    showConfirmButton: false,
                    toast: true,
                    position: 'top-end',
                    background: '#10b981',
                    color: 'white'
                });
            } else {
                Swal.fire({
                    title: 'ℹ️ Sin cambios',
                    text: 'La configuración ya estaba así',
                    icon: 'info',
                    timer: 1500,
                    showConfirmButton: false,
                    toast: true,
                    position: 'top-end'
                });
            }
        }
        
        key.style.transform = '';
    });
    return;
}
            
            if (!keyChar) return;

            pressTimer = setTimeout(() => {
                isLongPress = true;
                if (keyChar === 'N') {
                    console.log('Pulsación larga en N -> Ñ');
                    processVirtualKeyPress('Ñ');
                }
            }, LONG_PRESS_DURATION);
        };

        const handleEndPress = (event) => {
            event.preventDefault();
            clearTimeout(pressTimer);
            key.style.transform = '';

            if (action === 'backspace' || action === 'settings') {
                return;
            }
            
            if (!keyChar) return;

            if (!isLongPress) {
                if (keyChar === 'N') {
                    processVirtualKeyPress('N');
                } else {
                    processVirtualKeyPress(keyChar);
                }
            }
        };

        key.addEventListener('mousedown', handleStartPress);
        key.addEventListener('mouseup', handleEndPress);
        key.addEventListener('mouseleave', () => {
            clearTimeout(pressTimer);
            key.style.transform = '';
        });

        key.addEventListener('touchstart', handleStartPress, { passive: false });
        key.addEventListener('touchend', handleEndPress);
        key.addEventListener('touchcancel', () => {
            clearTimeout(pressTimer);
            key.style.transform = '';
        });
    });
    
    console.log(`Teclado virtual (${currentKeyboardLayout.toUpperCase()}) inicializado correctamente.`);
    console.log('=== FIN INICIALIZACIÓN TECLADO ===');
}




// Agregar esta variable global cerca de las otras declaraciones de variables
let gameInitializationStopped = false;

// Modificar la función initializeGame para que sea cancelable
// Modificar la función initializeGame existente

// Modificar la función initializeGame existente para incluir polling de abandono

// Modificar la función initializeGame para asegurar que el polling inicie

async function initializeGame() {
    // Resetear la bandera al inicio
    gameInitializationStopped = false;
    
    // 🆕 REGISTRAR TIEMPO DE INICIO DEL JUEGO
    window.gameStartTime = Date.now();
    console.log('🎮 Juego iniciado en:', new Date(window.gameStartTime).toLocaleTimeString());
    
    document.body.classList.remove('oculto-por-dialogo');
    console.log('=== INICIALIZANDO JUEGO ===');
    
    // Verificar si debe detenerse antes de cada paso
    if (gameInitializationStopped) {
        console.log('❌ Inicialización del juego detenida');
        return;
    }
    
    if (!verifyDOMElements()) {
        console.error('Elementos DOM no verificados');
        return;
    }
    
    if (gameInitializationStopped) return;
    
    initializeRandomFruits();
    updateFruitDisplay();
    
    if (gameInitializationStopped) return;
  generateGrid();
  initializeVirtualKeyboard();
       // 🟢 Precargar permisos antes de permitir escribir la primera palabra
    invalidatePermissionsCache();
    await checkUserPermissionsCached();
    
    await mostrarImagenGrandeTemporal(currentFruit.image);
    
    if (gameInitializationStopped) {
        // Si se detiene después de mostrar la imagen, asegurarse de limpiar
        document.querySelectorAll('.fruit-image-overlay').forEach(el => el.remove());
        return;
    }
      
    startTimer(); 
    handleDeviceOptimizations();
    updateScoreDisplay();
    
    if (gameInitializationStopped) return;
    
    // NUEVO: Cargar puntos totales al inicializar
    await loadTotalPoints();
    
    if (gameInitializationStopped) return;
    
    // NUEVO: Iniciar actualizaciones del ranking
    startRankingUpdates();
    
    // 🆕 INICIAR LIMPIEZA PERIÓDICA
    startPeriodicCleanup();
    
    // 🆕 ASEGURAR QUE EL POLLING DE ABANDONO INICIE
    console.log('🔍 INICIANDO POLLING DE ABANDONO FORZADO...');
    startAbandonWinnerPolling();
    
    // 🆕 VERIFICAR QUE SE INICIÓ CORRECTAMENTE
    setTimeout(() => {
        if (abandonWinnerPollingInterval) {
            console.log('✅ Polling de abandono confirmado activo');
        } else {
            console.log('❌ ERROR: Polling de abandono NO está activo, reintentando...');
            setGameActive();
            startAbandonWinnerPolling();
        }
    }, 1000);
    
    console.log('🎮 Juego inicializado completamente con todas las funciones de limpieza');
}
function stopGameInitializationAndHide() {
    console.log('🛑 Deteniendo inicialización del juego y ocultando contenido...');
    
    // 🆕 MARCAR JUEGO COMO INACTIVO
    setGameInactive();
    
    // Detener la inicialización
    gameInitializationStopped = true;
    
    // 🆕 DETENER POLLING DE ABANDONO
    stopAbandonWinnerPolling();
    
    // Ocultar el contenido principal
    document.body.classList.add('oculto-por-dialogo');
    
    // Detener timer si está activo
    stopTimer();
    
    // Detener audio
    stopAllAudio();
    
    // Eliminar overlays de imagen si existen
    document.querySelectorAll('.fruit-image-overlay').forEach(el => el.remove());
    
    // Detener actualizaciones de ranking
    stopRankingUpdates();
    
    // Limpiar timeouts pendientes
    if (typeof photoTimeoutId !== 'undefined' && photoTimeoutId) {
        clearTimeout(photoTimeoutId);
        photoTimeoutId = null;
    }
    
    console.log('✅ Juego detenido, contenido ocultado y polling de abandono detenido');
}


function playKeySound(key) {
    // Si el sonido está deshabilitado, no reproducir nada
    if (!keyboardSoundEnabled) {
        return;
    }
    
    try {
        if (!window.audioContext) {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const audioContext = window.audioContext;
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filterNode = audioContext.createBiquadFilter();
        
        // Conectar en cadena: oscillator -> filter -> gain -> destination
        oscillator.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Configurar filtro para sonido más moderno
        filterNode.type = 'lowpass';
        filterNode.frequency.setValueAtTime(2000, audioContext.currentTime);
        
        // Frecuencias más suaves y agradables
        let frequency = 440;
        let volumeMultiplier = 1;
        
        if (key === 'backspace') {
            frequency = 220;
            volumeMultiplier = 1.6;
        } else if (key === 'settings') {
            frequency = 880;
        } else if (typeof key === 'string' && key.length === 1) {
            const pentatonicScale = [261.63, 293.66, 329.63, 392.00, 440.00];
            const charCode = key.charCodeAt(0);
            frequency = pentatonicScale[charCode % pentatonicScale.length];
        }
        
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = 'sine';
        
        const attackTime = 0.005;
        const decayTime = 0.02;
        const sustainLevel = 0.3;
        const releaseTime = 0.08;
        
        const baseVolume = 0.35 * volumeMultiplier;
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(baseVolume, audioContext.currentTime + attackTime);
        gainNode.gain.linearRampToValueAtTime(sustainLevel * baseVolume, audioContext.currentTime + attackTime + decayTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + attackTime + decayTime + releaseTime);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + attackTime + decayTime + releaseTime);
        
        oscillator.onended = function() {
            try {
                oscillator.disconnect();
                filterNode.disconnect();
                gainNode.disconnect();
            } catch(e) {}
        };
        
    } catch (e) {
        console.log('Error en sonido de tecla:', e);
    }
}

let photoTimeoutId = null;
        // Función cuando se agota el tiempo
function handleTimeOut() {
    console.log('=== TIMEOUT EJECUTADO ===');
    console.log(`Tiempo agotado para: ${currentFruit.name}`);
    console.log(`Fruta actual index: ${currentFruitIndex}`);
    console.log(`Completadas: ${Array.from(completedFruits)}`);
    console.log(`Disponibles: ${availableFruits}`);

    // Cancela cualquier temporizador de foto pendiente
    if (typeof photoTimeoutId !== 'undefined' && photoTimeoutId) {
        clearTimeout(photoTimeoutId);
        photoTimeoutId = null;
    }

    // Añadir a frutas incompletas si no está completada
    if (!completedFruits.has(currentFruitIndex)) {
        incompleteFruits.push(currentFruitIndex);
        console.log(`Añadida ${currentFruit.name} (${currentFruitIndex}) a incompletas`);
    }

    console.log(`Frutas incompletas total: ${incompleteFruits}`);

    // Buscar siguiente fruta inmediatamente
    console.log('Buscando siguiente fruta...');
    findNextAvailableFruit();
}


async function findNextAvailableFruit() {
    console.log('=== BUSCANDO SIGUIENTE FRUTA ===');
    
    let nextIndex = -1;
    let currentIndexInArray = availableFruits.indexOf(currentFruitIndex);
    
    // Buscar desde la siguiente posición en adelante
    for (let i = currentIndexInArray + 1; i < availableFruits.length; i++) {
        if (!completedFruits.has(availableFruits[i])) {
            nextIndex = availableFruits[i];
            break;
        }
    }
    
    // Si no encontró nada, buscar desde el principio
    if (nextIndex === -1) {
        for (let i = 0; i < currentIndexInArray; i++) {
            if (!completedFruits.has(availableFruits[i])) {
                nextIndex = availableFruits[i];
                break;
            }
        }
    }
    
    if (nextIndex !== -1) {
        currentFruitIndex = nextIndex;
        currentFruit = fruits[currentFruitIndex];

        // Invalida el caché de permisos y fuerza el fetch antes de mostrar la nueva palabra
        invalidatePermissionsCache();
        await checkUserPermissionsCached();

        // SOLO aquí, y SOLO una vez
        await mostrarImagenGrandeTemporal(currentFruit.image);

        updateFruitDisplay();
        generateGrid();
        initializeVirtualKeyboard();
        startTimer();
    } else {
        await checkForIncompleteRounds();
    }
}

        // Función para mezclar array aleatoriamente (algoritmo Fisher-Yates)
 function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

// Inicializar frutas disponibles de forma aleatoria
function initializeRandomFruits() {
    console.log('Inicializando frutas aleatorias...');
    availableFruits = shuffleArray(fruits.map((_, index) => index));
    currentFruitIndex = availableFruits[0];
    currentFruit = fruits[currentFruitIndex];
    console.log('Primera fruta:', currentFruit.name);
    console.log('Orden aleatorio:', availableFruits.map(i => fruits[i].name));
}



  function openImageModal() {
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const fruitImage = document.getElementById('fruitImage');
            
            modalImage.src = fruitImage.src;
            modal.style.display = 'flex';
            
            // Prevenir scroll del body cuando el modal está abierto
            document.body.style.overflow = 'hidden';
        }

        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            modal.style.display = 'none';
            
            // Restaurar scroll del body
            document.body.style.overflow = 'auto';
        }
         // Cerrar modal con tecla Escape
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeImageModal();
            }
        });
         // Prevenir que el clic en la imagen cierre el modal
        document.getElementById('modalImage').addEventListener('click', function(event) {
            event.stopPropagation();
        });

        function updateFruitDisplay() {
            document.getElementById('fruitImage').src = currentFruit.image;

        }
        // Generar sonido de éxito
 function playSuccessSound() {
    try {
        // Detener cualquier oscilador previo
        if (window.currentOscillator) {
            try {
                window.currentOscillator.stop();
                window.currentOscillator.disconnect();
            } catch(e) {}
            window.currentOscillator = null;
        }
        
        if (!window.audioContext) {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const audioContext = window.audioContext;
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // Crear múltiples osciladores para un acorde armonioso
        const frequencies = [523.25, 659.25, 783.99]; // Do5, Mi5, Sol5 (acorde mayor)
        const oscillators = [];
        const gainNodes = [];
        const filterNodes = [];
        
        frequencies.forEach((freq, index) => {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            // Configurar filtro para sonido más cálido
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000 - (index * 200), audioContext.currentTime);
            filter.Q.setValueAtTime(1, audioContext.currentTime);
            
            // Conectar en cadena
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            // Configurar oscilador
            osc.frequency.setValueAtTime(freq, audioContext.currentTime);
            osc.type = 'triangle'; // Sonido más suave y cálido
            
            // Volumen decreciente para cada nota (armonía)
            const baseVolume = 0.12;
            const noteVolume = baseVolume * (1 - index * 0.3);
            
            // Envolvente elegante (ADSR)
            const attackTime = 0.02;   // Ataque suave
            const decayTime = 0.1;     // Decaimiento gradual
            const sustainLevel = 0.6;  // Sostenimiento medio
            const releaseTime = 1.2;   // Liberación larga y elegante
            
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(noteVolume, audioContext.currentTime + attackTime);
            gain.gain.linearRampToValueAtTime(noteVolume * sustainLevel, audioContext.currentTime + attackTime + decayTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + attackTime + decayTime + releaseTime);
            
            // Añadir ligera modulación para más expresividad
            if (index === 0) { // Solo a la nota principal
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                osc.frequency.linearRampToValueAtTime(freq * 1.02, audioContext.currentTime + 0.3);
                osc.frequency.linearRampToValueAtTime(freq, audioContext.currentTime + 0.8);
            }
            
            const totalDuration = attackTime + decayTime + releaseTime;
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + totalDuration);
            
            oscillators.push(osc);
            gainNodes.push(gain);
            filterNodes.push(filter);
        });
        
        // Guardar referencias para limpieza
        window.currentOscillator = oscillators[0]; // Usar el primero como referencia
        
        // Limpiar cuando termine el último oscilador
        oscillators[oscillators.length - 1].onended = function() {
            try {
                oscillators.forEach(osc => osc.disconnect());
                gainNodes.forEach(gain => gain.disconnect());
                filterNodes.forEach(filter => filter.disconnect());
            } catch(e) {}
            window.currentOscillator = null;
        };
        
    } catch (e) {
        console.log('Error en sonido de éxito:', e);
    }
}

function playPointScoredSound() {
    // Función mantenida para compatibilidad pero sin sonido
    // Solo se mantiene para que triggerPointScoredEffects() pueda llamarla
    // sin generar errores, pero no produce audio
    console.log('Sonido de punto desactivado - solo efecto visual');
}


function triggerPointScoredEffects() {
    const scoreDisplayElement = document.getElementById('scoreDisplayContainer'); // El contenedor principal
    
    if (scoreDisplayElement) {
        playPointScoredSound(); // Reproducir sonido

        scoreDisplayElement.classList.add('animate-score'); // Añadir clase para animación

        // Quitar la clase después de que la animación termine para poder reutilizarla
        setTimeout(() => {
            scoreDisplayElement.classList.remove('animate-score');
        }, 600); // Duración de la animación (0.6s)
    }
}
let isCheckingPermissions = false; 

async function processVirtualKeyPress(keyValue) {
    if (isCheckingPermissions) return; // Evita múltiples comprobaciones simultáneas

    if (!window.lastKeyPermissionCheck || Date.now() - window.lastKeyPermissionCheck > 5000) {
        isCheckingPermissions = true;
        const permissions = await checkUserPermissionsCached();
        isCheckingPermissions = false;

        if (!permissions.canEdit) {
            // ...tu lógica de bloqueo...
            return;
        }
        window.lastKeyPermissionCheck = Date.now();
    }

    // Resto del código sin cambios...
    let currentTargetInput = logicallyActiveInput;

    if (!currentTargetInput || !currentTargetInput.closest('.green input')) {
        const firstGreenInput = document.querySelector('.green input');
        if (firstGreenInput) {
            firstGreenInput.focus();
            currentTargetInput = logicallyActiveInput;
        }
    }

    if (!currentTargetInput) {
        console.log('No hay input activo para el teclado virtual.');
        return;
    }

    virtualKeyboardIsWriting = true;
    currentTargetInput.readOnly = false;
    currentTargetInput.value = keyValue.toUpperCase();
    currentTargetInput.readOnly = true;
    virtualKeyboardIsWriting = false;

    const nextInput = getNextInput(currentTargetInput);
   if (nextInput) {
    setTimeout(() => {
        nextInput.focus();
        ensureInputVisible(nextInput);
    }, 0);
}
    setTimeout(checkAnswerAutomatic, 100);
}

// Aplicar el mismo cambio en processVirtualBackspace

// ...existing code...
// ...existing code...
async function processVirtualBackspace() {
    if (isCheckingPermissions) return; // Evita múltiples comprobaciones simultáneas

    if (!window.lastKeyPermissionCheck || Date.now() - window.lastKeyPermissionCheck > 5000) {
        isCheckingPermissions = true;
        const permissions = await checkUserPermissionsCached();
        isCheckingPermissions = false;

        if (!permissions.canEdit) {
            // ...tu lógica de bloqueo...
            return;
        }
        window.lastKeyPermissionCheck = Date.now();
    }

    let currentTargetInput = logicallyActiveInput;
    if (!currentTargetInput || !currentTargetInput.closest('.green input')) {
        const firstGreenInput = document.querySelector('.green input');
        if (firstGreenInput) {
            firstGreenInput.focus();
            currentTargetInput = logicallyActiveInput;
        }
    }
    if (!currentTargetInput) {
        console.log('No hay input activo para backspace.');
        return;
    }

    virtualKeyboardIsWriting = true;
    currentTargetInput.readOnly = false;

    if (currentTargetInput.value !== '') {
        // Si la celda tiene valor, bórrala pero mantén el foco
        currentTargetInput.value = '';
        // No muevas el foco
    } else {
        // Si ya está vacía, mueve el foco a la anterior (y no escribas nada)
        const prevInput = getPreviousInput(currentTargetInput);
        if (prevInput) {
            prevInput.focus();
            ensureInputVisible(prevInput);
        }
    }

    currentTargetInput.readOnly = true;
    virtualKeyboardIsWriting = false;
}
// ...existing code...


// Y en el event listener del teclado físico también aplicar el mismo cambio
document.addEventListener('keydown', async function(event) {
    if (document.body.classList.contains('swal2-shown')) return;

    if (!window.lastPhysicalKeyCheck || Date.now() - window.lastPhysicalKeyCheck > 5000) {
        const permissions = await checkUserPermissionsCached();
        
        if (!permissions.canEdit) {
            const userName = getUserName();
            if (permissions.status === "PERDEDOR" && userName && userName !== 'Invitado') {
                console.log('🔴 Teclado físico bloqueado por PERDEDOR - Limpiando celda F');
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearWinnerStatus',
                        username: userName
                    })
                });
                
                // 🆕 USAR FUNCIÓN ESPECÍFICA PARA OBTENER GANADOR
                const winnerName = await obtenerNombreGanadorEspecifico();
                console.log(`🎯 Ganador para teclado físico bloqueado: "${winnerName}"`);
                mostrarMensajeBloqueo(permissions.status, winnerName);
                event.preventDefault();
                return;
            }
            
            mostrarMensajeBloqueo(permissions.status, null);
            event.preventDefault();
            return;
        }
        
        window.lastPhysicalKeyCheck = Date.now();
    }

    // Resto del código sin cambios...
});
function generateGrid() {
    const grid = document.getElementById('crossword');
    grid.innerHTML = '';
    
    const gridRows = 19;
    const gridCols = 18;
    const gridData = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
    
    // Primero, mapear todas las letras
    fruits.forEach(fruit => {
        const pos = fruit.position;
        for (let i = 0; i < fruit.name.length; i++) {
            let row, col;
            if (pos.direction === 'horizontal') {
                row = pos.row;
                col = pos.col + i;
            } else {
                row = pos.row + i;
                col = pos.col;
            }
            
            if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                if (!gridData[row][col]) {
                    gridData[row][col] = { type: 'white', letters: [] };
                }
                gridData[row][col].letters.push({
                    letter: fruit.name[i],
                    fruitIndex: fruits.indexOf(fruit),
                    letterIndex: i
                });
            }
        }
    });
    
    // Crear set de posiciones que pertenecen a la fruta actual
    const currentFruitPositions = new Set();
    const currentPos = currentFruit.position;
    
    for (let i = 0; i < currentFruit.name.length; i++) {
        let row, col;
        if (currentPos.direction === 'horizontal') {
            row = currentPos.row;
            col = currentPos.col + i;
        } else {
            row = currentPos.row + i;
            col = currentPos.col;
        }
        if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
            currentFruitPositions.add(`${row}-${col}`);
        }
    }
    
    // Generar el grid
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const cell = document.createElement('div');
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            const positionKey = `${row}-${col}`;
            
            if (gridData[row][col] && gridData[row][col].type === 'white') {
                cell.className = 'cell white';
                
                // CORRECCIÓN: Usar el set de posiciones para determinar si pertenece a la fruta actual
                if (currentFruitPositions.has(positionKey)) {
                    cell.classList.add('green');
                    
                    // Verificar si hay letras completadas de OTRAS frutas en esta posición
                    const completedLetterFromOtherFruit = gridData[row][col].letters.find(
                        letterData => letterData.fruitIndex !== currentFruitIndex && completedFruits.has(letterData.fruitIndex)
                    );
                    
                    if (completedLetterFromOtherFruit) {
                        // Es una intersección con otra fruta completada
                        cell.textContent = completedLetterFromOtherFruit.letter;
                        cell.style.backgroundColor = '#86efac'; // Mantener color verde
                        cell.style.color = '#1f2937';
                        cell.classList.add('filled-intersection');
                    } else {
                        // Es una celda normal de la fruta actual - crear input
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.inputMode = 'none';
                        input.autocomplete = 'off';
                        input.style.caretColor = 'transparent';
                        
                        cell.appendChild(input);
                    }
                } else {
                    // No pertenece a la fruta actual
                    const completedLetter = gridData[row][col].letters.find(
                        letterData => completedFruits.has(letterData.fruitIndex)
                    );
                    
                    if (completedLetter) {
                        cell.textContent = completedLetter.letter;
                        cell.style.backgroundColor = '#fef3c7';
                        cell.style.color = '#1f2937';
                        cell.classList.add('filled');
                    }
                }
           } else {
    cell.className = 'cell black';
    cell.style.backgroundColor = 'transparent'; // Cambiado de '#000' a 'transparent'
}
            
            grid.appendChild(cell);
        }
    }
    
    setTimeout(() => {
        const firstInput = document.querySelector('.green input');
        if (firstInput) {
            firstInput.focus();
            ensureInputVisible(firstInput);
        }
        centerOnGreenWord();
    }, 100);
}

function centerOnGreenWord() {
    const gridContainer = document.querySelector('.grid-container');
    
    if (!gridContainer) {
        console.log('No hay contenedor del grid');
        return;
    }
    
    // CAMBIO: Obtener todas las celdas que DEBERÍAN ser verdes para la fruta actual
    const currentPos = currentFruit.position;
    const wordCells = [];
    
    // Calcular todas las posiciones de la palabra actual
    for (let i = 0; i < currentFruit.name.length; i++) {
        let row, col;
        if (currentPos.direction === 'horizontal') {
            row = currentPos.row;
            col = currentPos.col + i;
        } else {
            row = currentPos.row + i;
            col = currentPos.col;
        }
        
        // Buscar la celda en esa posición
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (cell) {
            wordCells.push({
                row: row,
                col: col,
                element: cell
            });
        }
    }
    
    if (wordCells.length === 0) {
        console.log('No se encontraron celdas para la palabra actual');
        return;
    }
    
    console.log(`Centrando palabra "${currentFruit.name}" con ${wordCells.length} celdas`);
    
    // Obtener la primera y última celda de la palabra
    const firstCell = wordCells[0].element;
    const lastCell = wordCells[wordCells.length - 1].element;
    
    // Calcular posiciones absolutas de la primera y última celda
    const firstCellRect = firstCell.getBoundingClientRect();
    const lastCellRect = lastCell.getBoundingClientRect();
    const containerRect = gridContainer.getBoundingClientRect();
    
    // Posiciones relativas al contenido scrolleable
    const firstCellLeft = firstCellRect.left - containerRect.left + gridContainer.scrollLeft;
    const firstCellTop = firstCellRect.top - containerRect.top + gridContainer.scrollTop;
    const lastCellRight = lastCellRect.right - containerRect.left + gridContainer.scrollLeft;
    const lastCellBottom = lastCellRect.bottom - containerRect.top + gridContainer.scrollTop;
    
    // Calcular los límites de toda la palabra
    const wordLeft = firstCellLeft;
    const wordTop = firstCellTop;
    const wordRight = lastCellRight;
    const wordBottom = lastCellBottom;
    const wordWidth = wordRight - wordLeft;
    const wordHeight = wordBottom - wordTop;
    
    // Dimensiones del contenedor visible
    const containerWidth = gridContainer.clientWidth;
    const containerHeight = gridContainer.clientHeight;
    
    // Margen para mejor centrado
    const margin = 40;
    
    // Calcular scroll horizontal
    let targetScrollLeft = gridContainer.scrollLeft;
    
    if (currentPos.direction === 'vertical') {
        // Para palabras verticales, centrar horizontalmente
        const wordCenterX = wordLeft + (wordWidth / 2);
        targetScrollLeft = wordCenterX - (containerWidth / 2);
    } else {
        // Para palabras horizontales
        if (wordWidth + (margin * 2) <= containerWidth) {
            // La palabra cabe completa con margen - centrarla
            const wordCenterX = wordLeft + (wordWidth / 2);
            targetScrollLeft = wordCenterX - (containerWidth / 2);
        } else {
            // La palabra es más ancha que el contenedor - mostrar desde el inicio
            targetScrollLeft = wordLeft - margin;
        }
    }
    
    // Calcular scroll vertical
    let targetScrollTop = gridContainer.scrollTop;
    
    if (currentPos.direction === 'horizontal') {
        // Para palabras horizontales, centrar verticalmente
        const wordCenterY = wordTop + (wordHeight / 2);
        targetScrollTop = wordCenterY - (containerHeight / 2);
    } else {
        // Para palabras verticales
        if (wordHeight + (margin * 2) <= containerHeight) {
            // La palabra cabe completa con margen - centrarla
            const wordCenterY = wordTop + (wordHeight / 2);
            targetScrollTop = wordCenterY - (containerHeight / 2);
        } else {
            // La palabra es más alta que el contenedor - mostrar desde el inicio
            targetScrollTop = wordTop - margin;
        }
    }
    
    // Asegurar que el scroll esté dentro de los límites válidos
    const maxScrollLeft = Math.max(0, gridContainer.scrollWidth - containerWidth);
    const maxScrollTop = Math.max(0, gridContainer.scrollHeight - containerHeight);
    
    targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
    targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop));
    
    console.log(`Scroll objetivo: left=${targetScrollLeft} (actual=${gridContainer.scrollLeft}), top=${targetScrollTop} (actual=${gridContainer.scrollTop})`);
    
    // Verificar si realmente necesitamos hacer scroll
    const scrollThreshold = 10;
    const needsHorizontalScroll = Math.abs(gridContainer.scrollLeft - targetScrollLeft) > scrollThreshold;
    const needsVerticalScroll = Math.abs(gridContainer.scrollTop - targetScrollTop) > scrollThreshold;
    
    if (needsHorizontalScroll || needsVerticalScroll) {
        gridContainer.scrollTo({
            left: targetScrollLeft,
            top: targetScrollTop,
            behavior: 'smooth'
        });
        console.log(`✅ Scroll aplicado - Nueva posición: left=${targetScrollLeft}, top=${targetScrollTop}`);
    } else {
        console.log('ℹ️ No es necesario hacer scroll, la palabra ya está bien posicionada');
    }
}


function shouldCellHaveSeparator(row, col) {
    const pos = currentFruit.position;
    
    // Solo aplicar a la fruta actual
    if (!isCurrentFruitCell(row, col)) {
        return false;
    }
    
    // Calcular la posición relativa en el nombre de la fruta
    let relativeIndex;
    if (pos.direction === 'horizontal') {
        relativeIndex = col - pos.col;
    } else {
        relativeIndex = row - pos.row;
    }
    
    // Buscar espacios en el nombre de la fruta y verificar si esta posición corresponde a un espacio
    const fruitName = currentFruit.name;
    let letterCount = 0;
    
    for (let i = 0; i < fruitName.length; i++) {
        if (fruitName[i] === ' ') {
            // Si encontramos un espacio y coincide con la posición relativa
            if (letterCount === relativeIndex) {
                return true;
            }
        } else {
            letterCount++;
        }
    }
    
    return false;
}

 function isCurrentFruitCell(row, col) {
    const pos = currentFruit.position;
    const nameWithoutSpaces = currentFruit.name.replace(/\s/g, '');
    const nameLength = nameWithoutSpaces.length + (currentFruit.name.split(' ').length - 1); // Contar espacios como posiciones
    
    if (pos.direction === 'horizontal') {
        return row === pos.row && col >= pos.col && col < pos.col + nameLength;
    } else {
        return col === pos.col && row >= pos.row && row < pos.row + nameLength;
    }
}

        function isCompletedFruitCell(row, col) {
            return fruits.some((fruit, index) => {
                if (!completedFruits.has(index)) return false;
                
                const pos = fruit.position;
                if (pos.direction === 'horizontal') {
                    return row === pos.row && col >= pos.col && col < pos.col + fruit.name.length;
                } else {
                    return col === pos.col && row >= pos.row && row < pos.row + fruit.name.length;
                }
            });
        }

        function getLetterAt(row, col) {
            for (let i = 0; i < fruits.length; i++) {
                if (completedFruits.has(i)) {
                    const fruit = fruits[i];
                    const pos = fruit.position;
                    
                    if (pos.direction === 'horizontal') {
                        if (row === pos.row && col >= pos.col && col < pos.col + fruit.name.length) {
                            return fruit.name[col - pos.col];
                        }
                    } else {
                        if (col === pos.col && row >= pos.row && row < pos.row + fruit.name.length) {
                            return fruit.name[row - pos.row];
                        }
                    }
                }
            }
            return '';
        }

        function isMobileOrTablet() {
    return /android|iphone|ipad|ipod|opera mini|iemobile|mobile/i.test(navigator.userAgent);
}
function handleInput(event) {
    if (isMobileOrTablet()) {
        // Bloquear completamente los eventos de input del teclado físico en móvil/tablet
        event.preventDefault();
        return false;
    }
    // En PC, permitir la escritura normal
}

// ...existing code...

// Añade esto después de definir processVirtualKeyPress y logicallyActiveInput

// ...existing code...

let nKeyDownTime = null;

document.addEventListener('keydown', async function(event) {
    if (document.body.classList.contains('swal2-shown')) return;

    if (!window.lastPhysicalKeyCheck || Date.now() - window.lastPhysicalKeyCheck > 5000) {
        const permissions = await checkUserPermissionsCached();
        
        if (!permissions.canEdit) {
            const userName = getUserName();
            if (permissions.status === "PERDEDOR" && userName && userName !== 'Invitado') {
                console.log('🔴 Teclado físico bloqueado por PERDEDOR - Limpiando celda F');
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearWinnerStatus',
                        username: userName
                    })
                });
                
                // 🆕 USAR FUNCIÓN ESPECÍFICA PARA OBTENER GANADOR
                const winnerName = await obtenerNombreGanadorEspecifico();
                console.log(`🎯 Ganador para teclado físico bloqueado: "${winnerName}"`);
                mostrarMensajeBloqueo(permissions.status, winnerName);
                event.preventDefault();
                return;
            }
            
            mostrarMensajeBloqueo(permissions.status, null);
            event.preventDefault();
            return;
        }
        
        window.lastPhysicalKeyCheck = Date.now();
    }

    // Solo letras (A-Z, Ñ)
    let key = event.key.toUpperCase();

    // Detectar pulsación larga de N para Ñ
    if (key === 'N') {
        if (!nKeyDownTime) {
            nKeyDownTime = Date.now();
        }
        event.preventDefault();
        return;
    }

    if (/^[A-ZÑ]$/.test(key)) {
        event.preventDefault();
        processVirtualKeyPress(key);
    } else if (event.key === 'Backspace') {
        event.preventDefault();
        processVirtualBackspace();
    }
});
document.addEventListener('keyup', function(event) {
    // Ignorar si hay un modal SweetAlert2 abierto
    if (document.body.classList.contains('swal2-shown')) return;

    let key = event.key.toUpperCase();

    if (key === 'N' && nKeyDownTime) {
        const duration = Date.now() - nKeyDownTime;
        nKeyDownTime = null;
        // Si la pulsación fue larga (>=600ms), poner Ñ, si no, N
        if (duration >= 600) {
            processVirtualKeyPress('Ñ');
        } else {
            processVirtualKeyPress('N');
        }
        event.preventDefault();
        return;
    }
});


function ensureInputVisible(input) {
    const gridContainer = document.querySelector('.grid-container');
    const virtualKeyboard = document.querySelector('.virtual-keyboard');
    let keyboardHeight = 0;

    if (virtualKeyboard && getComputedStyle(virtualKeyboard).display !== 'none') {
        keyboardHeight = virtualKeyboard.offsetHeight;
    }

    const cell = input.parentElement;
    const cellRect = cell.getBoundingClientRect();
    const containerRect = gridContainer.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const effectiveViewportBottom = viewportHeight - keyboardHeight;

    let scrollAmountPage = 0;

    // Si la parte inferior de la celda está debajo del borde visible (considerando el teclado)
    if (cellRect.bottom > effectiveViewportBottom) {
        scrollAmountPage = cellRect.bottom - effectiveViewportBottom + 20; // +20px de margen
        
        if (!pageScrolledDueToKeyboard) { // Solo guardar si no hemos forzado el scroll antes
            previousScrollY = window.scrollY;
        }
        pageScrolledDueToKeyboard = true; // Marcamos que hemos forzado el scroll de página

        window.scrollBy({
            top: scrollAmountPage,
            left: 0,
            behavior: 'smooth'
        });
        console.log(`Página desplazada por teclado: ${scrollAmountPage}px`);

    } else {
        // La celda NO está oculta por el teclado.
        // Si previamente desplazamos la página POR EL TECLADO, intentamos revertir.
        if (pageScrolledDueToKeyboard && previousScrollY !== null) {
            // Comprobamos si la celda actual estaría visible si volvemos al scroll anterior
            // Esto es una heurística: si la parte superior de la celda está razonablemente visible
            const wouldBeVisibleTop = cellRect.top - (window.scrollY - previousScrollY);
            const wouldBeVisibleBottom = cellRect.bottom - (window.scrollY - previousScrollY);

            // Solo revertir si la celda seguiría estando mayormente visible y no debajo del teclado
            // y si el scroll actual es mayor que el previo (es decir, bajamos la página)
            if (window.scrollY > previousScrollY && wouldBeVisibleTop > 0 && wouldBeVisibleBottom < effectiveViewportBottom) {
                 window.scrollTo({
                    top: previousScrollY,
                    left: window.scrollX,
                    behavior: 'smooth'
                });
                console.log(`Página revertida a scroll anterior: ${previousScrollY}px`);
            }
            // Una vez que intentamos revertir (o decidimos no hacerlo), reseteamos.
            pageScrolledDueToKeyboard = false; 
            previousScrollY = null;
        } else if (pageScrolledDueToKeyboard) {
            // Si pageScrolledDueToKeyboard es true pero previousScrollY es null (no debería pasar mucho)
            // o si la condición de reversión no se cumple, simplemente reseteamos la bandera.
            pageScrolledDueToKeyboard = false;
            previousScrollY = null;
        }
    }

    // --- Lógica de scroll interno del grid-container (sin cambios) ---
    const marginBuffer = 20;
    const cellLeftInContainer = cellRect.left - containerRect.left;
    const cellRightInContainer = cellLeftInContainer + cellRect.width;
    const visibleRightInContainer = gridContainer.clientWidth;
    let needsInternalScroll = false;
    let targetScrollLeft = gridContainer.scrollLeft;

    if (cellLeftInContainer < marginBuffer) { // Ajustado para usar solo marginBuffer
        targetScrollLeft = gridContainer.scrollLeft + cellLeftInContainer - marginBuffer;
        needsInternalScroll = true;
    } else if (cellRightInContainer > visibleRightInContainer - marginBuffer) {
        targetScrollLeft = gridContainer.scrollLeft + cellRightInContainer - gridContainer.clientWidth + marginBuffer;
        needsInternalScroll = true;
    }
    
    if (needsInternalScroll) {
        const maxScrollLeft = gridContainer.scrollWidth - gridContainer.clientWidth;
        targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
        
        gridContainer.scrollTo({
            left: targetScrollLeft,
            behavior: 'smooth'
        });
        console.log(`Scroll interno del grid ajustado a: ${targetScrollLeft}px`);
    }
}


 function handleKeyDown(event) {
    // Bloquear completamente todos los eventos de teclado físico/móvil
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    
    // No procesar ninguna tecla física
    return false;
}


 function getNextInput(currentInput) {
    const cell = currentInput.parentElement;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const pos = currentFruit.position;
    
    let nextRow, nextCol;
    if (pos.direction === 'horizontal') {
        nextRow = row;
        nextCol = col + 1;
    } else {
        nextRow = row + 1;
        nextCol = col;
    }
    
    // Buscar la siguiente casilla que sea un input (no una intersección pre-llenada)
    let attempts = 0;
    while (attempts < currentFruit.name.length) {
        const nextCell = document.querySelector(`[data-row="${nextRow}"][data-col="${nextCol}"]`);
        const nextInput = nextCell ? nextCell.querySelector('input') : null;
        
        if (nextInput) {
            return nextInput;
        }
        
        // Si no hay input, continuar a la siguiente posición
        if (pos.direction === 'horizontal') {
            nextCol++;
        } else {
            nextRow++;
        }
        attempts++;
    }
    
    return null;
}

function getPreviousInput(currentInput) {
    const cell = currentInput.parentElement;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const pos = currentFruit.position;
    
    let prevRow, prevCol;
    if (pos.direction === 'horizontal') {
        prevRow = row;
        prevCol = col - 1;
    } else {
        prevRow = row - 1;
        prevCol = col;
    }
    
    // Buscar la casilla anterior que sea un input (no una intersección pre-llenada)
    let attempts = 0;
    while (attempts < currentFruit.name.length) {
        const prevCell = document.querySelector(`[data-row="${prevRow}"][data-col="${prevCol}"]`);
        const prevInput = prevCell ? prevCell.querySelector('input') : null;
        
        if (prevInput) {
            return prevInput;
        }
        
        // Si no hay input, continuar a la posición anterior
        if (pos.direction === 'horizontal') {
            prevCol--;
        } else {
            prevRow--;
        }
        attempts++;
    }
    
    return null;
}
async function checkAnswerAutomatic() {
    if (window.checkingAnswer) {
        return;
    }

    // Cancela el temporizador automático de la palabra
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    // Cancela cualquier timeout de foto pendiente
    if (typeof photoTimeoutId !== 'undefined' && photoTimeoutId) {
        clearTimeout(photoTimeoutId);
        photoTimeoutId = null;
    }

    const inputs = document.querySelectorAll('.green input');
    let userAnswer = '';
    let isComplete = true;

    const pos = currentFruit.position;

    for (let i = 0; i < currentFruit.name.length; i++) {
        if (currentFruit.name[i] === ' ') {
            userAnswer += ' ';
            continue;
        }

        let letterFound = false;
        let currentRow, currentCol;

        if (pos.direction === 'horizontal') {
            currentRow = pos.row;
            currentCol = pos.col + i;
        } else {
            currentRow = pos.row + i;
            currentCol = pos.col;
        }

        // Buscar en celdas con clase .green (tanto intersecciones como inputs)
        const greenCell = document.querySelector(`[data-row="${currentRow}"][data-col="${currentCol}"].green`);
        if (greenCell) {
            // Si tiene input, usar el valor del input
            const input = greenCell.querySelector('input');
            if (input) {
                if (input.value) {
                    userAnswer += input.value;
                    letterFound = true;
                }
            } else {
                // Si no tiene input, es una intersección - usar el texto
                if (greenCell.textContent) {
                    userAnswer += greenCell.textContent;
                    letterFound = true;
                }
            }
        }

        if (!letterFound) {
            isComplete = false;
            break;
        }
    }

    if (isComplete && userAnswer === currentFruit.name) {
        playSuccessSound();

        // Marcar como correctas todas las celdas verdes (inputs e intersecciones)
        document.querySelectorAll('.green').forEach(cell => {
            cell.classList.add('correct');
        });

        const previousScore = completedFruits.size;
        completedFruits.add(currentFruitIndex);

        if (completedFruits.size > previousScore) {
            triggerPointScoredEffects();

            // NUEVO: Enviar puntos al Google Sheet
            const newPoints = 1;
            sendPointsToSheet(newPoints, 'fruta_completada').then(success => {
                if (success) {
                    console.log(`✅ Puntos registrados en Google Sheet: ${newPoints} por fruta completada`);
                    // NUEVO: Actualizar puntos totales después de enviar al sheet
                    updateTotalPointsAfterScore();
                } else {
                    console.log('⚠️ No se pudieron registrar los puntos en Google Sheet');
                }
            });
        }

        updateScoreDisplay();
        incompleteFruits = incompleteFruits.filter(index => index !== currentFruitIndex);

        setTimeout(() => {
            playAudio(currentFruit.audio);

            const audio = window.currentAudio;
            let duracion = 2000;
            if (audio && audio.duration && !isNaN(audio.duration)) {
                duracion = audio.duration * 1000;
            }

// Reemplazar la sección final de checkAnswerAutomatic

setTimeout(() => {
    if (completedFruits.size === fruits.length) {
        // 🏆 TODAS LAS FRUTAS COMPLETADAS - VICTORIA DIRECTA
        console.log('🏆 Todas las frutas completadas. VICTORIA DIRECTA.');
        
        // 🆕 MOSTRAR VICTORIA INMEDIATAMENTE sin esperar broadcast
        handleDirectWin();
        
        // También notificar al servidor y hacer broadcast para otros usuarios
        notifyGameCompleted().then(() => {
            console.log('✅ Victoria notificada al servidor');
        });
    } else {
        nextFruit(); 
    }
}, duracion);
        }, 800);
    }
}

// Reemplazar la función handleDirectWin existente

// Reemplazar la función handleDirectWin existente

// Actualizar handleDirectWin para NO limpiar sesiones (ya se limpiaron en el servidor)

function handleDirectWin() {
    console.log('🎉 Manejando VICTORIA DIRECTA (sesiones ya limpiadas en servidor)');
    
    // Marcar que ya se mostró la victoria
    window.victoryShown = true;
    
    // Detener el juego inmediatamente
    stopAbandonWinnerPolling();
    stopGameInitializationAndHide();
    ocultarMainContent();
    hideLottieAnimation();
    
    if (winnerPollingInterval) {
        clearInterval(winnerPollingInterval);
        winnerPollingInterval = null;
    }
    
    stopTimer();
    playWinnerSound();
    launchConfetti();
    
    // Mostrar mensaje de victoria
    Swal.fire({
        title: '¡Eres el GANADOR! 🎉',
        text: '¡Felicidades, has completado todas las frutas!',
        icon: 'success',
        confirmButtonText: 'Aceptar',
        allowOutsideClick: false,
        allowEscapeKey: false
    }).then(() => {
        const userName = getUserName();
        console.log('👤 Usuario ganador confirmó salir');
        
        // 🆕 SOLO LIMPIAR ESTADO TEMPORAL (F) - Las sesiones ya se limpiaron automáticamente
        if (userName && userName !== 'Invitado') {
            fetch(scriptURL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'clearWinnerStatus',
                    username: userName
                })
            });
            
            console.log('ℹ️ Solo limpiando estado temporal (sesiones ya limpiadas automáticamente)');
        }
        
        if (window.parent !== window) {
            window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
        } else {
            window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
        }
    });
}
async function nextFruit() {
    stopTimer();
    stopAllAudio();
    setTimeout(async () => {
        await findNextAvailableFruit();
    }, 100);
}

async function checkForIncompleteRounds() {
    if (incompleteFruits.length > 0) {
        currentRound++;
        availableFruits = shuffleArray([...incompleteFruits]);
        incompleteFruits = [];
        currentFruitIndex = availableFruits[0];
        currentFruit = fruits[currentFruitIndex];

        // Invalida el caché de permisos y fuerza el fetch antes de mostrar la nueva palabra
        invalidatePermissionsCache();
        await checkUserPermissionsCached();

        updateFruitDisplay();
        await mostrarImagenGrandeTemporal(currentFruit.image); // SOLO AQUÍ
        generateGrid();
        initializeVirtualKeyboard();
        startTimer();
    } else {
        // Aquí el usuario ha completado todas las palabras
        notifyGameCompleted().then(() => {
            startWinnerPolling();
        });
    }
}

   
// Agregar función de debug después de las funciones existentes

function debugAbandonPolling() {
    console.log('🧪 === DEBUG POLLING DE ABANDONO ===');
    console.log('Polling activo:', abandonWinnerPollingInterval !== null);
    console.log('ID del intervalo:', abandonWinnerPollingInterval);
    console.log('Usuario actual:', getUserName());
    console.log('Abandono detectado:', abandonoDetectado);
    console.log('Tiempo de inicio del juego:', window.gameStartTime ? new Date(window.gameStartTime).toLocaleTimeString() : 'No definido');
    console.log('🧪 === FIN DEBUG ===');
}

// Para usar en la consola: debugAbandonPolling()

function resetGame() {
    stopTimer();
    
    // 🆕 DETENER POLLING DE ABANDONO ANTES DEL RESET
    stopAbandonWinnerPolling();
    
    completedFruits.clear();
    updateScoreDisplay();
    incompleteFruits = [];
    currentRound = 1;
    
    // 🆕 RESETEAR ESTADOS
    resetGameStates();
    
    initializeRandomFruits();
    updateFruitDisplay();
    generateGrid();
    startTimer();
    initializeVirtualKeyboard();
    
    // 🆕 REINICIAR POLLING DE ABANDONO
    startAbandonWinnerPolling();
    console.log('🔄 Juego reseteado con polling de abandono reiniciado');
}

let logicallyActiveInput = null;
let virtualKeyboardIsWriting = false;
let previousScrollY = null; // Para guardar la posición de scroll antes de un ajuste
let pageScrolledDueToKeyboard = false; // Bandera para indicar si ajustamos el scroll de la página

// ...
document.addEventListener('focusin', function(e) {
    if (e.target.tagName === 'INPUT' && e.target.closest('.cell.white')) {
        const inputField = e.target;
        // ... (lógica de readOnly y logicallyActiveInput) ...
        logicallyActiveInput = inputField;
        
        // Asegurar visibilidad después de que el foco se haya establecido
        // y logicallyActiveInput esté actualizado.
        // Usar un pequeño timeout para permitir que el DOM se estabilice
        // y que virtualKeyboardIsWriting se haya reseteado si es relevante.
        setTimeout(() => {
            if (logicallyActiveInput === inputField) { // Solo si el foco no cambió de nuevo rápidamente
                 ensureInputVisible(inputField);
            }
        }, 50); // 50ms puede ser un buen compromiso

        console.log('Input enfocado (focusin global):', logicallyActiveInput, 'readOnly:', inputField.readOnly);
    }
});
// ... (antes de initializeVirtualKeyboard) ...
const keyboardLayouts = {
    qwerty: [
        ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
        ['SETTINGS', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'BACKSPACE']
    ],
    azerty: [
        ['A', 'Z', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        ['Q', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M'],
        ['SETTINGS', 'W', 'X', 'C', 'V', 'B', 'N', 'BACKSPACE']
    ]
};
let currentKeyboardLayout = 'qwerty';
let keyboardSoundEnabled = true;

function loadKeyboardLayoutPreference() {
    const savedLayout = localStorage.getItem('crosswordKeyboardLayout');
    if (savedLayout && keyboardLayouts[savedLayout]) {
        currentKeyboardLayout = savedLayout;
    }
    
    // Cargar preferencia de sonido
    const savedSoundSetting = localStorage.getItem('crosswordKeyboardSound');
    if (savedSoundSetting !== null) {
        keyboardSoundEnabled = savedSoundSetting === 'true';
    }
}

function saveKeyboardLayoutPreference() {
    localStorage.setItem('crosswordKeyboardLayout', currentKeyboardLayout);
    localStorage.setItem('crosswordKeyboardSound', keyboardSoundEnabled.toString());
}

function buildVirtualKeyboardHTML(layoutName) {
    const keyboardContainer = document.querySelector('.virtual-keyboard');
    if (!keyboardContainer) {
        console.error('Contenedor del teclado virtual no encontrado.');
        return;
    }
    keyboardContainer.innerHTML = '';

    const layout = keyboardLayouts[layoutName];
    if (!layout) {
        console.error(`Layout ${layoutName} no encontrado. Usando QWERTY por defecto.`);
        layout = keyboardLayouts.qwerty;
    }

    layout.forEach(rowKeys => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'keyboard-row';
        rowKeys.forEach(keySymbol => {
            const button = document.createElement('button');
            button.className = 'key';

            if (keySymbol === 'BACKSPACE') {
                button.innerHTML = '⌫';
                button.dataset.action = 'backspace';
                button.classList.add('special', 'backspace');
            } else if (keySymbol === 'SETTINGS') {
                button.innerHTML = '⚙️';
                button.dataset.action = 'settings';
                button.classList.add('special');
            } else {
                button.textContent = keySymbol.toLowerCase();
                button.dataset.key = keySymbol.toUpperCase();
            }
            rowDiv.appendChild(button);
        });
        keyboardContainer.appendChild(rowDiv);
    });
}
function getUserName() {
    // 1. Intenta por query string
    const params = new URLSearchParams(window.location.search);
    let user = params.get('username');
    if (user) return user;
    // 2. Intenta por localStorage (varias claves)
    user = localStorage.getItem('crosswordUsername') ||
           localStorage.getItem('userName');
    if (user) return user;
    // 3. Intenta por objeto externo
    try {
        const externalGameUser = localStorage.getItem('externalGameUser');
        if (externalGameUser) {
            const userData = JSON.parse(externalGameUser);
            if (userData.username) return userData.username;
        }
    } catch (e) {}
    return '';
}
function getUserData() {
    const urlParams = new URLSearchParams(window.location.search);
    
    let userData = {
        username: getUserName(),
        orderNumber: urlParams.get('orderNumber') || null,
        sessionId: urlParams.get('sessionId') || null,
        timestamp: Date.now()
    };
    
    // Intentar obtener datos más completos del localStorage
    try {
        const externalGameUser = localStorage.getItem('externalGameUser');
        if (externalGameUser) {
            const storedData = JSON.parse(externalGameUser);
            userData = { ...userData, ...storedData };
        }
    } catch (e) {
        console.log('Error leyendo datos completos:', e);
    }
    
    return userData;
}

function notifyGameReady() {
    // Notificar a la página padre que el juego está listo
    if (window.parent !== window) {
        window.parent.postMessage({ type: 'GAME_READY' }, '*');
    }
}

// Listener para recibir datos del iframe padre
window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'USER_DATA') {
        console.log('Datos de usuario recibidos:', event.data);
        
        // Guardar datos recibidos
        localStorage.setItem('userName', event.data.username);
        localStorage.setItem('crosswordUsername', event.data.username);
        localStorage.setItem('externalGameUser', JSON.stringify(event.data));
        
        // Actualizar interfaz si es necesario
        if (typeof updateUserInterface === 'function') {
            updateUserInterface(event.data.username);
        }
    }
});


let userDataReceived = false;

window.addEventListener('message', function(event) {
    if (
        event.data &&
        event.data.type === 'USER_DATA' &&
        !userDataReceived
    ) {
        userDataReceived = true; // Marcar como recibido
        localStorage.setItem('userName', event.data.username);
        localStorage.setItem('crosswordUsername', event.data.username);
        localStorage.setItem('externalGameUser', JSON.stringify(event.data));
        showWelcomeDialog();
    }
});

document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM cargado - obteniendo datos de usuario...');
    
    const userData = getUserData();
    console.log('Datos de usuario obtenidos:', userData);
    
    // Mostrar información de debug
    showUserDebugInfo();
    
    // Notificar que el juego está listo
    setTimeout(notifyGameReady, 1000);
    
    // Mostrar diálogo de bienvenida si no se han recibido datos de usuario
    if (!userDataReceived) {
        showWelcomeDialog();
    }
});

// Control de historial y popstate
let ignoreFirstPop = true;

window.onload = function() {
    history.pushState(null, '', location.href);
};

window.addEventListener('popstate', function() {
    if (ignoreFirstPop) {
        ignoreFirstPop = false;
        return;
    }
    cerrarIframeYSalir();
});

// ...existing code...

function cerrarIframeYSalir() {
    // NUEVO: Detener actualizaciones del ranking
    stopRankingUpdates();
    
    if (window.parent !== window) {
        window.parent.postMessage({ type: 'CLOSE_GAME_IFRAME_AND_EXIT' }, '*');
    } else {
        window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
    }
}

// También detener cuando se abandona la página
window.addEventListener('beforeunload', function () {
    stopRankingUpdates();
    // ... resto del código existente ...
});



function showWelcomeDialog() {
    const userData = getUserData();
    const userName = userData.username;

    if (!userName || userName === 'Invitado') {
        Swal.fire({
            title: '⚠️ Usuario no detectado',
            html: `
                <p>No se pudo detectar tu nombre de usuario.</p>
                <p><strong>Posibles causas:</strong></p>
                <ul style="text-align: left; margin: 10px 0;">
                    <li>No has iniciado sesión correctamente</li>
                    <li>La página se cargó directamente</li>
                    <li>Error en la comunicación entre páginas</li>
                </ul>
                <p>¿Quieres continuar como invitado?</p>
            `,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Sí, como invitado',
            cancelButtonText: 'No, salir',
            confirmButtonColor: '#f59e0b',
            cancelButtonColor: '#ef4444',
            allowOutsideClick: false,
            allowEscapeKey: false,
            customClass: {
                popup: 'welcome-dialog-popup',
                title: 'welcome-dialog-title',
                content: 'welcome-dialog-content'
            }
        }).then((result) => {
            if (result.isConfirmed) {
                 checkIfUserIsBlocked().then(isBlocked => {
            if (!isBlocked) {
                document.body.classList.remove('oculto-por-dialogo');
                initializeGame();
                startAbandonWinnerPolling();
                  }
                  });
            } else if (result.dismiss === Swal.DismissReason.cancel) {
                cerrarIframeYSalir();
            }
        });
    } else {
        Swal.fire({
            html: `
            <div style="text-align: center; margin: 15px 0;">
            <lottie-player 
            src="https://lottie.host/c5f2b76e-f9de-4a0c-843e-b146a34f12a4/nT4CPOsBRH.json"
            background="transparent"
            speed="1"
            style="width: 100px; height: 100px; margin: 0 auto 1px auto; display: block;"
            loop
            autoplay>
            </lottie-player>
            <p style="font-size: 22px; font-weight: bold; margin-bottom: 10px; color: #4338ca; letter-spacing: 1px;">
                👋 ¡Hola <span style="color: #059669;">${userName}</span>!
            </p>
     
            <div style="margin-top: 12px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                <span style="font-size: 22px; color: #059669;">🧩</span>
                <span style="color: blue; font-size: 18px; font-weight: 600; letter-spacing: 0.5px;">
                    ¿Estás listo para jugar?
                </span>
                <span style="font-size: 22px; color: #059669;">🧩</span>
            </div>
            </p>
            </div>
            `,
            showCancelButton: true,
            confirmButtonText: 'Sí, ¡jugar!',
            cancelButtonText: 'No, salir',
            confirmButtonColor: '#059669',
            cancelButtonColor: '#ef4444',
            allowOutsideClick: false,
            allowEscapeKey: false,
            customClass: {
                popup: 'welcome-dialog-popup',
                title: 'welcome-dialog-title',
                content: 'welcome-dialog-content'
            }
        }).then(async (result) => {
            if (result.isConfirmed) {
            document.body.classList.add('oculto-por-dialogo');
            Swal.fire({
                html: `
                <div id="crucigrama-preparando"></div>
                <h2 style="margin-top:20px; font-size: 1.5em;">Preparando el crucigrama...</h2>

                    <div id="progress-steps" style="font-size: 14px; color: #6b7280;">
                    <div id="step1" style="margin: 5px 0;">⏳ Registrando participación...</div>
                    <div id="step2" style="margin: 5px 0; opacity: 0.5;">⏳ Inicializando juego...</div>
                    <div id="step3" style="margin: 5px 0; opacity: 0.5;">⏳ Preparando interfaz...</div>
                    </div>
                </div>
                <style>
                    #crucigrama-preparando {
                    display: grid;
                    grid-template-rows: repeat(3, 1fr);
                    grid-template-columns: repeat(3, 1fr);
                    width: 50px;
                    height: 50px;
                    border: 2px solid #333;
                    margin: 0 auto;
                    background: #fafafa;
                    }
                    .celda-prep {
                    border: 1px solid #999;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.8em;
                    background: #fff;
                    width: 100%;
                    height: 100%;
                    transition: background 0.3s;
                    }
                    .resaltada-prep {
                    background: yellow !important;
                    }
                    .step-done {
                    color: #059669 !important;
                    opacity: 1 !important;
                    font-weight: bold;
                    }
                </style>
                `,
                showConfirmButton: false,
                allowOutsideClick: false,
                width: 300,
                didOpen: async () => {
                // Crucigrama animado usando el JSON original
                const crucigramaData = {
                    size: 3,
                    width: 50,
                    height: 50,
                    animaciones: [
                    { palabra: 'ANA', posiciones: [0, 1, 2] },
                    { palabra: 'ALA', posiciones: [0, 3, 6] },
                    { palabra: 'OLA', posiciones: [6, 7, 8] }
                    ]
                };

                const crucigrama = document.getElementById('crucigrama-preparando');
                crucigrama.style.width = crucigramaData.width + 'px';
                crucigrama.style.height = crucigramaData.height + 'px';
                let celdas = [];
                for (let i = 0; i < crucigramaData.size * crucigramaData.size; i++) {
                    const celda = document.createElement('div');
                    celda.className = 'celda-prep';
                    celda.textContent = '';
                    crucigrama.appendChild(celda);
                    celdas.push(celda);
                }
                let animIndex = 0;
                function limpiarCeldas() {
                    celdas.forEach(celda => {
                    celda.textContent = '';
                    celda.classList.remove('resaltada-prep');
                    });
                }
                function animarPalabra({palabra, posiciones}, callback) {
                    let i = 0;
                    function escribirLetra() {
                    if (i < palabra.length) {
                        celdas[posiciones[i]].textContent = palabra[i];
                        i++;
                        setTimeout(escribirLetra, 300);
                    } else {
                        posiciones.forEach(idx => celdas[idx].classList.add('resaltada-prep'));
                        setTimeout(() => {
                        posiciones.forEach(idx => celdas[idx].classList.remove('resaltada-prep'));
                        limpiarCeldas();
                        setTimeout(callback, 400);
                        }, 700);
                    }
                    }
                    escribirLetra();
                }
                function cicloAnimacion() {
                    animarPalabra(crucigramaData.animaciones[animIndex], () => {
                    animIndex = (animIndex + 1) % crucigramaData.animaciones.length;
                    cicloAnimacion();
                    });
                }
                cicloAnimacion();

                // Helper para marcar step como hecho (verde)
                function markStepDone(stepId, text) {
                    const el = document.getElementById(stepId);
                    if (el) {
                    el.textContent = text;
                    el.classList.add('step-done');
                    }
                }

                try {
                    updateProgressStep('step1', '⏳ Registrando participación...');
                    const gameStartSuccess = await registerGameStart();

                    if (gameStartSuccess) {
                    markStepDone('step1', '✅ Participación registrada');
                    updateProgressStep('step2', '⏳ Inicializando juego...');
                    const sessionName = await getSessionNameFromServer();
                    // Marcar step2 como hecho después de un pequeño delay
                    setTimeout(() => {
                        markStepDone('step2', '✅ Juego inicializado');
                        updateProgressStep('step3', '⏳ Preparando interfaz...');
                    }, 600);
                    // Marcar step3 como hecho después de otro delay
                    setTimeout(() => {
                        markStepDone('step3', '✅ Interfaz lista');
                    }, 1200);
                    await waitForRival(sessionName);
                    } else {
                    markStepDone('step1', '⚠️ Registro opcional falló');
                    Swal.close();
                    initializeGame();
                    startWinnerPolling();
                    startAbandonWinnerPolling();
                    }
                } catch (error) {
                    console.error('Error en preparación:', error);
                            Swal.update({
                                title: '⚠️ Error en preparación',
                                html: `
                                    <p>Hubo un error al preparar el juego:</p>
                                    <p style="color: #ef4444; font-size: 14px;">${error.message}</p>
                                    <p>¿Quieres continuar sin registro completo?</p>
                                `,
                                icon: 'warning',
                                showCancelButton: true,
                                confirmButtonText: 'Continuar',
                                cancelButtonText: 'Reintentar'
                            }).then((retryResult) => {
                                document.body.classList.remove('oculto-por-dialogo');
                                if (retryResult.isConfirmed) {
                                    initializeGame();
                                    startAbandonWinnerPolling();
                                } else if (retryResult.dismiss === Swal.DismissReason.cancel) {
                                    cerrarIframeYSalir();
                                }
                            });
                        }
                    }
                });
            } else if (result.dismiss === Swal.DismissReason.cancel) {
                cerrarIframeYSalir();
            }
        });
    }
}
function updateProgressStep(stepId, text) {
    const stepElement = document.getElementById(stepId);
    if (stepElement) {
        stepElement.textContent = text;
        stepElement.style.opacity = '1';
        stepElement.style.color = '#059669';
    }
}

function cerrarJuego() {
    window.history.back();
}

// Función adicional para debugging - mostrar información de usuario
function showUserDebugInfo() {
    const userData = getUserData();
    const urlParams = new URLSearchParams(window.location.search);
    
    console.log('=== DEBUG INFO USUARIO ===');
    console.log('URL params:', Object.fromEntries(urlParams));
    console.log('localStorage userName:', localStorage.getItem('userName'));
    console.log('localStorage crosswordUsername:', localStorage.getItem('crosswordUsername'));
    console.log('localStorage externalGameUser:', localStorage.getItem('externalGameUser'));
    console.log('Datos finales:', userData);
    console.log('========================');
    
    // Mostrar en pantalla para debugging fácil
    if (window.location.search.includes('debug=1')) {
        const debugDiv = document.createElement('div');
        debugDiv.style.cssText = `
            position: fixed; top: 10px; right: 10px; 
            background: rgba(0,0,0,0.8); color: white; 
            padding: 10px; border-radius: 5px; 
            font-size: 12px; z-index: 9999; max-width: 300px;
        `;
        debugDiv.innerHTML = `
            <strong>DEBUG - Datos Usuario:</strong><br>
            Usuario: ${userData.username}<br>
            Order: ${userData.orderNumber}<br>
            Session: ${userData.sessionId}<br>
            URL params: ${urlParams.get('username') ? 'Sí' : 'No'}<br>
            LocalStorage: ${localStorage.getItem('userName') ? 'Sí' : 'No'}
        `;
        document.body.appendChild(debugDiv);
        
        // Remover después de 10 segundos
        setTimeout(() => debugDiv.remove(), 10000);
    }
}

// Modificar el event listener del DOM para incluir debug
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM cargado - obteniendo datos de usuario...');
    
    const userData = getUserData();
    console.log('Datos de usuario obtenidos:', userData);
    
    // Mostrar información de debug
    showUserDebugInfo();
    
    // Notificar que el juego está listo
    setTimeout(notifyGameReady, 1000);
    

});

// ...existing code...

// Función para enviar puntos a Google Sheets
// ...existing code...

// Modificar sendPointsToSheet para limpiar celda F
// Modificar sendPointsToSheet para obtener el nombre del ganador

async function sendPointsToSheet(points, eventType = 'punto_normal') {
    const userData = getUserData();
    const userName = userData.username;
    
    if (!userName || userName === 'Invitado') {
        console.log('❌ No se pueden enviar puntos - usuario no registrado');
        return false;
    }

    const permissions = await checkUserPermissionsCached();
    
    if (!permissions.canEdit) {
        console.log(`❌ Usuario ${userName} no puede registrar puntos - Estado: ${permissions.status}`);
        
        if (permissions.status === "PERDEDOR") {
            console.log('🔴 Envío de puntos bloqueado por PERDEDOR - Limpiando celda F');
            fetch(scriptURL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'clearWinnerStatus',
                    username: userName
                })
            });
            
            // 🆕 OBTENER EL NOMBRE DEL GANADOR ESPECÍFICAMENTE
            try {
                const response = await fetch(scriptURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'getScoreStatusAndRank',
                        username: userName
                    })
                });
                const data = await response.json();
                const winnerName = data.winnerName || 'Otro jugador';
                console.log(`🎯 Ganador obtenido para puntos bloqueados: "${winnerName}"`);
                mostrarMensajeBloqueo(permissions.status, winnerName);
            } catch (error) {
                console.error('Error obteniendo ganador:', error);
                mostrarMensajeBloqueo(permissions.status, 'Otro jugador');
            }
            return false;
        }
        
        mostrarMensajeBloqueo(permissions.status, null);
        return false;
    }
    
    const postData = {
        action: 'registerPoints',
        username: userName,
        points: points,
        eventType: eventType,
        fruitName: currentFruit ? currentFruit.name : '',
        timestamp: new Date().toISOString(),
        sessionId: userData.sessionId || null,
        orderNumber: userData.orderNumber || null,
        gameMode: 'crucigrama_frutas'
    };
    
    console.log('📤 Datos a enviar (modo no-cors):', postData);
    
    try {
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify(postData)
        });
        console.log(`✅ Intento de envío de puntos (${points}, evento: ${eventType}) para ${userName} realizado.`);
        return true;
    } catch (error) {
        console.error('💥 Error de red enviando puntos:', error);
        return false;
    }
}

// EJEMPLO DE CÓMO PODRÍAS LLAMAR A handleGameWin:
// Supongamos que tienes una función que verifica si todas las palabras están correctas
function checkForAllWordsCorrect() {
    // ... tu lógica para verificar si el juego se ganó ...
    if (todasLasPalabrasSonCorrectas) {
        const puntosDeEsteJuego = calcularPuntosDelJuegoActual(); // Necesitas esta función
        handleGameWin(puntosDeEsteJuego);
    }
}

async function fetchRanking() {
 
  try {
    const response = await fetch(url);
    const data = await response.json();
    // data.ranking es un array de usuarios y puntos
    // Aquí puedes renderizar el ranking en tu HTML
    console.log(data.ranking);
  } catch (e) {
    console.error('Error obteniendo ranking:', e);
  }
}

// Función de prueba para enviar puntos manualmente
function testSendPoints() {
    console.log('🧪 Probando envío de puntos...');
    sendPointsToSheet(1, 'test_manual').then(result => {
        console.log('🧪 Resultado del test:', result);
    });
}

// Para probar, puedes ejecutar esto en la consola del navegador:
// testSendPoints();

// ...existing code...

// Modificar la función checkAnswerAutomatic para enviar puntos cuando se complete una fruta


// Función para enviar puntos finales al completar el juego
async function sendFinalScore() {
    const totalPointsInThisGame = completedFruits.size; // Puntos de este juego específico
    const totalFruitsInGame = fruits.length;
    const percentage = totalFruitsInGame > 0 ? Math.round((totalPointsInThisGame / totalFruitsInGame) * 100) : 0;
    
    // Enviar 0 puntos porque los puntos ya se sumaron por cada fruta.
    // El eventType 'juego_completado' es importante para el script si tiene lógica específica.
    // En nuestro script actual, resetCurrentGamePointsAndIncrementGames maneja el contador de juegos.
    // Esta llamada a registerPoints con 'juego_completado' podría ser redundante para el contador de juegos
    // si registerGameStart ya lo incrementó, pero no hace daño y puede ser útil para otros logs.
    const success = await sendPointsToSheet(0, 'juego_completado'); 
    
    if (success) {
        console.log(`✅ Evento 'juego_completado' enviado. Puntos de este juego: ${totalPointsInThisGame}/${totalFruitsInGame} (${percentage}%)`);
    } else {
        console.warn(`⚠️ Falló el envío del evento 'juego_completado'.`);
    }
    
    return { success, pointsThisGame: totalPointsInThisGame }; // Devolver también los puntos de este juego
}


async function registerGameStart() {
    const userData = getUserData();
    const userName = userData.username;
    const sessionName = await getSessionNameFromServer(); // <--- NUEVO

    if (!userName || userName === 'Invitado') {
        console.log('❌ No se puede registrar inicio - usuario no registrado');
        return false;
    }


    const postData = {
        action: 'registerGameStart',
        username: userName,
        gameMode: 'crucigrama_frutas',
        timestamp: new Date().toISOString(),
        sessionName: sessionName // <--- NUEVO
    };

    try {
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify(postData)
        });
        return true;
    } catch (error) {
        console.error('💥 Error de red registrando inicio de juego:', error);
        return false;
    }
}

async function checkIfAloneInSession(sessionName) {

    const postData = {
        action: 'countUsersInSession',
        sessionName: sessionName
    };
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        const data = await response.json();
        return data.count === 1;
    } catch (e) {
        return false;
    }
}

// Modificar la función waitForRival existente

async function waitForRival(sessionName) {
    let waitingAlert = null;
    let alone = await checkIfAloneInSession(sessionName);

    if (alone) {
         document.body.classList.add('oculto-por-dialogo');
        waitingAlert = Swal.fire({
            title: 'Espera a tu rival',
            text: 'Aún no hay otro jugador en tu sesión. Espera un momento...',
            icon: 'info',
            allowOutsideClick: false,
            showConfirmButton: false
        });

        // Polling cada 2 segundos
        const interval = setInterval(async () => {
            const stillAlone = await checkIfAloneInSession(sessionName);
            if (!stillAlone) {
                clearInterval(interval);
                Swal.close();
                
                // 🆕 INICIAR JUEGO CON POLLING DE ABANDONO
                initializeGame();
                // 🆕 ACTIVAR POLLING DE ABANDONO TAMBIÉN AQUÍ
                startAbandonWinnerPolling();
                console.log('🤝 Rival encontrado - Polling de abandono activado');
            }
        }, 2000);
    } else {
        Swal.close();
        initializeGame();
        startWinnerPolling();
        // 🆕 ACTIVAR POLLING DE ABANDONO TAMBIÉN AQUÍ
        startAbandonWinnerPolling();
        console.log('🤝 Unido al juego con rival - Polling de abandono activado');
    }
}









window.addEventListener('beforeunload', function () {
    const userName = getUserName();
    if (!userName) return;
    const postData = {
        action: 'clearUserSession',
        username: userName
    };
    navigator.sendBeacon(
        scriptURL,
        new Blob([JSON.stringify(postData)], { type: 'text/plain' })
    );
});





function autoCompletar24Palabras() {
    completedFruits.clear();
    // Marca las primeras 24 frutas como completadas
    for (let i = 0; i < 24; i++) {
        completedFruits.add(i);
    }
    updateScoreDisplay();
    generateGrid();
    Swal.fire({
        title: 'Test rápido',
        text: '¡24 palabras autocompletadas! Solo te falta la última para probar el flujo de ganador.',
        icon: 'info',
        timer: 2000,
        showConfirmButton: false
    });
}

// Crear el botón debajo del teclado
document.addEventListener('DOMContentLoaded', function() {
    const keyboard = document.querySelector('.virtual-keyboard');
    if (keyboard) {
        const testBtn = document.createElement('button');
        testBtn.textContent = '🧪 Autocompletar 24 palabras (TEST)';
        testBtn.style.margin = '10px auto 0 auto';
        testBtn.style.display = 'block';
        testBtn.style.background = '#059669';
        testBtn.style.color = 'white';
        testBtn.style.fontWeight = 'bold';
        testBtn.style.border = 'none';
        testBtn.style.borderRadius = '8px';
        testBtn.style.padding = '10px 18px';
        testBtn.style.fontSize = '16px';
        testBtn.style.cursor = 'pointer';
        testBtn.onclick = autoCompletar24Palabras;
        keyboard.parentNode.insertBefore(testBtn, keyboard.nextSibling);
    }
});

async function clearSessionOnServer(userName) {
    if (!userName) return;
    const postData = {
        action: 'clearUserSession',
        username: userName
    };
    try {
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify(postData)
        });
        console.log('✅ Sesión borrada en backend para', userName);
    } catch (e) {
        console.warn('No se pudo limpiar la sesión en backend:', e);
    }
    await limpiezaInmediataUsuario(username, 'clear_session_manual');
}

let winnerPollingInterval = null;


// Reemplazar la función startWinnerPolling existente

function startWinnerPolling() {
    if (winnerPollingInterval) clearInterval(winnerPollingInterval);
    winnerPollingInterval = setInterval(async () => {
        const userName = getUserName();
        if (!userName) return;
        
        const postData = {
            action: 'getScoreStatusAndRank',
            username: userName
        };
        
        try {
            const response = await fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify(postData)
            });
            const data = await response.json();
            console.log("Respuesta OFICIAL de getScoreStatusAndRank:", data);
            
            if (data && data.completed === "GANADOR") {
                clearInterval(winnerPollingInterval);
                winnerPollingInterval = null;
                
                // 🧹 LIMPIAR CELDA F INMEDIATAMENTE para GANADOR
                console.log('🎉 GANADOR OFICIAL - Limpiando celda F inmediatamente');
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearWinnerStatus',
                        username: userName
                    })
                });
                
                // Luego limpiar sesión también
                await limpiezaInmediataUsuario(userName, 'ganador_polling');
                
                invalidatePermissionsCache();
                
                stopGameInitializationAndHide();
                ocultarMainContent();
                hideLottieAnimation();
                playWinnerSound();
                
                Swal.fire({
                    title: '¡Eres el GANADOR! 🎉',
                    text: '¡Felicidades, has ganado la partida!',
                    icon: 'success',
                    confirmButtonText: 'Aceptar',
                    allowOutsideClick: false,
                    allowEscapeKey: false
                }).then(() => {
                    if (window.parent !== window) {
                        window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
                    } else {
                        window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
                    }
                });
                launchConfetti();
                
            } else if (data && data.completed === "PERDEDOR") {
                clearInterval(winnerPollingInterval);
                winnerPollingInterval = null;
                
                // 🧹 LIMPIAR CELDA F INMEDIATAMENTE para PERDEDOR
                console.log('💔 PERDEDOR OFICIAL - Limpiando celda F inmediatamente');
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearWinnerStatus',
                        username: userName
                    })
                }).then(() => {
                    console.log(`✅ Celda F limpiada para ${userName} tras polling PERDEDOR`);
                }).catch(error => {
                    console.error('❌ Error limpiando celda F en polling:', error);
                });
                
                invalidatePermissionsCache();
                
                stopGameInitializationAndHide();
                ocultarMainContent();
                hideLottieAnimation();

                if (typeof photoTimeoutId !== 'undefined' && photoTimeoutId) {
                    clearTimeout(photoTimeoutId);
                    photoTimeoutId = null;
                }
                
                // 🆕 PASAR DIRECTAMENTE EL NOMBRE DEL GANADOR A mostrarMensajeBloqueo
                const winnerName = data.winnerName || 'Otro jugador';
                console.log(`🔴 Perdedor detectado en polling - Ganador: "${winnerName}"`);
                
                // USAR LA FUNCIÓN mostrarMensajeBloqueo CON EL NOMBRE DEL GANADOR
                mostrarMensajeBloqueo("PERDEDOR", winnerName);
            }
        } catch (e) {
            console.error('Error al obtener estado de ganador:', e);
        }
    }, 5000);
}


// Reemplazar la función notifyGameCompleted existente

// Reemplazar la función notifyGameCompleted existente

async function notifyGameCompleted() {
    const userName = getUserName();
    if (!userName || userName === 'Invitado') {
        console.log('❌ No se puede notificar completado - usuario no registrado');
        return;
    }
    
    console.log('🏆 JUEGO COMPLETADO - Marcando como GANADOR y limpiando sesiones');
    
    try {
        // 1. Marcar este usuario como GANADOR (esto automáticamente limpia sesiones)
        const postData = {
            action: 'setCompleted',
            username: userName,
            completed: 'GANADOR'
        };
        
        const response1 = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        
        console.log('📤 Respuesta setCompleted:', response1.status);
        
        // 2. Asegurar limpieza de perdedores y sesiones (doble verificación)
        setTimeout(async () => {
            console.log('🔴 Verificando limpieza de perdedores y sesiones...');
            try {
                const response2 = await fetch(scriptURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'markLosersInSession',
                        winnerUsername: userName
                    })
                });
                
                const data = await response2.json();
                console.log('🔴 Resultado markLosersInSession:', data);
                
                if (data.success) {
                    console.log(`✅ Perdedores marcados: ${data.losersMarked}`);
                    console.log(`🧹 Sesiones limpiadas: ${data.sessionsCleared}`);
                }
                
            } catch (error) {
                console.error('❌ Error en verificación:', error);
            }
        }, 500); // 500ms de delay
        
        // 3. Hacer broadcast inmediatamente
        console.log(`📢 Broadcasting ganador "${userName}" a localStorage`);
        broadcastWinnerToAllUsers(userName);
        
    } catch (error) {
        console.error('❌ Error marcando usuario como ganador:', error);
    }
}


async function debugLosersMarking() {
    console.log('🧪 === DEBUG MARCADO DE PERDEDORES ===');
    
    const userName = getUserName();
    console.log('Usuario actual:', userName);
    
    try {
        // Probar marcar perdedores en la sesión del usuario actual
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'markLosersInSession',
                winnerUsername: userName
            })
        });
        
        const data = await response.json();
        console.log('Resultado markLosersInSession:', data);
        
        if (data.success) {
            console.log(`✅ Perdedores marcados: ${data.losersMarked}`);
            console.log(`📍 Sesión del ganador: ${data.winnerSession}`);
        } else {
            console.log(`❌ Error: ${data.error}`);
        }
        
    } catch (error) {
        console.error('Error en debug:', error);
    }
    
    console.log('🧪 === FIN DEBUG ===');
}

// Para usar en la consola: debugLosersMarking()
// Verificar que esta función esté correcta

function broadcastWinnerToAllUsers(winnerName) {
    console.log(`📢 === BROADCASTING GANADOR ===`);
    console.log(`Nombre del ganador a broadcast: "${winnerName}"`);
    
    // Verificar que el nombre del ganador sea válido
    if (!winnerName || winnerName === 'Invitado' || winnerName.trim() === '') {
        console.error('❌ Nombre de ganador no válido para broadcast:', winnerName);
        return;
    }
    
    // Crear evento de almacenamiento que será detectado por todas las pestañas/ventanas
    const winnerData = {
        type: 'WINNER_DETECTED',
        winner: winnerName,
        timestamp: Date.now(),
        gameMode: 'crucigrama_frutas',
        source: 'direct_completion'
    };
    
    console.log(`📤 Datos a guardar en localStorage:`, winnerData);
    
    // Guardar en localStorage (esto activará el evento 'storage' en otras pestañas)
    try {
        localStorage.setItem('crucigrama_winner_broadcast', JSON.stringify(winnerData));
        console.log(`✅ Datos del ganador guardados correctamente en localStorage`);
        
        // Verificar que se guardó correctamente
        const verificacion = localStorage.getItem('crucigrama_winner_broadcast');
        if (verificacion) {
            const dataVerificada = JSON.parse(verificacion);
            console.log(`✅ Verificación localStorage - Ganador: "${dataVerificada.winner}"`);
        } else {
            console.error('❌ Error: No se pudo verificar el localStorage');
        }
        
    } catch (error) {
        console.error('❌ Error guardando en localStorage:', error);
    }
    
    console.log(`📢 === FIN BROADCASTING ===`);
}

// Reemplazar el event listener existente para storage

// 🆕 LISTENER MEJORADO PARA DETECTAR GANADOR DESDE LOCALSTORAGE
window.addEventListener('storage', function(event) {
    console.log('🔔 Evento storage detectado:', {
        key: event.key,
        newValue: event.newValue,
        oldValue: event.oldValue
    });
    
    // Solo procesar eventos de ganador
    if (event.key === 'crucigrama_winner_broadcast' && event.newValue) {
        try {
            const winnerData = JSON.parse(event.newValue);
            console.log('📢 Datos del ganador parseados:', winnerData);
            
            if (winnerData.type === 'WINNER_DETECTED' && winnerData.winner) {
                console.log(`🎯 Procesando ganador: "${winnerData.winner}"`);
                
                // Verificar si ya hay un SweetAlert abierto
                if (document.body.classList.contains('swal2-shown')) {
                    console.log('⚠️ SweetAlert ya abierto, ignorando evento storage');
                    return;
                }
                
                // Pequeño delay para evitar conflictos con múltiples eventos
                setTimeout(() => {
                    handleWinnerFromBroadcast(winnerData);
                }, 100);
            } else {
                console.log('⚠️ Datos de ganador incompletos:', winnerData);
            }
        } catch (error) {
            console.error('❌ Error procesando ganador desde localStorage:', error);
        }
    }
});

// Función de debug para probar localStorage

function debugLocalStorageBroadcast() {
    console.log('🧪 === DEBUG LOCALSTORAGE BROADCAST ===');
    
    // Verificar contenido actual
    const current = localStorage.getItem('crucigrama_winner_broadcast');
    console.log('Contenido actual:', current);
    
    if (current) {
        try {
            const data = JSON.parse(current);
            console.log('Datos parseados:', data);
        } catch (e) {
            console.error('Error parseando:', e);
        }
    }
    
    // Probar broadcast manual
    const testUser = getUserName() || 'TestUser';
    console.log(`Probando broadcast con usuario: "${testUser}"`);
    
    broadcastWinnerToAllUsers(testUser);
    
    console.log('🧪 === FIN DEBUG ===');
}


// Reemplazar handleWinnerFromBroadcast con más debug

// Reemplazar handleWinnerFromBroadcast con más debug

function handleWinnerFromBroadcast(winnerData) {
    const currentUser = getUserName();
    const winner = winnerData.winner;
    
    console.log(`🎯 === PROCESANDO GANADOR DESDE BROADCAST ===`);
    console.log(`Ganador: "${winner}"`);
    console.log(`Usuario actual: "${currentUser}"`);
    console.log(`Timestamp: ${winnerData.timestamp}`);
    console.log(`Fuente: ${winnerData.source || 'no especificada'}`);
    
    // SI YA SE MOSTRÓ VICTORIA DIRECTA, IGNORAR BROADCAST
    if (window.victoryShown) {
        console.log('⚠️ Victoria ya mostrada directamente, ignorando broadcast');
        return;
    }
    
    // Verificar si el evento es reciente (últimos 30 segundos)
    if (Date.now() - winnerData.timestamp > 30000) {
        console.log('⚠️ Evento de ganador muy antiguo, ignorando');
        return;
    }
    
    // Verificar si ya hay un SweetAlert abierto
    if (document.body.classList.contains('swal2-shown')) {
        console.log('⚠️ Ya hay un SweetAlert abierto, ignorando broadcast');
        return;
    }
    
    // Verificar si ya se procesó este evento
    if (window.lastProcessedWinner === winner && window.lastProcessedTimestamp === winnerData.timestamp) {
        console.log('⚠️ Evento ya procesado anteriormente, ignorando');
        return;
    }
    
    // Marcar evento como procesado
    window.lastProcessedWinner = winner;
    window.lastProcessedTimestamp = winnerData.timestamp;
    
    if (winner === currentUser) {
        // Este usuario es el ganador DESDE BROADCAST (no directo)
        console.log('🏆 SOY EL GANADOR desde broadcast - Mostrando interfaz de victoria');
        handleLocalWinner();
    } else {
        // 💔 OTRO USUARIO GANÓ
        console.log(`💔 OTRO USUARIO GANÓ: "${winner}" - Mostrando interfaz de perdedor`);
        handleLocalLoser(winner); // Pasar el nombre del ganador directamente
    }
    
    console.log(`🎯 === FIN PROCESAMIENTO BROADCAST ===`);
}

// Reemplazar handleWinnerFromBroadcast con más debug

function handleWinnerFromBroadcast(winnerData) {
    const currentUser = getUserName();
    const winner = winnerData.winner;
    
    console.log(`🎯 === PROCESANDO GANADOR DESDE BROADCAST ===`);
    console.log(`Ganador: "${winner}"`);
    console.log(`Usuario actual: "${currentUser}"`);
    console.log(`Timestamp: ${winnerData.timestamp}`);
    console.log(`Fuente: ${winnerData.source || 'no especificada'}`);
    
    // SI YA SE MOSTRÓ VICTORIA DIRECTA, IGNORAR BROADCAST
    if (window.victoryShown) {
        console.log('⚠️ Victoria ya mostrada directamente, ignorando broadcast');
        return;
    }
    
    // Verificar si el evento es reciente (últimos 30 segundos)
    if (Date.now() - winnerData.timestamp > 30000) {
        console.log('⚠️ Evento de ganador muy antiguo, ignorando');
        return;
    }
    
    // Verificar si ya hay un SweetAlert abierto
    if (document.body.classList.contains('swal2-shown')) {
        console.log('⚠️ Ya hay un SweetAlert abierto, ignorando broadcast');
        return;
    }
    
    // Verificar si ya se procesó este evento
    if (window.lastProcessedWinner === winner && window.lastProcessedTimestamp === winnerData.timestamp) {
        console.log('⚠️ Evento ya procesado anteriormente, ignorando');
        return;
    }
    
    // Marcar evento como procesado
    window.lastProcessedWinner = winner;
    window.lastProcessedTimestamp = winnerData.timestamp;
    
    if (winner === currentUser) {
        // Este usuario es el ganador DESDE BROADCAST (no directo)
        console.log('🏆 SOY EL GANADOR desde broadcast - Mostrando interfaz de victoria');
        handleLocalWinner();
    } else {
        // 💔 OTRO USUARIO GANÓ
        console.log(`💔 OTRO USUARIO GANÓ: "${winner}" - Mostrando interfaz de perdedor`);
        handleLocalLoser(winner); // Pasar el nombre del ganador directamente
    }
    
    console.log(`🎯 === FIN PROCESAMIENTO BROADCAST ===`);
}

function emergencyCleanup() {
    console.log('🚨 LIMPIEZA DE EMERGENCIA - Desbloqueando interfaz');
    
    // Ocultar animación Lottie
    hideLottieAnimation();
    
    // Mostrar contenido principal
    mostrarMainContent();
    
    // Remover clases que ocultan contenido
    document.body.classList.remove('oculto-por-dialogo');
    
    // Cerrar cualquier SweetAlert abierto
    if (typeof Swal !== 'undefined' && Swal.isVisible()) {
        Swal.close();
    }
    
    // Resetear variables de estado
    window.victoryShown = false;
    window.defeatShown = false;
    window.currentBlockAlert = false;
    
    console.log('✅ Limpieza de emergencia completada');
}

// Agregar combinación de teclas de emergencia (Ctrl+Shift+E)
document.addEventListener('keydown', function(event) {
    if (event.ctrlKey && event.shiftKey && event.key === 'E') {
        emergencyCleanup();
    }
});

// Reemplazar la función handleLocalWinner existente
// Reemplazar la función handleLocalWinner existente

// Reemplazar la función handleLocalWinner existente

function handleLocalWinner() {
    console.log('🎉 Manejando victoria local');
    
    // Verificar si ya hay un SweetAlert abierto
    if (document.body.classList.contains('swal2-shown')) {
        console.log('⚠️ Ya hay un SweetAlert de victoria abierto, no mostrar otro');
        return;
    }
    
    // Verificar si ya se mostró victoria
    if (window.victoryShown) {
        console.log('⚠️ Victoria ya mostrada anteriormente');
        return;
    }
    
    // Marcar victoria como mostrada
    window.victoryShown = true;
    
    // Detener el juego
    stopGameInitializationAndHide();
    ocultarMainContent();
    hideLottieAnimation();
    
    // Detener polling si está activo
    if (winnerPollingInterval) {
        clearInterval(winnerPollingInterval);
        winnerPollingInterval = null;
    }
    
    // Efectos de victoria
    playWinnerSound();
    launchConfetti();
    
    // Mostrar mensaje de victoria
    Swal.fire({
        title: '¡Eres el GANADOR! 🎉',
        text: '¡Tu rival ha abandonado, has ganado la partida!',
        icon: 'success',
        confirmButtonText: 'Aceptar',
        allowOutsideClick: false,
        allowEscapeKey: false
    }).then(() => {
        // 🆕 LIMPIAR TODO INMEDIATAMENTE AL CONFIRMAR
        const userName = getUserName();
        console.log('👤 Usuario ganador confirmó salir - Limpiando todo');
        
        if (userName && userName !== 'Invitado') {
            // Limpiar sesión (celda E)
            fetch(scriptURL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'clearUserSession',
                    username: userName
                })
            });
            
            // Limpiar estado de ganador (celda F)
            fetch(scriptURL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'clearWinnerStatus',
                    username: userName
                })
            });
            
            // Limpiar ganador permanente (celda G)
            fetch(scriptURL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'clearPermanentWinner'
                })
            });
        }
        
        if (window.parent !== window) {
            window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
        } else {
            window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
        }
    });
}

// Reemplazar la función handleLocalLoser existente
// Reemplazar handleLocalLoser para preservar ganador permanente

// Actualizar handleLocalLoser para NO limpiar sesiones

// Modificar la función handleLocalLoser para asegurar limpieza

// Reemplazar la función handleLocalLoser completa:

function handleLocalLoser() {
    console.log('😢 MANEJANDO USUARIO PERDEDOR LOCAL');
    
    // Verificar duplicados
    if (window.loserShown) {
        console.log('⚠️ Mensaje de perdedor ya mostrado, ignorando');
        return;
    }
    
    // Marcar que ya se mostró el mensaje de perdedor
    window.loserShown = true;
    
    // 🆕 LIMPIAR CELDA F INMEDIATAMENTE (ANTES del mensaje)
    const userName = getUserName();
    if (userName && userName !== 'Invitado') {
        console.log('🧹 Limpiando celda F ANTES de mostrar mensaje de perdedor');
        fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearWinnerStatus',
                username: userName
            })
        });
    }
    
    // DETENER Y OCULTAR TODO
    stopAbandonWinnerPolling();
    stopGameInitializationAndHide();
    ocultarMainContent();
    hideLottieAnimation();
    
    // Detener otros timers
    if (winnerPollingInterval) {
        clearInterval(winnerPollingInterval);
        winnerPollingInterval = null;
    }
    
    stopTimer();
    stopRankingUpdates();
    stopAllAudio();
    
    console.log('👤 Usuario perdedor:', userName);
    
    // MENSAJE DE PERDEDOR
    Swal.fire({
        title: '¡Has perdido! 😔',
        html: `
            <div style="text-align: center; margin: 15px 0;">
                <p style="font-size: 18px; color: #dc2626; margin-bottom: 10px;">
                    😔 Otro jugador completó el crucigrama antes que tú
                </p>
                <p style="font-size: 16px; color: #4b5563;">
                    ¡Mejor suerte la próxima vez!
                </p>
            </div>
        `,
        icon: 'error',
        confirmButtonText: 'Aceptar',
        allowOutsideClick: false,
        allowEscapeKey: false,
        customClass: {
            popup: 'loser-popup',
            title: 'loser-title',
            htmlContainer: 'loser-content'
        }
    }).then(() => {
        console.log('👤 Usuario perdedor confirmó salir');
        
        // 🆕 DOBLE LIMPIEZA AL CONFIRMAR (por seguridad)
        if (userName && userName !== 'Invitado') {
            console.log('🧹 Segunda limpieza al confirmar salir');
            
            // Usar fetch normal con keepalive para mejor confiabilidad
            fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'clearWinnerStatus',
                    username: userName
                }),
                keepalive: true
            }).then(() => {
                console.log('✅ Segunda limpieza completada');
                salirDelJuego();
            }).catch(() => {
                // Si falla, intentar con sendBeacon
                navigator.sendBeacon(scriptURL, JSON.stringify({
                    action: 'clearWinnerStatus',
                    username: userName
                }));
                salirDelJuego();
            });
        } else {
            salirDelJuego();
        }
    });
}

// Función auxiliar para salir
function salirDelJuego() {
    setTimeout(() => {
        if (window.parent !== window) {
            console.log('🚪 Cerrando juego en iframe...');
            window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
        } else {
            console.log('🚪 Redirigiendo a página principal...');
            window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
        }
    }, 200); // Delay reducido pero suficiente
}


async function checkAndClearWinnerIfNoActiveUsers() {
    console.log('🧹 Verificando si se debe limpiar ganador permanente...');
    
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'scheduleAutoClearPermanentWinner'
            })
        });
        
        console.log('✅ Verificación de limpieza completada');
        
    } catch (error) {
        console.error('❌ Error en verificación de limpieza:', error);
    }
}

// Llamar esta función cuando un usuario salga del juego
window.addEventListener('beforeunload', () => {
    // Programar limpieza después de que el usuario salga
    setTimeout(() => {
        checkAndClearWinnerIfNoActiveUsers();
    }, 2000);
});


let estadoPendiente = null;

// Cuando el usuario gana o pierde:
function usuarioGana() {
  if (document.hidden) {
    estadoPendiente = 'ganador';
  } else {
    Swal.fire('¡Ganaste!', 'Felicidades', 'success');
  }
}

function usuarioPierde() {
  if (document.hidden) {
    estadoPendiente = 'perdedor';
  } else {
    Swal.fire('Perdiste', 'Intenta de nuevo', 'error');
  }
}

// Cuando el usuario regresa a la pestaña:
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'hidden') {
        const userName = getUserName();
        
        if (userName && 
            userName !== 'Invitado' && 
            gameIsActive && 
            !abandonoDetectado) {
            
            console.log('👁️ PÁGINA OCULTA - Posible abandono: ' + userName);
            
            // Esperar un poco para ver si realmente abandonó
            setTimeout(() => {
                if (document.visibilityState === 'hidden' && !abandonoDetectado) {
                    abandonoDetectado = true;
                    navigator.sendBeacon(scriptURL, JSON.stringify({
                        action: 'clearUserSession',
                        username: userName
                    }));
                    console.log('📤 Abandono por página oculta enviado');
                }
            }, 5000); // 5 segundos de espera
        }
    }
});

function mostrarImagenGrandeTemporal(imagenUrl) {
    return new Promise((resolve) => {
        if (!imagenUrl) {
            resolve();
            return;
        }

        // Elimina cualquier overlay anterior
        document.querySelectorAll('.fruit-image-overlay').forEach(el => el.remove());

        // Crea el overlay nuevo
        const overlay = document.createElement('div');
        overlay.className = 'fruit-image-overlay';
        overlay.style.position = 'fixed';
        overlay.style.top = 0;
        overlay.style.left = 0;
        overlay.style.width = '100vw';
        overlay.style.height = '100vh';
        overlay.style.background = 'rgba(0,0,0,0.85)';
        overlay.style.display = 'flex';
        overlay.style.justifyContent = 'center';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = 9999;

        const imgGrande = document.createElement('img');
        imgGrande.src = imagenUrl;
        imgGrande.style.maxWidth = '90vw';
        imgGrande.style.maxHeight = '90vh';
        imgGrande.style.borderRadius = '20px';
        imgGrande.style.boxShadow = '0 8px 40px #000a';

        overlay.appendChild(imgGrande);
        document.body.appendChild(overlay);

        // Permite cerrar el overlay haciendo clic
        overlay.addEventListener('click', () => {
            overlay.remove();
            resolve();
        });

        // Cierra automáticamente después de 3 segundos
        setTimeout(() => {
            overlay.remove();
            resolve();
        }, 3000);
    });
}

function precargarImagenes(frutas) {
    frutas.forEach(fruta => {
        const img = new Image();
        img.src = fruta.image;
    });
}

// Llama a esta función al iniciar el juego:
precargarImagenes(fruits);

function mostrarMainContent() {
    document.body.classList.remove('oculto-por-dialogo');
}
function ocultarMainContent() {
    document.body.classList.add('oculto-por-dialogo');
}

function createLottieOverlayIfNotExists() {
    if (document.getElementById('lottie-wait-overlay')) {
        return; // Ya existe
    }

    const overlayDiv = document.createElement('div');
    overlayDiv.id = 'lottie-wait-overlay';
    overlayDiv.style.display = 'none';
    overlayDiv.style.position = 'fixed';
    overlayDiv.style.top = '0';
    overlayDiv.style.left = '0';
    overlayDiv.style.width = '100vw';
    overlayDiv.style.height = '100vh';
    overlayDiv.style.background = 'rgba(0,0,0,0.25)';
    overlayDiv.style.zIndex = '99999';
    overlayDiv.style.justifyContent = 'center';
    overlayDiv.style.alignItems = 'center';

    const lottiePlayer = document.createElement('lottie-player');
    lottiePlayer.id = 'lottie-wait';
    lottiePlayer.setAttribute('src', 'https://fawzinoo.github.io/Rep/Animation%20-%201750018222493.json');
    lottiePlayer.setAttribute('background', 'transparent');
    lottiePlayer.setAttribute('speed', '1');
    lottiePlayer.style.width = '100px';
    lottiePlayer.style.height = '100px';
    lottiePlayer.setAttribute('loop', '');
    lottiePlayer.setAttribute('autoplay', '');

    overlayDiv.appendChild(lottiePlayer);
    document.body.appendChild(overlayDiv);
}

function showLottieAnimation() {
    createLottieOverlayIfNotExists(); // Asegura que el overlay exista
    const lottieOverlay = document.getElementById('lottie-wait-overlay');
    if (lottieOverlay) {
        lottieOverlay.style.display = 'flex';
        const player = document.getElementById('lottie-wait');
        if (player && typeof player.play === 'function') { // Verificar que player.play sea una función
            player.play();
        }
    }
}

function hideLottieAnimation() {
    const lottieOverlay = document.getElementById('lottie-wait-overlay');
    if (lottieOverlay) {
        lottieOverlay.style.display = 'none';
        const player = document.getElementById('lottie-wait');
        if (player && typeof player.stop === 'function') { // Verificar que player.stop sea una función
            player.stop();
        }
    }
}

function handleDeviceOptimizations() {
    // Detectar tipo de dispositivo
    const screenWidth = window.innerWidth;
    const isMobile = screenWidth <= 768;
    const isTablet = screenWidth > 768 && screenWidth <= 1024;
    const isPC = screenWidth > 1024;
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // Elementos DOM
    const virtualKeyboard = document.querySelector('.virtual-keyboard');
    const gridContainer = document.querySelector('.grid-container');
    const crosswordContainer = document.querySelector('.crossword-container');
    
    console.log(`Dispositivo detectado: ${isMobile ? 'Móvil' : isTablet ? 'Tablet' : 'PC'}, Táctil: ${isTouchDevice}`);
    
    // Manejar teclado virtual
    if (virtualKeyboard) {
        if (isPC && !isTouchDevice) {
            // Ocultar en PC sin táctil
            virtualKeyboard.style.display = 'none';
            console.log('Teclado virtual ocultado - PC detectado');
        } else if (isMobile || (isTablet && isTouchDevice)) {
            // Mostrar en móviles y tablets táctiles
            virtualKeyboard.style.display = 'block';
            console.log('Teclado virtual mostrado - Dispositivo táctil');
        } else {
            // Ocultar en tablets sin táctil
            virtualKeyboard.style.display = 'none';
            console.log('Teclado virtual ocultado - Tablet sin táctil');
        }
    }
    
    // Optimizaciones específicas para PC
    if (isPC) {
        // Ajustar contenedor del grid para PC - ALTURA Y ANCHO
        if (gridContainer) {
            gridContainer.style.maxHeight = '52vh'; // Altura reducida
            gridContainer.style.maxWidth = '60vw';  // Ancho aumentado a 90% del viewport
            gridContainer.style.padding = '20px';
            gridContainer.style.margin = '0 auto';
        }
        
        // Ajustar contenedor principal para PC - ANCHO AUMENTADO
        if (crosswordContainer) {
            crosswordContainer.style.maxWidth = '63vw';     // Ancho aumentado a 95% del viewport
            crosswordContainer.style.width = '100%';        // Ocupar todo el ancho disponible
            crosswordContainer.style.padding = '20px';
            crosswordContainer.style.margin = '0 auto';
            crosswordContainer.style.boxSizing = 'border-box';
        }
        
        console.log('Optimizaciones para PC aplicadas - Altura y ancho ajustados');
    }
    
    // Optimizaciones para tablets - MANTENER ORIGINAL
    if (isTablet) {
        if (gridContainer) {
            gridContainer.style.maxHeight = '600px'; // VALOR ORIGINAL
        }
        
        if (crosswordContainer) {
            crosswordContainer.style.maxWidth = '600px'; // VALOR ORIGINAL
        }
        
        console.log('Optimizaciones para tablet aplicadas');
    }
            
}

// Event listeners para ejecutar la función
document.addEventListener('DOMContentLoaded', function() {
    handleDeviceOptimizations();
});

window.addEventListener('resize', function() {
    handleDeviceOptimizations();
});

window.addEventListener('orientationchange', function() {
    setTimeout(handleDeviceOptimizations, 100);
});


function handleBackButton() {
    // Reproducir el sonido de los botones
    playKeySound('back');
    
    // Efecto visual adicional
    const backButton = document.getElementById('backButton');
    if (backButton) {
        backButton.style.transform = 'scale(0.95)';
        setTimeout(() => {
            backButton.style.transform = '';
        }, 150);
    }
    
    // Pequeño delay para que se aprecie el efecto antes de salir
    setTimeout(() => {
        cerrarIframeYSalir();
    }, 100);
}


// NUEVA FUNCIÓN PARA OBTENER PUNTOS TOTALES DEL USUARIO
async function getTotalPointsFromSheet() {
    const userData = getUserData();
    const userName = userData.username;
    
    if (!userName || userName === 'Invitado') {
        console.log('❌ No se pueden obtener puntos totales - usuario no registrado');
        return 0;
    }
    
    const postData = {
        action: 'getTotalPoints',
        username: userName
    };
    
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        
        const data = await response.json();
        
        if (data.success) {
            return data.totalPoints || 0;
        } else {
            console.warn('⚠️ Error obteniendo puntos totales:', data.error);
            return 0;
        }
    } catch (error) {
        console.error('💥 Error de red obteniendo puntos totales:', error);
        return 0;
    }
}

// NUEVA FUNCIÓN PARA ACTUALIZAR LA VISUALIZACIÓN DE PUNTOS TOTALES
function updateTotalPointsDisplay(points) {
    const totalPointsElement = document.getElementById('totalPoints');
    if (totalPointsElement) {
        totalPointsElement.textContent = points;
    } else {
        console.error('Elemento totalPoints no encontrado');
    }
}

// NUEVA FUNCIÓN PARA CARGAR PUNTOS TOTALES AL INICIO
async function loadTotalPoints() {
    console.log('🏆 Cargando puntos totales del usuario...');
    try {
        const totalPoints = await getTotalPointsFromSheet();
        updateTotalPointsDisplay(totalPoints);
        console.log(`✅ Puntos totales cargados: ${totalPoints}`);
    } catch (error) {
        console.error('💥 Error cargando puntos totales:', error);
        updateTotalPointsDisplay(0);
    }
}

// NUEVA FUNCIÓN PARA ACTUALIZAR PUNTOS TOTALES DESPUÉS DE COMPLETAR UNA FRUTA
async function updateTotalPointsAfterScore() {
    // Pequeño delay para asegurar que el backend se haya actualizado
    setTimeout(async () => {
        const totalPoints = await getTotalPointsFromSheet();
        updateTotalPointsDisplay(totalPoints);
        
        // Efecto visual para el marcador de puntos totales
        const totalPointsContainer = document.getElementById('totalPointsContainer');
        if (totalPointsContainer) {
            totalPointsContainer.classList.add('animate-score');
            setTimeout(() => {
                totalPointsContainer.classList.remove('animate-score');
            }, 600);
        }
    }, 1000); // 1 segundo de delay
}





// NUEVA FUNCIÓN PARA OBTENER RANKING TOP 3
async function getRankingTop3FromSheet() {
    const postData = {
        action: 'getRankingTop3'
    };
    
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        
        const data = await response.json();
        
        if (data.success) {
            return data.ranking || [];
        } else {
            console.warn('⚠️ Error obteniendo ranking:', data.error);
            return [];
        }
    } catch (error) {
        console.error('💥 Error de red obteniendo ranking:', error);
        return [];
    }
}

// NUEVA FUNCIÓN PARA ACTUALIZAR LA VISUALIZACIÓN DEL RANKING
function updateRankingDisplay(ranking) {
    const rankingListElement = document.getElementById('rankingList');
    if (!rankingListElement) {
        console.error('Elemento rankingList no encontrado');
        return;
    }

    if (ranking.length === 0) {
        rankingListElement.innerHTML = '<div class="ranking-empty">Sin datos</div>';
        return;
    }

    let html = '';
    ranking.forEach((user, index) => {
        const position = index + 1;
        html += `
            <div class="ranking-item">
                <span class="ranking-position">${position}.</span>
                <span class="ranking-user">${user.username}</span>
                <span class="ranking-score">⭐ ${user.points}</span>
            </div>
        `;
    });

    rankingListElement.innerHTML = html;
}

// NUEVA FUNCIÓN PARA CARGAR RANKING AL INICIO
async function loadRanking() {
    console.log('🏆 Cargando ranking top 3...');
    try {
        const ranking = await getRankingTop3FromSheet();
        updateRankingDisplay(ranking);
        console.log(`✅ Ranking cargado: ${ranking.length} usuarios`);
    } catch (error) {
        console.error('💥 Error cargando ranking:', error);
        updateRankingDisplay([]);
    }
}

// VARIABLE PARA EL INTERVALO DE RANKING
let rankingUpdateInterval = null;

// NUEVA FUNCIÓN PARA INICIAR ACTUALIZACIÓN AUTOMÁTICA DEL RANKING
// Modificar la función startRankingUpdates existente:

// FUNCIÓN PARA INICIAR ACTUALIZACIÓN AUTOMÁTICA DE AMBOS RANKINGS - VERSIÓN ACTUALIZADA
function startRankingUpdates() {
    console.log('🔄 Iniciando sistema de rankings con intervalos diferenciados...');
    
    // Cargar ambos rankings inmediatamente
    loadRanking(); // Ranking total (histórico)
    loadCurrentGameRanking(); // Ranking partido actual
    
    // CONFIGURAR DIFERENTES INTERVALOS
    
    // 1. RANKING TOTAL: cada 5 segundos (como antes)
    if (rankingUpdateInterval) {
        clearInterval(rankingUpdateInterval);
    }
    
    rankingUpdateInterval = setInterval(() => {
        console.log('🔄 Actualizando ranking total automáticamente...');
        loadRanking(); // Solo ranking total
    }, 5000); // 5 segundos
    
    // 2. RANKING PARTIDA ACTUAL: cada 20 segundos (NUEVO)
    if (typeof currentGameRankingUpdateInterval !== 'undefined' && currentGameRankingUpdateInterval) {
        clearInterval(currentGameRankingUpdateInterval);
    }
    
    window.currentGameRankingUpdateInterval = setInterval(() => {
        console.log('🎮 Actualizando ranking partida actual automáticamente...');
        loadCurrentGameRanking(); // Solo ranking partida actual
    }, 20000); // 20 segundos
    
    console.log('✅ Sistema de rankings iniciado:');
    console.log('   - Ranking Total: cada 5 segundos');
    console.log('   - Ranking Partida: cada 20 segundos');
}

// MODIFICAR LA FUNCIÓN stopRankingUpdates PARA AMBOS INTERVALOS
function stopRankingUpdates() {
    // Detener ranking total
    if (rankingUpdateInterval) {
        clearInterval(rankingUpdateInterval);
        rankingUpdateInterval = null;
        console.log('⏹️ Actualización automática del ranking total detenida');
    }
    
    // Detener ranking partida actual
    if (typeof currentGameRankingUpdateInterval !== 'undefined' && currentGameRankingUpdateInterval) {
        clearInterval(currentGameRankingUpdateInterval);
        window.currentGameRankingUpdateInterval = null;
        console.log('⏹️ Actualización automática del ranking partida actual detenida');
    }
    
    console.log('🛑 Todos los rankings detenidos');
}

// NUEVA FUNCIÓN MEJORADA PARA OBTENER RANKING PARTIDO ACTUAL CON FILTRO DE SESIÓN
async function getCurrentGameRankingFromSheet() {
    const postData = {
        action: 'getRankingCurrentGame'
    };
    
    console.log('🎮 Solicitando ranking del partido actual (solo usuarios en sesión) al servidor...');
    
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        
        const data = await response.json();
        console.log('📊 Respuesta del servidor (ranking partido actual con sesión):', data);
        
        if (data.success) {
            const filteredRanking = data.ranking || [];
            console.log(`🔍 Usuarios en sesión encontrados: ${filteredRanking.length}`);
            return filteredRanking;
        } else {
            console.warn('⚠️ Error obteniendo ranking partido actual:', data.error);
            return [];
        }
    } catch (error) {
        console.error('💥 Error de red obteniendo ranking partido actual:', error);
        return [];
    }
}

// ACTUALIZAR LA FUNCIÓN updateCurrentGameRankingDisplay PARA MOSTRAR INFORMACIÓN DE SESIÓN
function updateCurrentGameRankingDisplay(ranking) {
    const rankingListElement = document.getElementById('rankingCurrentList');
    if (!rankingListElement) {
        console.error('❌ Elemento rankingCurrentList no encontrado');
        return;
    }

    console.log('🎯 Actualizando ranking partido actual (solo usuarios en sesión) con datos:', ranking);

    if (ranking.length === 0) {
        rankingListElement.innerHTML = '<div class="ranking-empty">Sin jugadores<br>en sesión</div>';
        return;
    }

    let html = '';
    ranking.forEach((user, index) => {
        const position = index + 1;
        const medal = position === 1 ? '🥇' : position === 2 ? '🥈' : '🥉';
        
        // Mostrar información adicional de sesión en el tooltip
        const sessionInfo = user.session ? ` (${user.session})` : '';
        
        html += `
            <div class="ranking-item" title="Usuario: ${user.username}${sessionInfo}">
                <span class="ranking-position">${medal}</span>
                <span class="ranking-user">${user.username}</span>
                <span class="ranking-score">🔥 ${user.points}</span>
            </div>
        `;
    });

    rankingListElement.innerHTML = html;
    console.log(`✅ Ranking partido actual actualizado correctamente - ${ranking.length} usuarios en sesión`);
}

// NUEVA FUNCIÓN PARA CARGAR RANKING PARTIDO ACTUAL CON MEJOR LOGGING
async function loadCurrentGameRanking() {
    console.log('🎮 Cargando ranking del partido actual (solo usuarios en sesión)...');
    
    // Mostrar estado de carga
    const rankingListElement = document.getElementById('rankingCurrentList');
    if (rankingListElement) {
        rankingListElement.innerHTML = '<div class="ranking-empty">🔄 Cargando...</div>';
    }
    
    try {
        const ranking = await getCurrentGameRankingFromSheet();
        updateCurrentGameRankingDisplay(ranking);
        
        if (ranking.length > 0) {
            console.log(`✅ Ranking partido actual cargado: ${ranking.length} usuarios en sesión activa`);
        } else {
            console.log('ℹ️ No hay usuarios con sesión activa en este momento');
        }
    } catch (error) {
        console.error('💥 Error cargando ranking partido actual:', error);
        if (rankingListElement) {
            rankingListElement.innerHTML = '<div class="ranking-empty">❌ Error al cargar</div>';
        }
    }
}

// FUNCIÓN DE PRUEBA MEJORADA PARA AMBOS RANKINGS
async function testBothRankings() {
    console.log('🧪 === PRUEBA DE AMBOS RANKINGS (CON FILTROS) ===');
    
    console.log('1. Verificando elementos DOM...');
    const rankingContainer = document.getElementById('rankingContainer');
    const rankingList = document.getElementById('rankingList');
    const rankingCurrentContainer = document.getElementById('rankingCurrentContainer');
    const rankingCurrentList = document.getElementById('rankingCurrentList');
    
    console.log('rankingContainer (total):', rankingContainer ? '✅ Encontrado' : '❌ No encontrado');
    console.log('rankingList (total):', rankingList ? '✅ Encontrado' : '❌ No encontrado');
    console.log('rankingCurrentContainer (partida):', rankingCurrentContainer ? '✅ Encontrado' : '❌ No encontrado');
    console.log('rankingCurrentList (partida):', rankingCurrentList ? '✅ Encontrado' : '❌ No encontrado');
    
    console.log('2. Obteniendo datos del ranking total...');
    const rankingTotal = await getRankingTop3FromSheet();
    console.log('Datos ranking total:', rankingTotal);
    
    console.log('3. Obteniendo datos del ranking partida actual (solo usuarios en sesión)...');
    const rankingCurrent = await getCurrentGameRankingFromSheet();
    console.log('Datos ranking partida actual (con sesión):', rankingCurrent);
    
    console.log('4. Actualizando visualizaciones...');
    updateRankingDisplay(rankingTotal);
    updateCurrentGameRankingDisplay(rankingCurrent);
    
    console.log('🧪 === FIN PRUEBA DE AMBOS RANKINGS (CON FILTROS) ===');
}


// Agregar esta función para manejar casos específicos de abandono
function handleWinnerByAbandonment() {
    console.log('🏆 Ganador por abandono del rival detectado');
    
    // Detener todo inmediatamente
    stopGameInitializationAndHide();
    
    // Detener polling
    if (winnerPollingInterval) {
        clearInterval(winnerPollingInterval);
        winnerPollingInterval = null;
    }
    
    // Mostrar mensaje de victoria
    Swal.fire({
        title: '🎉 ¡GANASTE POR ABANDONO!',
        html: `
            <div style="text-align: center; margin: 15px 0;">
                <p style="font-size: 18px; color: #059669; margin-bottom: 10px;">
                    🏃‍♂️ Tu rival ha abandonado la partida
                </p>
                <p style="font-size: 16px; color: #4b5563;">
                    ¡Felicidades, eres el ganador!
                </p>
            </div>
        `,
        icon: 'success',
        confirmButtonText: '¡Genial!',
        confirmButtonColor: '#059669',
        allowOutsideClick: false,
        allowEscapeKey: false
    }).then(() => {
        const userName = getUserName();
        clearSessionOnServer(userName);
        if (window.parent !== window) {
            window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
        } else {
            window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
        }
    });
    
    // Efectos visuales
    launchConfetti();
    playWinnerSound();
}

function pollStatus() {
    fetch(scriptURL, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: JSON.stringify({
            action: 'getScoreStatusAndRank',
            username: userName
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.completed === "GANADOR") {
            mostrarMensajeGanador();
        } else if (data.completed === "PERDEDOR") {
            mostrarMensajePerdedor();
        } else {
            setTimeout(pollStatus, 2000);
        }
    });
}

function mostrarMensajePerdedor() {
    Swal.fire({
        title: 'Has perdido',
        text: 'Otro jugador ha completado antes que tú.',
        icon: 'error',
        confirmButtonText: 'Aceptar',
        allowOutsideClick: false,
        allowEscapeKey: false
    }).then(() => {
        // Aquí puedes limpiar la sesión, redirigir, etc.
        // Por ejemplo:
        window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
    });
    // Deshabilita la interfaz de juego
    document.querySelectorAll('input, button').forEach(el => el.disabled = true);
}

// En tu archivo JavaScript del cliente
async function verificarPermisosYEjecutar(accion, datos) {
    try {
        // Verificar si el usuario puede editar
        const checkResponse = await fetch(API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                action: 'canUserEdit',
                username: currentUsername
            })
        });
        
        const checkResult = await checkResponse.json();
        
        if (!checkResult.success || !checkResult.canEdit) {
            // Usuario no puede editar
            mostrarMensajeBloqueo(checkResult.status);
            return { success: false, blocked: true };
        }
        
        // Usuario puede editar, ejecutar la acción original
        const actionResponse = await fetch(API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(datos)
        });
        
        return await actionResponse.json();
        
    } catch (error) {
        console.error('Error verificando permisos:', error);
        return { success: false, error: error.message };
    }
}




// Reemplazar la función mostrarMensajeBloqueo existente

async function mostrarMensajeBloqueo(status, winnerName = null) {
    // Evitar mostrar múltiples alertas del mismo tipo
    if (window.currentBlockAlert) {
        return;
    }
    
    const userName = getUserName();
    
    let mensaje = "No puedes realizar más cambios.";
    let titulo = "Juego Bloqueado";
    let icono = 'warning';
    
    if (status === "PERDEDOR") {
        // 🧹 SIEMPRE LIMPIAR CELDA F cuando se muestra mensaje de perdedor
        console.log('🔴 PERDEDOR detectado en mostrarMensajeBloqueo - Limpiando celda F inmediatamente');
        
        if (userName && userName !== 'Invitado') {
            fetch(scriptURL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'clearWinnerStatus',
                    username: userName
                })
            }).then(() => {
                console.log(`✅ Celda F limpiada para ${userName} en mostrarMensajeBloqueo`);
            }).catch(error => {
                console.error('❌ Error limpiando celda F:', error);
            });
        }
        
        // 🔍 DETERMINAR EL NOMBRE DEL GANADOR
        let ganadorFinal = winnerName; // Usar el parámetro proporcionado
        
        // Solo buscar el ganador si no se proporcionó o es genérico
        if (!ganadorFinal || ganadorFinal === 'Otro jugador') {
            console.log('🔍 Nombre del ganador no proporcionado, buscando en servidor...');
            try {
                const response = await fetch(scriptURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'getScoreStatusAndRank',
                        username: userName
                    })
                });
                const data = await response.json();
                if (data && data.winnerName && data.winnerName !== 'Otro jugador') {
                    ganadorFinal = data.winnerName;
                    console.log(`🔍 Ganador encontrado en servidor: "${ganadorFinal}"`);
                } else {
                    ganadorFinal = 'Otro jugador';
                    console.log('🔍 No se encontró ganador específico en servidor');
                }
            } catch (error) {
                console.error('❌ Error obteniendo nombre del ganador:', error);
                ganadorFinal = 'Otro jugador';
            }
        } else {
            console.log(`✅ Usando nombre del ganador proporcionado: "${ganadorFinal}"`);
        }
        
        // DETENER EL JUEGO Y OCULTAR CONTENIDO
        stopGameInitializationAndHide();
        ocultarMainContent();
        hideLottieAnimation();
        
        // Detener foto timeout si existe
        if (typeof photoTimeoutId !== 'undefined' && photoTimeoutId) {
            clearTimeout(photoTimeoutId);
            photoTimeoutId = null;
        }
        
        // 🎯 MENSAJE ESPECÍFICO CON EL NOMBRE DEL GANADOR
        mensaje = `${ganadorFinal} ha ganado la partida.`;
        titulo = "¡Has Perdido!";
        icono = 'error';
        
        console.log(`🔴 Mostrando mensaje final: "${mensaje}"`);
        
        window.currentBlockAlert = true;
        
        Swal.fire({
            title: titulo,
            text: mensaje,
            icon: icono,
            confirmButtonText: 'Salir del Juego',
            allowOutsideClick: false,
            allowEscapeKey: false,
            showCloseButton: false
}).then((result) => {
    if (result.isConfirmed) {
        // 🆕 LIMPIAR INMEDIATAMENTE AL CONFIRMAR SALIR
        console.log('👤 Usuario confirmó salir - Limpiando estado y sesión');
        
        if (userName && userName !== 'Invitado') {
            Promise.all([
                // Limpiar estado (PERDEDOR)
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearWinnerStatus',
                        username: userName
                    })
                }),
                // Limpiar sesión
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearUserSession',
                        username: userName
                    })
                })
            ]).then(() => {
                console.log('✅ Estado y sesión limpiados desde mostrarMensajeBloqueo');
                
                // Salir después de confirmar limpieza
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
                } else {
                    window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
                }
            });
        } else {
            // Si no hay usuario válido, salir directamente
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
            } else {
                window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
            }
        }
    }
    window.currentBlockAlert = false;
});
        
        return;
        
    } else if (status === "GANADOR") {
        // 🧹 SIEMPRE LIMPIAR CELDA F cuando se muestra mensaje de ganador
        console.log('🟢 GANADOR detectado - Limpiando celda F inmediatamente');
        
        if (userName && userName !== 'Invitado') {
            fetch(scriptURL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'clearWinnerStatus',
                    username: userName
                })
            }).then(() => {
                console.log(`✅ Celda F limpiada para ${userName} en mostrarMensajeBloqueo GANADOR`);
            }).catch(error => {
                console.error('❌ Error limpiando celda F:', error);
            });
        }
        
        mensaje = "¡Felicitaciones! Ya has ganado el juego.";
        titulo = "¡Tu rival ha abandonado!";
        icono = 'success';

        // Detener el juego y ocultar contenido
        stopGameInitializationAndHide();
        ocultarMainContent();
        hideLottieAnimation();
        stopTimer();
        stopRankingUpdates();
        stopAllAudio();
    }
    
    // Para GANADOR u otros casos
    window.currentBlockAlert = true;
    
    Swal.fire({
        title: titulo,
        text: mensaje,
        icon: icono,
        confirmButtonText: 'Entendido',
        allowOutsideClick: false,
        timer: undefined,
        timerProgressBar: false
    }).then(() => {
        window.currentBlockAlert = false;
        if (status === "GANADOR") {
            window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
        }
    });
}

// Función para probar limpieza manual

async function testClearUserStates() {
    console.log('🧪 === PROBANDO LIMPIEZA DE ESTADOS ===');
    
    const userName = getUserName();
    console.log('Usuario:', userName);
    
    if (!userName || userName === 'Invitado') {
        console.log('❌ No se puede probar - usuario no válido');
        return;
    }
    
    try {
        // Probar limpieza de estado
        console.log('1. Limpiando estado (columna F)...');
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearWinnerStatus',
                username: userName
            })
        });
        
        // Probar limpieza de sesión
        console.log('2. Limpiando sesión (columna E)...');
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearUserSession',
                username: userName
            })
        });
        
        console.log('✅ Limpieza completa enviada');
        
        // Verificar resultado después de 2 segundos
        setTimeout(async () => {
            const response = await fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'getScoreStatusAndRank',
                    username: userName
                })
            });
            
            const data = await response.json();
            console.log('📊 Estado después de limpieza:', data.completed);
            
        }, 2000);
        
    } catch (error) {
        console.error('❌ Error:', error);
    }
    
    console.log('🧪 === FIN PRUEBA ===');
}

async function registrarPuntos(datos) {
    const resultado = await verificarPermisosYEjecutar('registerPoints', {
        action: 'registerPoints',
        username: currentUsername,
        ...datos
    });
    
    if (resultado.blocked) {
        return; // Usuario bloqueado, no continuar
    }
    
    // Procesar resultado normal...
    if (resultado.success) {
        console.log('Puntos registrados:', resultado.pointsRegistered);
    } else {
        console.error('Error registrando puntos:', resultado.error);
    }
}

// En tus event listeners de las celdas
function setupCellEventListeners() {
    const allCells = document.querySelectorAll('.crossword-cell input');
    
    allCells.forEach(cell => {
        cell.addEventListener('input', async function(event) {
            // Verificar permisos antes de procesar el input
            const canEdit = await verificarSiPuedeEditar();
            
            if (!canEdit) {
                event.preventDefault();
                this.value = ''; // Limpiar el valor
                return false;
            }
            
            // Tu lógica existente de input aquí...
        });
        
        cell.addEventListener('keydown', async function(event) {
            const canEdit = await verificarSiPuedeEditar();
            
            if (!canEdit) {
                event.preventDefault();
                return false;
            }
            
            // Tu lógica existente de keydown aquí...
        });
    });
}

async function verificarSiPuedeEditar() {
    try {
        const response = await fetch(API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                action: 'canUserEdit',
                username: currentUsername
            })
        });
        
        const result = await response.json();
        
        if (!result.success || !result.canEdit) {
            mostrarMensajeBloqueo(result.status);
            return false;
        }
        
        return true;
    } catch (error) {
        console.error('Error verificando permisos:', error);
        return false; // Por seguridad, bloquear si hay error
    }
}

// Modificar la variable userPermissionsCache existente

let userPermissionsCache = {
    canEdit: true,
    status: '',
    lastCheck: 0,
    cacheTimeout: 15000 // Aumentado a 15 segundos para mejor rendimiento
};

// Función optimizada para verificar permisos con caché
// Reemplazar la función checkUserPermissionsCached existente

async function checkUserPermissionsCached() {
    const userData = getUserData();
    const userName = userData.username;
    
    // Si es invitado, siempre puede editar (sin verificaciones adicionales)
    if (!userName || userName === 'Invitado') {
        return { canEdit: true, status: '' };
    }
    
    const now = Date.now();
    
    // Verificar si el caché es válido (15 segundos)
    if (now - userPermissionsCache.lastCheck < userPermissionsCache.cacheTimeout) {
        return {
            canEdit: userPermissionsCache.canEdit,
            status: userPermissionsCache.status
        };
    }
    
    // Caché expirado, verificar con el servidor (solo si es necesario)
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'canUserEdit',
                username: userName
            })
        });
        
        const result = await response.json();
        
        // Actualizar caché
        userPermissionsCache = {
            canEdit: result.success && result.canEdit,
            status: result.status || '',
            lastCheck: now,
            cacheTimeout: 15000 // 15 segundos
        };
        
        return {
            canEdit: userPermissionsCache.canEdit,
            status: userPermissionsCache.status
        };
        
    } catch (error) {
        console.error('Error verificando permisos:', error);
        // En caso de error, asumir que puede editar para no bloquear el juego
        return {
            canEdit: true,
            status: ''
        };
    }
}

// Función para invalidar el caché (llamar cuando sepamos que el estado cambió)
function invalidatePermissionsCache() {
    userPermissionsCache.lastCheck = 0;
}





function logUsageMetrics() {
    const today = new Date().toDateString();
    console.log(`Peticiones del día ${today}: ${requestCount}`);
    
    // Si te acercas al límite, aumentar cacheTimeout
    if (requestCount > 15000) {
        console.warn('⚠️ Acercándose al límite diario');
    }
}

// Agregar esta función al inicio del script

// Reemplazar la función limpiezaInmediataUsuario existente

// Reemplazar la función limpiezaInmediataUsuario existente

// Modificar la función limpiezaInmediataUsuario para incluir limpieza de celda F

async function limpiezaInmediataUsuario(username, origen = 'manual') {
    if (!username || username === 'Invitado') {
        console.log('⚠️ No se puede limpiar - usuario no válido');
        return;
    }
    
    console.log(`🧹 Iniciando limpieza inmediata para ${username} (origen: ${origen})`);
    
    try {
        // 1. Limpiar sesión (celda E)
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearUserSession',
                username: username
            })
        });
        console.log(`✅ Sesión limpiada para ${username}`);
        
        // 🆕 2. Limpiar celda F también por seguridad
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearWinnerStatus',
                username: username
            })
        });
        console.log(`✅ Celda F limpiada para ${username}`);
        
        // 3. Invalidar caché
        invalidatePermissionsCache();
        console.log(`✅ Caché invalidado para ${username}`);
        
    } catch (error) {
        console.error(`❌ Error en limpieza inmediata para ${username}:`, error);
    }
}


// Limpieza automática al abandonar la página
// Reemplazar el event listener beforeunload existente

window.addEventListener('beforeunload', async (event) => {
    const userName = getUserName();
    if (userName && userName !== 'Invitado' && gameIsActive) {
        // VALIDACIÓN ADICIONAL: Solo limpiar si el juego ha estado activo por más de 60 segundos
        if (window.gameStartTime && Date.now() - window.gameStartTime > 60000) {
            console.log('🚪 Usuario abandonando la página después de 60s - Limpieza inmediata');
            
            navigator.sendBeacon(scriptURL, JSON.stringify({
                action: 'clearUserSession',
                username: userName
            }));
        } else {
            console.log('🚪 Usuario saliendo muy pronto - NO hacer limpieza automática');
        }
    }
});

// Marcar juego como inactivo cuando termine oficialmente
function markGameAsInactive() {
    gameIsActive = false;
    console.log('🎮 Juego marcado como inactivo');
}


// Agregar una función específica para limpiar solo la celda F

async function limpiarSoloCeldaF(username, reason = 'unknown') {
    console.log(`🧹 LIMPIANDO SOLO CELDA F para ${username} - Motivo: ${reason}`);
    
    if (!username || username === 'Invitado') {
        console.log('❌ No se puede limpiar - usuario no válido');
        return;
    }
    
    try {
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearWinnerStatus',
                username: username
            })
        });
        console.log(`✅ Celda F limpiada para ${username} - Motivo: ${reason}`);
        
        // Invalidar caché de permisos
        invalidatePermissionsCache();
        
    } catch (error) {
        console.error('❌ Error limpiando celda F:', error);
    }
}

// Función auxiliar para obtener el nombre del ganador

async function obtenerNombreGanador() {
    try {
        const userName = getUserName();
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'getScoreStatusAndRank',
                username: userName
            })
        });
        const data = await response.json();
        return data.winnerName || 'Otro jugador';
    } catch (error) {
        console.error('Error obteniendo nombre del ganador:', error);
        return 'Otro jugador';
    }
}

// Función de debug para verificar nombres de ganador

async function debugWinnerName() {
    console.log('🧪 === DEBUG NOMBRE DEL GANADOR ===');
    
    const userName = getUserName();
    console.log('Usuario actual:', userName);
    
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'getScoreStatusAndRank',
                username: userName
            })
        });
        
        const data = await response.json();
        console.log('Respuesta completa del servidor:', data);
        console.log('Nombre del ganador en respuesta:', data.winnerName);
        console.log('Tipo de winnerName:', typeof data.winnerName);
        console.log('¿Es undefined?:', data.winnerName === undefined);
        console.log('¿Es null?:', data.winnerName === null);
        console.log('¿Es string vacío?:', data.winnerName === '');
        
    } catch (error) {
        console.error('Error en debug:', error);
    }
    
    console.log('🧪 === FIN DEBUG ===');
}

// Crear función específica para obtener el ganador

// Reemplazar la función obtenerNombreGanadorEspecifico existente

// Reemplazar la función obtenerNombreGanadorEspecifico existente

async function obtenerNombreGanadorEspecifico() {
    console.log('🔍 === OBTENIENDO NOMBRE DEL GANADOR ESPECÍFICAMENTE ===');
    
    try {
        // 🆕 PASO 1: Intentar obtener ganador permanente (más confiable)
        console.log('🔍 Paso 1: Intentando obtener ganador permanente...');
        const responsePermanent = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'getPermanentWinner'
            })
        });
        
        const dataPermanent = await responsePermanent.json();
        console.log('🔍 Respuesta getPermanentWinner:', dataPermanent);
        
        if (dataPermanent && dataPermanent.success && dataPermanent.permanentWinner && dataPermanent.permanentWinner.trim() !== '') {
            console.log(`🏆 ✅ Ganador permanente encontrado: "${dataPermanent.permanentWinner}"`);
            return dataPermanent.permanentWinner;
        }
        
        // 🔄 PASO 2: Fallback usando getWinnerName
        console.log('🔄 Paso 2: Ganador permanente no encontrado, usando fallback getWinnerName...');
        
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'getWinnerName'
            })
        });
        
        const data = await response.json();
        console.log('🔍 Respuesta getWinnerName (fallback):', data);
        
        if (data && data.success && data.winnerName && data.winnerName !== 'Sin ganador' && data.winnerName.trim() !== '') {
            console.log(`🏆 ✅ Ganador encontrado con fallback: "${data.winnerName}"`);
            return data.winnerName;
        }
        
        // 🔄 PASO 3: Último recurso usando getScoreStatusAndRank
        console.log('🔄 Paso 3: Último recurso usando getScoreStatusAndRank...');
        
        const responseScore = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'getScoreStatusAndRank',
                username: 'dummy' // Usuario dummy para obtener info general
            })
        });
        
        const dataScore = await responseScore.json();
        console.log('🔍 Respuesta getScoreStatusAndRank (último recurso):', dataScore);
        
        if (dataScore && dataScore.success && dataScore.winnerName && dataScore.winnerName !== 'Sin ganador' && dataScore.winnerName.trim() !== '') {
            console.log(`🏆 ✅ Ganador encontrado con último recurso: "${dataScore.winnerName}"`);
            return dataScore.winnerName;
        }
        
        console.log('❌ No se encontró ganador con ningún método');
        return 'Otro jugador'; // Fallback final
        
    } catch (error) {
        console.error('❌ Error obteniendo ganador específico:', error);
        return 'Otro jugador'; // Fallback en caso de error
    }
}

window.addEventListener('beforeunload', async (event) => {
    const userName = getUserName();
    
    // Limpiar datos de broadcast al salir
    try {
        localStorage.removeItem('crucigrama_winner_broadcast');
        console.log('🧹 Datos de broadcast limpiados del localStorage');
    } catch (error) {
        console.error('Error limpiando localStorage:', error);
    }
    
    if (userName && userName !== 'Invitado' && gameIsActive) {
        if (window.gameStartTime && Date.now() - window.gameStartTime > 60000) {
            console.log('🚪 Usuario abandonando la página después de 60s - Limpieza inmediata');
            
            navigator.sendBeacon(scriptURL, JSON.stringify({
                action: 'clearUserSession',
                username: userName
            }));
        } else {
            console.log('🚪 Usuario saliendo muy pronto - NO hacer limpieza automática');
        }
    }
});
// Función de debug para probar el sistema de broadcast

function testBroadcastWinner(testWinnerName = null) {
    const winner = testWinnerName || getUserName() || 'TestUser';
    console.log(`🧪 Probando broadcast con ganador: "${winner}"`);
    
    broadcastWinnerToAllUsers(winner);
}

// Agregar función para resetear estados

// Reemplazar la función resetGameStates existente

function resetGameStates() {
    window.victoryShown = false;
    window.defeatShown = false;
    window.lastProcessedWinner = null;
    window.lastProcessedTimestamp = null;
    window.currentBlockAlert = false;
    gameInitializationStopped = false; // Importante para permitir nuevo inicio
    
    // Limpiar broadcast del localStorage
    try {
        localStorage.removeItem('crucigrama_winner_broadcast');
    } catch (e) {}
    
    console.log('🔄 Estados del juego reseteados completamente');
}

// Agregar después de las funciones existentes

// 🆕 DETECTOR DE ABANDONO DE PÁGINA
let abandonoDetectado = false;
let gameIsActive = false;

function setGameActive() {
    gameIsActive = true;
    abandonoDetectado = false;
    console.log('✅ Juego ACTIVO - Detección de abandono habilitada');
}

// Marcar juego como inactivo
// Asegurar que setGameInactive esté definida correctamente

function setGameInactive() {
    gameIsActive = false;
    console.log('❌ Juego INACTIVO - Detección de abandono deshabilitada');
}

// Reemplazar el event listener beforeunload existente:

window.addEventListener('beforeunload', function(event) {
    const userName = getUserName();
    
    console.log('🚪 === BEFOREUNLOAD DETECTADO ===');
    console.log('Usuario:', userName);
    console.log('Juego activo:', gameIsActive);
    console.log('Ya procesado:', abandonoDetectado);
    
    // 🆕 LIMPIAR CELDA F INDEPENDIENTEMENTE DEL ESTADO
    if (userName && userName !== 'Invitado') {
        console.log('🧹 LIMPIEZA FORZADA en beforeunload');
        
        // Doble envío para asegurar que llegue
        const limpiezaData = JSON.stringify({
            action: 'clearWinnerStatus',
            username: userName
        });
        
        const sesionData = JSON.stringify({
            action: 'clearUserSession', 
            username: userName
        });
        
        // Intentar con sendBeacon primero (más confiable)
        try {
            navigator.sendBeacon(scriptURL, limpiezaData);
            navigator.sendBeacon(scriptURL, sesionData);
            console.log('📤 Limpieza enviada con sendBeacon');
        } catch (error) {
            console.error('❌ Error con sendBeacon:', error);
        }
        
        // Backup con fetch + keepalive
        try {
            fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: limpiezaData,
                keepalive: true
            });
            
            fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: sesionData,
                keepalive: true
            });
            console.log('📤 Backup con fetch+keepalive enviado');
        } catch (error) {
            console.error('❌ Error con fetch:', error);
        }
    }
    
    // Solo procesar lógica de abandono si es necesario
    if (userName && 
        userName !== 'Invitado' && 
        gameIsActive && 
        !abandonoDetectado) {
        
        abandonoDetectado = true;
        console.log('✅ Señal de abandono procesada para: ' + userName);
    }
});
// Event listener adicional para pagehide (navegación hacia atrás)
window.addEventListener('pagehide', function(event) {
    const userName = getUserName();
    
    if (userName && 
        userName !== 'Invitado' && 
        gameIsActive && 
        !abandonoDetectado) {
        
        abandonoDetectado = true;
        console.log('⬅️ PAGEHIDE - Abandono por navegación: ' + userName);
        
        navigator.sendBeacon(scriptURL, JSON.stringify({
            action: 'clearUserSession',
            username: userName
        }));
    }
});


// 🆕 POLLING PARA DETECTAR SI EL USUARIO SE CONVIRTIÓ EN GANADOR POR ABANDONO
let abandonWinnerPollingInterval = null;

// Modificar la función startAbandonWinnerPolling existente

// Reemplazar la función startAbandonWinnerPolling con mejor debug

// Polling optimizado

function startAbandonWinnerPolling() {
    // Limpiar polling anterior
    if (abandonWinnerPollingInterval) {
        clearInterval(abandonWinnerPollingInterval);
    }
    
    console.log('🔍 Iniciando polling para detectar victoria por abandono...');
    
    let pollingCount = 0;
    
    abandonWinnerPollingInterval = setInterval(async () => {
        pollingCount++;
        
        try {
            const userName = getUserName();
            if (!userName || userName === 'Invitado' || !gameIsActive) {
                return;
            }
            
            const response = await fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'getScoreStatusAndRank',
                    username: userName
                })
            });
            
            const data = await response.json();
            
            if (data.success && data.completed === 'GANADOR') {
                console.log(`🏆 POLLING #${pollingCount} - ¡${userName} ES GANADOR!`);
                
                // Detener polling
                clearInterval(abandonWinnerPollingInterval);
                abandonWinnerPollingInterval = null;
                
                // Verificar que no sea victoria directa
                if (!window.victoryShown) {
                    console.log('🎯 Victoria por abandono detectada');
                    handleAbandonmentWin();
                }
            } else {
                console.log(`🔍 Polling #${pollingCount} - Estado: ${data.completed || 'sin estado'}`);
            }
            
        } catch (error) {
            console.error(`❌ Error en polling #${pollingCount}:`, error);
        }
    }, 1500); // Verificar cada 1.5 segundos
    
    console.log('✅ Polling iniciado - Verificando cada 1.5 segundos');
}
// Agregar función de debug para probar el sistema

// Función para probar el sistema completo

async function testAbandonSystem() {
    console.log('🧪 === PROBANDO SISTEMA DE ABANDONO ===');
    
    const userName = getUserName();
    console.log('1. Usuario:', userName);
    console.log('2. Juego activo:', gameIsActive);
    console.log('3. Polling activo:', !!abandonWinnerPollingInterval);
    
    if (!gameIsActive) {
        console.log('⚠️ Activando juego primero...');
        setGameActive();
    }
    
    if (!abandonWinnerPollingInterval) {
        console.log('⚠️ Iniciando polling...');
        startAbandonWinnerPolling();
    }
    
    console.log('4. Simulando que ESTE usuario abandona...');
    
    try {
        // Simular abandono del usuario actual
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearUserSession',
                username: userName
            })
        });
        
        console.log('5. ✅ Abandono simulado enviado');
        
        // Verificar resultado después de 3 segundos
        setTimeout(async () => {
            console.log('6. Verificando resultado...');
            
            const checkResponse = await fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'getScoreStatusAndRank',
                    username: userName
                })
            });
            
            const data = await checkResponse.json();
            console.log('7. Estado final:', data.completed);
            
            if (data.completed === 'GANADOR') {
                console.log('🏆 ¡El usuario se convirtió en GANADOR!');
            } else {
                console.log('ℹ️ El usuario no se convirtió en ganador');
            }
        }, 3000);
        
    } catch (error) {
        console.error('❌ Error:', error);
    }
    
    console.log('🧪 === FIN PRUEBA ===');
}

// Para usar en consola: testAbandonSystem()
// Modificar registerGameStart para más debug

async function registerGameStart() {
    const userData = getUserData();
    const userName = userData.username;
    
    console.log('🎮 === REGISTRANDO INICIO DE JUEGO ===');
    console.log('Usuario:', userName);

    if (!userName || userName === 'Invitado') {
        console.log('❌ No se puede registrar inicio - usuario no registrado');
        return false;
    }

    // 🆕 OBTENER SESIÓN INMEDIATAMENTE
    let sessionName;
    try {
        sessionName = await getSessionNameFromServer();
        console.log('📍 Sesión obtenida:', sessionName);
    } catch (error) {
        console.error('❌ Error obteniendo sesión:', error);
        sessionName = 'default_session';
    }

    const postData = {
        action: 'registerGameStart',
        username: userName,
        gameMode: 'crucigrama_frutas',
        timestamp: new Date().toISOString(),
        sessionName: sessionName
    };

    console.log('📤 Enviando datos de registro:', postData);

    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        
        const result = await response.json();
        console.log('📨 Respuesta del servidor:', result);
        
        if (result.success) {
            console.log('✅ Registro de inicio exitoso');
            return true;
        } else {
            console.log('⚠️ Registro no exitoso:', result.error);
            return false;
        }
    } catch (error) {
        console.error('💥 Error de red registrando inicio de juego:', error);
        return false;
    }
}

// Agregar función para forzar inicio del polling

function forceStartAbandonPolling() {
    console.log('🔧 === FORZANDO INICIO DE POLLING ===');
    
    // Detener cualquier polling existente
    if (abandonWinnerPollingInterval) {
        clearInterval(abandonWinnerPollingInterval);
        console.log('🛑 Polling anterior detenido');
    }
    
    // Iniciar nuevo polling
    startAbandonWinnerPolling();
    
    // Verificar que se inició
    setTimeout(() => {
        if (abandonWinnerPollingInterval) {
            console.log('✅ Polling forzado exitoso');
            console.log('ID:', abandonWinnerPollingInterval);
        } else {
            console.log('❌ ERROR: Polling forzado falló');
        }
    }, 500);
}

// Para usar en la consola: forceStartAbandonPolling()

function stopAbandonWinnerPolling() {
    if (abandonWinnerPollingInterval) {
        clearInterval(abandonWinnerPollingInterval);
        abandonWinnerPollingInterval = null;
        console.log('⏹️ Polling de abandono detenido');
    }
}

// Reemplazar la función handleAbandonmentWin existente

// Reemplazar la función handleAbandonmentWin existente

// La función handleAbandonmentWin ya está correcta, pero confirmemos el flujo

// Modificar handleAbandonmentWin para mejor limpieza

function handleAbandonmentWin() {
    console.log('🎉 MANEJANDO VICTORIA POR ABANDONO - Limpieza completa');
    
    // Verificar duplicados
    if (window.victoryShown) {
        console.log('⚠️ Victoria ya mostrada, ignorando');
        return;
    }
    
    // Marcar que ya se mostró la victoria
    window.victoryShown = true;
    
    // DETENER Y OCULTAR TODO
    stopAbandonWinnerPolling();
    stopGameInitializationAndHide();
    ocultarMainContent();
    hideLottieAnimation();
    
    if (winnerPollingInterval) {
        clearInterval(winnerPollingInterval);
        winnerPollingInterval = null;
    }
    
    stopTimer();
    stopRankingUpdates();
    
    // EFECTOS DE VICTORIA
    playWinnerSound();
    launchConfetti();
    
    // MENSAJE DE VICTORIA POR ABANDONO
    Swal.fire({
        title: '¡Eres el GANADOR! 🏆',
        html: `
            <div style="text-align: center; margin: 15px 0;">
                <p style="font-size: 18px; color: #059669; margin-bottom: 10px;">
                    🏃‍♂️ Tu rival abandonó la partida
                </p>
                <p style="font-size: 16px; color: #4b5563;">
                    ¡Felicidades, eres el ganador!
                </p>
            </div>
        `,
        icon: 'success',
        confirmButtonText: 'Aceptar',
        allowOutsideClick: false,
        allowEscapeKey: false
    }).then(() => {
        const userName = getUserName();
        console.log('👤 Usuario ganador por abandono confirmó salir');
        
        // 🆕 LIMPIAR TODO INMEDIATAMENTE AL CONFIRMAR
        if (userName && userName !== 'Invitado') {
            Promise.all([
                // Limpiar estado temporal (GANADOR)
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearWinnerStatus',
                        username: userName
                    })
                }),
                // Limpiar sesión
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearUserSession',
                        username: userName
                    })
                }),
                // Limpiar ganador permanente
                fetch(scriptURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearPermanentWinner'
                    })
                })
            ]).then(() => {
                console.log('✅ Limpieza completa realizada para ganador por abandono');
            }).catch(error => {
                console.error('❌ Error en limpieza completa:', error);
            });
        }
        
        // SALIR DESPUÉS DE UN PEQUEÑO DELAY
        setTimeout(() => {
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
            } else {
                window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
            }
        }, 500);
    });
}
// Función de debug para simular abandono de rival
async function debugSimulateRivalAbandonment() {
    console.log('🧪 === SIMULANDO ABANDONO DE RIVAL ===');
    
    const userName = getUserName();
    console.log('Usuario actual:', userName);
    
    if (!userName || userName === 'Invitado') {
        console.log('❌ No se puede simular - usuario no válido');
        return;
    }
    
    // Simular que otro usuario abandona
    const fakeRivalName = 'RivalSimulado';
    
    try {
        console.log(`🚪 Simulando abandono de: ${fakeRivalName}`);
        
        // Enviar clearUserSession para el rival simulado
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearUserSession',
                username: fakeRivalName
            })
        });
        
        console.log('📤 Abandono simulado enviado');
        
        // Esperar un poco y verificar si el usuario actual se convirtió en ganador
        setTimeout(async () => {
            console.log('🔍 Verificando si el usuario se convirtió en ganador...');
            
            const checkResponse = await fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'getScoreStatusAndRank',
                    username: userName
                })
            });
            
            const data = await checkResponse.json();
            console.log('📊 Estado después del abandono simulado:', data);
            
            if (data.completed === 'GANADOR') {
                console.log('🏆 ¡Usuario se convirtió en ganador por abandono!');
            } else {
                console.log('ℹ️ Usuario no se convirtió en ganador');
            }
        }, 2000);
        
    } catch (error) {
        console.error('❌ Error en simulación:', error);
    }
    
    console.log('🧪 === FIN SIMULACIÓN ===');
}

// Agregar esta función para verificar el estado del polling

function checkAbandonPollingStatus() {
    console.log('🔍 === ESTADO DEL POLLING DE ABANDONO ===');
    console.log('Polling activo:', abandonWinnerPollingInterval !== null);
    console.log('ID del intervalo:', abandonWinnerPollingInterval);
    console.log('Tiempo de inicio del juego:', window.gameStartTime ? new Date(window.gameStartTime).toLocaleTimeString() : 'No definido');
    console.log('Estados del juego:');
    console.log('  - victoryShown:', window.victoryShown);
    console.log('  - defeatShown:', window.defeatShown);
    console.log('  - gameInitializationStopped:', gameInitializationStopped);
    console.log('Usuario actual:', getUserName());
    console.log('🔍 === FIN ESTADO ===');
}

// Agregar esta nueva función después de las funciones existentes:

// 🆕 LIMPIEZA FORZADA PERIÓDICA
let cleanupInterval = null;

function startPeriodicCleanup() {
    if (cleanupInterval) {
        clearInterval(cleanupInterval);
    }
    
    console.log('🧹 Iniciando limpieza periódica cada 30 segundos');
    
    cleanupInterval = setInterval(() => {
        const userName = getUserName();
        
        if (userName && userName !== 'Invitado') {
            console.log('🧹 Limpieza periódica para:', userName);
            
            // Verificar estado actual
            fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'getScoreStatusAndRank',
                    username: userName
                })
            }).then(response => response.json())
            .then(data => {
                // Si el usuario tiene estado PERDEDOR o ABANDONADO, limpiar
                if (data.completed === 'PERDEDOR' || data.completed === 'ABANDONADO') {
                    console.log(`🧹 Limpiando estado ${data.completed} para ${userName}`);
                    
                    fetch(scriptURL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'text/plain' },
                        body: JSON.stringify({
                            action: 'clearWinnerStatus',
                            username: userName
                        })
                    });
                }
            }).catch(error => {
                console.error('Error en limpieza periódica:', error);
            });
        }
    }, 30000); // Cada 30 segundos
}

function stopPeriodicCleanup() {
    if (cleanupInterval) {
        clearInterval(cleanupInterval);
        cleanupInterval = null;
        console.log('🛑 Limpieza periódica detenida');
    }
}

// Agregar función de prueba:

async function testForcedCleanup() {
    console.log('🧪 === PROBANDO LIMPIEZA FORZADA ===');
    
    const userName = getUserName();
    console.log('Usuario:', userName);
    
    if (!userName || userName === 'Invitado') {
        console.log('❌ Usuario no válido para prueba');
        return;
    }
    
    console.log('1. Verificando estado actual...');
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'getScoreStatusAndRank',
                username: userName
            })
        });
        
        const data = await response.json();
        console.log('Estado actual:', data.completed);
        
        console.log('2. Forzando limpieza...');
        await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify({
                action: 'clearWinnerStatus',
                username: userName
            })
        });
        
        console.log('3. Verificando después de limpieza...');
        setTimeout(async () => {
            const response2 = await fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify({
                    action: 'getScoreStatusAndRank',
                    username: userName
                })
            });
            
            const data2 = await response2.json();
            console.log('Estado después de limpieza:', data2.completed);
            
            if (data2.completed === '' || data2.completed === null) {
                console.log('✅ Limpieza exitosa');
            } else {
                console.log('❌ Limpieza falló');
            }
        }, 2000);
        
    } catch (error) {
        console.error('Error en prueba:', error);
    }
    
    console.log('🧪 === FIN PRUEBA ===');
}

function handleWinnerDetected() {
    // 1. Tapar el contenido y desactivar controles
    ocultarMainContent(); // Oculta el crucigrama y controles
    hideLottieAnimation();
    if (winnerPollingInterval) clearInterval(winnerPollingInterval);
    stopTimer();
    stopRankingUpdates();
    stopAllAudio();
    disableVirtualKeyboard(); // Si tienes una función para esto

    // 2. Mostrar el popup de ganador
    Swal.fire({
        title: '¡Eres el GANADOR! 🏆',
        html: `<div style="text-align: center; margin: 15px 0;">
                <p style="font-size: 18px; color: #059669; margin-bottom: 10px;">
                    ¡Felicidades, completaste el crucigrama!
                </p>
                <p style="font-size: 16px; color: #4b5563;">
                    Espera a la próxima partida para volver a jugar.
                </p>
            </div>`,
        icon: 'success',
        confirmButtonText: 'Aceptar',
        allowOutsideClick: false,
        allowEscapeKey: false
    }).then(() => {
        // Aquí puedes limpiar estado y redirigir si hace falta
        salirDelJuego();
    });
}

// ...dentro de showWelcomeDialog, justo antes de initializeGame()...

async function checkIfUserIsBlocked() {
    const userData = getUserData();
    const userName = userData.username;
    if (!userName || userName === 'Invitado') return false;

    // Obtener el nombre de la sesión actual
    let sessionName;
    try {
        sessionName = await getSessionNameFromServer();
    } catch (e) {
        sessionName = document.title + "_1";
    }

    // Consultar al backend si el usuario está bloqueado de esta sesión
    const response = await fetch(scriptURL, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: JSON.stringify({
            action: 'checkCanJoinSession',
            username: userName,
            sessionName: sessionName
        })
    });
    const data = await response.json();
    if (data && data.canJoin === false) {
        // Mostrar mensaje y bloquear acceso
        Swal.fire({
            title: 'Acceso bloqueado',
            html: `
                <div style="text-align:center;">
                    <p style="font-size:18px;color:#dc2626;">Ya has abandonado esta partida.</p>
                    <p style="font-size:16px;color:#4b5563;">No puedes volver a jugar hasta que termine el juego actual.</p>
                </div>
            `,
            icon: 'error',
            confirmButtonText: 'Salir',
            allowOutsideClick: false,
            allowEscapeKey: false
        }).then(() => {
            cerrarIframeYSalir();
        });
        return true; // Está bloqueado
    }
    return false; // No está bloqueado
}
    </script>
</body>
</html>
