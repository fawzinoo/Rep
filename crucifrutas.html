<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Frutas</title>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>  
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #6366f1, #a5b4fc);
            min-height: 100vh;
            
        }

       .header {
            background-color: #4338ca;
            color: white;
            padding: 10px 15px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
      .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

          .timer-mini {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .timer-mini.warning {
            background-color: #f59e0b;
            border-color: #f59e0b;
            animation: pulse 1s infinite;
        }

/* ESTILOS PARA EL CONTADOR DE PUNTOS FIJO */
          .score-display-fixed {
            position: fixed; /* Esto lo fija en la pantalla */
            top: 70px;       /* Ajusta según la posición vertical deseada */
            left: -8px;     /* Pegado a la derecha con un pequeño margen */
            z-index: 100;    /* Para que esté por encima de otros elementos */
            background-color: rgba(255, 255, 255, 5); /* MISMO COLOR QUE .timer-mini */
            color: black;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3); /* MISMO BORDE QUE .timer-mini */
        }
        .score-icon {
            font-size: 12px;
        }
               @keyframes scorePulseAnimation {
            0% {
                transform: scale(1);
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.5); /* Sombra amarilla suave */
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 0 15px rgba(255, 255, 0, 0.8); /* Sombra amarilla más intensa */
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
            }
        }

        .score-display-fixed.animate-score {
            animation: scorePulseAnimation 0.6s ease-in-out;
        }

.timer-mini-icon {
            font-size: 12px;
        }
.crossword-container {
    background-color: #e0f2fe;
    padding: 15px;
    border-radius: 10px;
    margin: 0 auto;
    max-width: 600px; /* Reducido de 800px a 600px para ver mejor la foto */
}

.grid-container {
    overflow-x: auto;
    overflow-y: auto; /* Cambiado de hidden a auto para permitir scroll vertical */
    padding: 15px;
    margin: 2px 0;
    border-radius: 8px;
    background-color: rgba(255, 255, 255, 0.1);
    max-height: 500px; /* Añadido límite de altura para activar scroll vertical */
    border: 2px solid rgba(255, 255, 255, 0.2); /* Borde sutil */
      scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE y Edge */
}

/* Personalizar la barra de scroll horizontal */
.grid-container::-webkit-scrollbar:horizontal {
    height: 10px;
}

.grid-container::-webkit-scrollbar-track:horizontal {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:horizontal {
    background: #4338ca;
    border-radius: 5px;
}

/* Personalizar la barra de scroll vertical */
.grid-container::-webkit-scrollbar:vertical {
    width: 10px;
}

.grid-container::-webkit-scrollbar-track:vertical {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:vertical {
    background: #4338ca;
    border-radius: 5px;
}

.grid-container::-webkit-scrollbar-thumb:hover {
    background: #3730a3;
}

/* Esquina del scroll */
.grid-container::-webkit-scrollbar-corner {
    background: rgba(0, 0, 0, 0.1);
}

        .fruit-display {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #4338ca;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            gap: 20px;
        }

       .fruit-image {
            width: 100px;
            height: 100px;
            border-radius: 10px;
            object-fit: cover;
            border: 3px solid white;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

 .fruit-image:hover {
            transform: scale(1.05);
        }

          .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }
        
         .modal-image {
            max-width: 90%;
            max-height: 90%;
            border-radius: 15px;
            border: 5px solid white;
            object-fit: contain;
            animation: zoomIn 0.3s ease;
        }

            @keyframes zoomIn {
            from {
                transform: scale(0.3);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
        }

        .close-modal:hover {
            color: #ff6b6b;
        }

        .zoom-hint {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            pointer-events: none;
        }

        .fruit-info {
            text-align: center;
        }

        .fruit-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .fruit-instruction {
            font-size: 16px;
            opacity: 0.9;
        }

.grid {
    display: grid;
    grid-template-columns: repeat(18, 45px); /* Cambiado de 40px a 45px */
    grid-template-rows: repeat(19, 45px); /* Cambiado de 40px a 45px */
    gap: 0;
    margin: 0;
    justify-content: start;
    min-width: calc(18 * 45px + 34px); /* Actualizado el cálculo */
    min-height: calc(19 * 45px + 36px); /* Actualizado el cálculo */
}

.cell {
    width: 45px; /* Cambiado de 40px a 45px */
    height: 45px; /* Cambiado de 40px a 45px */
    border: 1px solid #333;
    text-align: center;
    font-weight: 600;
    font-size: 20px; /* Aumentado de 18px a 20px */
    font-family: 'Georgia', 'Times New Roman', serif;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    letter-spacing: 0.5px;
}


       .white {
    background-color: #f8fafc;
}

        .green {
            background-color: #86efac;
            border: 1px solid #22c55e;
        }

        .blue {
            background-color: #93c5fd;
        }

        .blocked {
            background-color: #64748b;
        }

        .filled {
            background-color: #f3f4f6;
            color: #374151;
            font-weight: bold;
        }


input[type="text"] {
    width: 100%;
    height: 100%;
    border: none;
    text-align: center;
    font-weight: 600;
    font-size: 20px; /* Aumentado de 18px a 20px */
    font-family: 'Georgia', 'Times New Roman', serif;
    background: transparent;
    text-transform: uppercase;
    letter-spacing: 1px;
    caret-color: transparent;
    cursor: default;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
    inputmode: none;
}

input[type="text"]:focus {
    outline: none;
    box-shadow: 0 0 0 2px #4338ca;
}

        .green input[type="text"] {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .correct {
            background-color: #f3f70f !important;
            color: white;
        }

  @media (max-width: 1024px) {

 
    .grid-container {
        max-height: 600px; /* Reducido para tablets */
         margin: 0 auto;
        padding: 1px;
        justify-content: center;
        text-align: center;
    }
    
    .grid {
        grid-template-columns: repeat(18, 40px); /* Cambiado de 35px a 40px */
        grid-template-rows: repeat(19, 40px); /* Cambiado de 35px a 40px */
        gap: 0;
        min-width: calc(18 * 40px + 17px);
        min-height: calc(19 * 40px + 18px);
    }
    
    
      .cell {
        width: 40px; /* Cambiado de 35px a 40px */
        height: 40px; /* Cambiado de 35px a 40px */
        font-size: 19px; /* Cambiado de 17px a 19px */
        font-family: 'Georgia', 'Times New Roman', serif;
    }
    
     input[type="text"] {
        font-size: 19px; /* Cambiado de 17px a 19px */
        font-family: 'Georgia', 'Times New Roman', serif;
    }
     body {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
    }
       .header {
        width: 92%;

        max-width: 600px; /* Que coincida con el contenedor del crucigrama */
    }
    .crossword-container {
    background-color: #e0f2fe;
    padding: 15px;
    border-radius: 10px;
    margin: 0 auto; /* Esto ya está bien */
    max-width: 600px;
    width: 100%; /* Añadir para que ocupe el ancho disponible */
}
}
@media (max-width: 768px) {

      input[type="text"] {
        font-size: 12px;
        /* Forzar que no aparezca el teclado en móviles */
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    /* Asegurar que el teclado virtual sea más prominente en móvil */
    .virtual-keyboard {
        position: sticky;
        bottom: 0;
        z-index: 100;
        background-color: #2d3748;
        border-top: 3px solid #4338ca;
    }

    body {
        padding: 0;
    }
    
    .crossword-container {
        padding: 1px;
        max-width: 100%;
    }

    .header-right {
        gap: 5px;
    }

    .timer-mini {
        font-size: 10px;
        padding: 3px 6px;
    }

    .grid-container {
        margin: 1px 0;
        padding: 1px;
        max-height: 350px; /* Reducido para móviles */
    }

     .grid {
        grid-template-columns: repeat(18, 32px); /* Cambiado de 28px a 32px */
        grid-template-rows: repeat(19, 32px); /* Cambiado de 28px a 32px */
        gap: 0;
        min-width: calc(18 * 32px + 17px);
        min-height: calc(19 * 32px + 18px);
    }
    
     .cell {
        width: 32px; /* Cambiado de 28px a 32px */
        height: 32px; /* Cambiado de 28px a 32px */
        font-size: 18px; /* Cambiado de 16px a 18px */
        font-family: 'Georgia', 'Times New Roman', serif;
        letter-spacing: 0.3px;
    }
    
    input[type="text"] {
        font-size: 18px; /* Cambiado de 16px a 18px */
        font-family: 'Georgia', 'Times New Roman', serif;
        letter-spacing: 0.8px;
    }
    
    .fruit-display {
        flex-direction: column;
        gap: 10px;
        padding: 15px;
    }
    
    .fruit-image {
        width: 80px;
        height: 80px;
    }

    .modal-image {
        max-width: 95%;
        max-height: 95%;
    }

    .close-modal {
        top: 10px;
        right: 15px;
        font-size: 30px;
    }
    
    .fruit-name {
        font-size: 20px;
    }

    /* Barras de scroll más delgadas en móvil */
    .grid-container::-webkit-scrollbar:horizontal {
        height: 8px;
    }
    
    .grid-container::-webkit-scrollbar:vertical {
        width: 8px;
    }
}
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .timer-icon {
            font-size: 20px;
        }



/* Teclado Virtual */
.virtual-keyboard {
    background-color: #2d3748;
    padding: 5px 0; /* Cambiado de "padding: 5px;" a "padding: 5px 0;" para quitar padding lateral */
    border-radius: 0; /* Cambiado de "border-radius: 15px;" a "border-radius: 0;" */
    margin: 0;
    max-width: 100%;
    width: 100%;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    border: none; /* Cambiado de "border: 2px solid #4a5568;" a "border: none;" */
    border-top: 2px solid #4a5568; /* Solo borde superior */
}

.keyboard-row {
    display: flex;
    justify-content: center;
    gap:2px;
    margin-bottom: 2px;
}

.keyboard-row:last-child {
    margin-bottom: 0;
}

.key {
    background: linear-gradient(145deg, #4a5568, #2d3748);
    color: white;
    border: 2px solid #4a5568;
    border-radius: 8px;
    width: 70px;
    height: 70px;
    font-size: 24px; /* Cambiado de 20px a 24px */
    font-weight: 500; /* Mantener elegante */
    font-family: 'Georgia', 'Times New Roman', serif; /* Fuente elegante */
    cursor: pointer;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    text-transform: lowercase;
    user-select: none;
    letter-spacing: 0.5px; /* Espaciado elegante */
}

.key:hover {
    background: linear-gradient(145deg, #5a6478, #3d4758);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

.key:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    background: linear-gradient(145deg, #3d4758, #2d3748);
}

.key.special {
    background: linear-gradient(145deg, #6366f1, #4338ca);
    border-color: #4338ca;
    font-size: 24px; /* Cambiado de 20px a 24px */
    font-family: 'Georgia', 'Times New Roman', serif; /* Fuente elegante */
}

.key.special:hover {
    background: linear-gradient(145deg, #7c3aed, #5b21b6);
}

.key.backspace {
    width: 60px;
}

/* Responsive para teclado */
@media (max-width: 768px) {
     body {
        padding: 0; /* Cambiado de "padding: 5px;" a "padding: 0;" */
        
    }
     .keyboard-selection-popup {
        width: 90% !important;
        margin: 0 auto !important;
    }
    
    .keyboard-selection-popup .swal2-title {
        font-size: 1.5rem !important;
    }
    
    .keyboard-selection-popup .swal2-content {
        font-size: 1rem !important;
    }
  .virtual-keyboard {
        max-width: 100%;
        padding: 2px;
        margin-bottom: 10px;
    }
    
    .keyboard-row {
        gap: 2px;
        margin-bottom: 2px;
    }
    
    .key {
        width: 60px;
        height: 60px;
        font-size: 20px; /* Cambiado de 18px a 20px */
        font-family: 'Georgia', 'Times New Roman', serif;
    }
    
    .key.backspace {
        width: 65px;
    }
    .cell {
        width: 28px;
        height: 28px;
        font-size: 16px; /* Cambiado de 12px a 16px */
        font-family: 'Georgia', 'Times New Roman', serif;
        letter-spacing: 0.3px;
    }
    
    input[type="text"] {
        font-size: 16px; /* Cambiado de 12px a 16px */
        font-family: 'Georgia', 'Times New Roman', serif;
        letter-spacing: 0.8px;
    } 
    
}

@media (max-width: 480px) {
    
  .key {
        width: 45px;
        height: 45px;
        font-size: 16px; /* Cambiado de 14px a 16px */
        font-family: 'Georgia', 'Times New Roman', serif;
    }
    
    .key.backspace {
        width: 55px;
    }
}

/* ...existing code... */     
        /* Añadir este estilo para la clase separator */
.separator {
    background-color: #1f2937 !important;
    color: white !important;
    border: 3px solid #374151 !important;
}
.keyboard-selection-popup {
    border-radius: 15px !important;
    font-family: Arial, sans-serif !important;
}

.keyboard-selection-popup .swal2-title {
    color: #1f2937 !important;
    font-weight: bold !important;
}

.keyboard-selection-popup .swal2-content {
    color: #4b5563 !important;
}
.cell.black {
    background-color: rgba(0, 0, 0, 0.1); /* Ligeramente transparente */
    border: 1px solid rgba(255, 255, 255, 0.1); /* Borde muy sutil */
}

.ranking-container {
    width: 120px;
    height: 100px;

    background: linear-gradient(145deg, #ffffff, #f8fafc);
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 2px solid rgba(67, 56, 202, 0.2);
    overflow: hidden;
    font-family: 'Georgia', 'Times New Roman', serif;
    
}

.ranking-header {
    background: linear-gradient(145deg, #4338ca, #6366f1);
    color: white;
    padding: 1px 1px;
    text-align: center;
    font-size: 12px;
    font-weight: bold;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.ranking-list {
    max-height: 250px;
    overflow-y: auto;
    padding: 0;
    margin: 0;
}

.ranking-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 10px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    font-size: 11px;
    transition: background-color 0.2s ease;
}

.ranking-item:hover {
    background-color: rgba(67, 56, 202, 0.1);
}

.ranking-item:last-child {
    border-bottom: none;
}

.ranking-position {
    font-weight: bold;
    color: #4338ca;
    min-width: 20px;
}

.ranking-user {
    flex: 1;
    margin: 0 6px;
    font-weight: 500;
    color: #1f2937;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.ranking-score {
    font-weight: bold;
    color: #059669;
    font-size: 10px;
}

.ranking-item.current-user {
    background-color: rgba(251, 191, 36, 0.2);
    border-left: 3px solid #f59e0b;
}

.ranking-empty {
    text-align: center;
    padding: 20px;
    color: #6b7280;
    font-size: 11px;
    font-style: italic;
}

.ranking-update {
    text-align: center;
    padding: 4px;
    font-size: 9px;
    color: #6b7280;
    background-color: rgba(0, 0, 0, 0.02);
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}

/* ...existing code... */

/* Estilos para el diálogo de bienvenida */
.welcome-dialog-popup {
    border-radius: 15px !important;
    font-family: Arial, sans-serif !important;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3) !important;
}

.welcome-dialog-title {
    color: #1f2937 !important;
    font-weight: bold !important;
    font-size: 1.8rem !important;
}

.welcome-dialog-content {
    color: #4b5563 !important;
    font-size: 1.1rem !important;
}

/* Responsive para el diálogo de bienvenida */
@media (max-width: 768px) {
    .welcome-dialog-popup {
        width: 90% !important;
        margin: 0 auto !important;
    }
    
    .welcome-dialog-title {
        font-size: 1.5rem !important;
    }
    
    .welcome-dialog-content {
        font-size: 1rem !important;
    }
}


    </style>
</head>
<body>
   <div class="header">
    <span>←</span>
    <span style="font-size: 24px; font-weight: bold;">Crucigrama</span>
    <div class="header-right">
        <div id="timerMini" class="timer-mini">
            <span class="timer-mini-icon">⏰</span>
            <span id="timerDisplay">30</span>
        </div>
        
        <span>🍎 Frutas</span>
    </div>
</div>
 <div id="scoreDisplayContainer" class="score-display-fixed"> 
            <span class="score-icon">⭐</span>
            <span id="scorePoints">0</span>
        </div>
<div class="crossword-container">
    <div class="fruit-display" id="fruitDisplay">

 <span style="display: flex; justify-content: center; align-items: center; width: 100%; position: relative;">
    <!-- fruitImage container, will be centered by the span's flex properties -->
    <div style="position: relative;"> <!-- This div wraps the image and its zoom hint -->
        <img id="fruitImage" class="fruit-image" src="" alt="Fruta" onclick="openImageModal()">
        <div class="zoom-hint">🔍</div>
    </div>

    <!-- rankingContainer, positioned absolutely to the right of the span -->
    <div id="rankingContainer" class="ranking-container"
         style="position: absolute; right: 0px; top: 50%; transform: translateY(-50%);">
      <div class="ranking-header">
        🏆 Ranking
       </div>
      <div id="rankingList" class="ranking-list">
       <div class="ranking-empty">Cargando...</div>
      </div>

       </div>
    </span>

    
    </div>
    
    <!-- Nuevo contenedor con scroll horizontal -->
    <div class="grid-container">
        <div class="grid" id="crossword">
            <!-- La cuadrícula se generará con JavaScript -->
        </div>
    </div>
</div>

<div class="virtual-keyboard">
    
</div>

<!-- Modal para imagen ampliada -->
<div id="imageModal" class="image-modal" onclick="closeImageModal()">
    <span class="close-modal" onclick="closeImageModal()">&times;</span>
    <img id="modalImage" class="modal-image" src="" alt="Fruta ampliada">
</div>

<div id="welcomeBackdrop" style="
  position:fixed;
  top:0; left:0; width:100vw; height:100vh;
  background: #e0f2fe;
  z-index: 9998;
  display: none;
"></div>

 <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
 <audio id="button-sound" src="https://www.myinstants.com/media/sounds/geometry-dash-click-sound.mp3"></audio>
<script>
  const sound = document.getElementById('button-sound');

  document.addEventListener('click', function(e) {
    // Excluir botones del teclado de crucigrama
    if (e.target.classList.contains('teclado-crucigrama') || 
        e.target.closest('.teclado-crucigrama')) {
      return;
    }

    // Excluir tecla ESC/borrar (por contenido o clase)
    if (e.target.textContent.trim() === 'ESC' ||
        e.target.textContent.trim() === '⌫' ||
        e.target.classList.contains('tecla-borrar') ||
        e.target.classList.contains('tecla-esc')) {
      return;
    }

    // Excluir botones que contienen una sola letra (si no tienes clases específicas)
    if (e.target.tagName === 'BUTTON' && 
        e.target.textContent.length === 1 && 
        /^[A-Za-z]$/.test(e.target.textContent)) {
      return;
    }

    // Resto de botones (normales y SweetAlert2)
    if (
      e.target.tagName === 'BUTTON' ||
      e.target.classList.contains('swal2-confirm') ||
      e.target.classList.contains('swal2-cancel') ||
      e.target.classList.contains('swal2-deny')
    ) {
      sound.currentTime = 0;
      sound.play();
    }
  });


  window.onload = function() {
      history.pushState(null, '', location.href);
    };
    window.addEventListener('popstate', function() {
      window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
    });








    const scriptURL = 'https://script.google.com/macros/s/AKfycbzpq0DqXykaOjqbOjbSonvhHXc2xpTOsVgH4CInnyf6Vt4gyMd3eFfsAHIJ5CbCuJAmnA/exec';
let hasShownAutoWinner = false;
    let hasShownLoserMessage = false;
    let isAbandoning = false;

    async function getSessionNameFromServer() {
    const sessionBaseName = document.title;
    const scriptURL = 'TU_SCRIPT_URL'; // Cambia por tu URL real
    const postData = {
        action: 'getOrCreateSession',
        sessionBaseName: sessionBaseName
    };
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        const data = await response.json();
        return data.sessionName; // Ejemplo: "Frutas_1"
    } catch (e) {
        console.error('Error obteniendo nombre de sesión:', e);
        return sessionBaseName + "_1"; // fallback
    }
}

function launchConfetti() {
    if (typeof confetti === 'function') {
        confetti({
            particleCount: 180,
            spread: 100,
            origin: { y: 0.6 },
            zIndex: 9999
        });
        setTimeout(() => { // Un segundo estallido
             confetti({ particleCount: 100, spread: 120, origin: { y: 0.5 }, angle: 60, zIndex: 9999});
             confetti({ particleCount: 100, spread: 120, origin: { y: 0.5 }, angle: 120, zIndex: 9999});
        }, 250);
    } else {
        console.warn('Confetti no está definido.');
    }
}



// Añadir esta función después de la función resetGame()
// ...existing code...
function showAllFruits() {
    console.log('Mostrando todas las frutas en el crucigrama...');
    
    const grid = document.getElementById('crossword');
    grid.innerHTML = '';
    
    // CORREGIR: Usar las mismas dimensiones
    const gridRows = 19;
    const gridCols = 18;
    const gridData = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
    
    // Marcar todas las posiciones de frutas
    fruits.forEach(fruit => {
        const pos = fruit.position;
        for (let i = 0; i < fruit.name.length; i++) {
            let row, col;
            if (pos.direction === 'horizontal') {
                row = pos.row;
                col = pos.col + i;
            } else {
                row = pos.row + i;
                col = pos.col;
            }
            
            // CORREGIR: Usar gridRows y gridCols
            if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                gridData[row][col] = {
                    type: 'white',
                    letter: fruit.name[i],
                    fruitName: fruit.name,
                    number: fruit.number
                };
            }
        }
    });
    
    // Crear el grid HTML - CORREGIR: Usar gridRows y gridCols
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const cell = document.createElement('div');
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (gridData[row][col] && gridData[row][col].type === 'white') {
                // Casilla blanca con letra
                 cell.className = 'cell white';
                cell.style.backgroundColor = 'transparent';
                cell.textContent = gridData[row][col].letter;
                cell.style.backgroundColor = '#c8e6c9';
                cell.style.color = '#1f2937';
                
                // Agregar números si es la primera casilla de una palabra
                fruits.forEach(fruit => {
                    if (fruit.position.row === row && fruit.position.col === col) {
                        const numberSpan = document.createElement('span');
                        numberSpan.textContent = fruit.number;
                        numberSpan.style.position = 'absolute';
                        numberSpan.style.top = '2px';
                        numberSpan.style.left = '2px';
                        numberSpan.style.fontSize = '8px';
                        numberSpan.style.fontWeight = 'bold';
                        numberSpan.style.color = '#000';
                        numberSpan.style.zIndex = '10';
                        cell.appendChild(numberSpan);
                    }
                });
} else {
    cell.className = 'cell white';
    cell.style.backgroundColor = 'transparent'; // Cambiado de '#000' a 'transparent'
}
            
            grid.appendChild(cell);
        }
    }
    
    console.log('Todas las frutas mostradas en el crucigrama');
}

// Función para volver al modo de juego normal
function returnToGame() {
    console.log('Regresando al modo de juego normal...');
    updateFruitDisplay();
    generateGrid();
    
    // Solo reiniciar timer si no hay uno activo
    if (!timer) {
        startTimer();
    }
}

// Función para mostrar estadísticas de las frutas
function showFruitsStats() {
    console.log('=== ESTADÍSTICAS DE FRUTAS ===');
    
    const horizontalFruits = fruits.filter(f => f.position.direction === 'horizontal');
    const verticalFruits = fruits.filter(f => f.position.direction === 'vertical');
    const fruitsWithSpaces = fruits.filter(f => f.name.includes(' '));
    
    console.log(`Total de frutas: ${fruits.length}`);
    console.log(`Horizontales: ${horizontalFruits.length}`);
    console.log(`Verticales: ${verticalFruits.length}`);
    console.log(`Con espacios: ${fruitsWithSpaces.length}`);
    
    console.log('\n=== FRUTAS HORIZONTALES ===');
    horizontalFruits.forEach((fruit, i) => {
        console.log(`${i+1}. ${fruit.name} - Fila ${fruit.position.row}, Col ${fruit.position.col}`);
    });
    
    console.log('\n=== FRUTAS VERTICALES ===');
    verticalFruits.forEach((fruit, i) => {
        console.log(`${i+1}. ${fruit.name} - Fila ${fruit.position.row}, Col ${fruit.position.col}`);
    });
    
    if (fruitsWithSpaces.length > 0) {
        console.log('\n=== FRUTAS CON ESPACIOS ===');
        fruitsWithSpaces.forEach(fruit => {
            console.log(`- ${fruit.name}`);
        });
    }
}

// Función para verificar intersecciones entre frutas
function checkIntersections() {
    console.log('=== VERIFICANDO INTERSECCIONES ===');
    
    const intersections = [];
    
    for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
            const fruit1 = fruits[i];
            const fruit2 = fruits[j];
            
            // Solo verificar si tienen direcciones diferentes
            if (fruit1.position.direction !== fruit2.position.direction) {
                const intersection = findIntersection(fruit1, fruit2);
                if (intersection) {
                    intersections.push({
                        fruit1: fruit1.name,
                        fruit2: fruit2.name,
                        position: intersection.position,
                        letter: intersection.letter
                    });
                }
            }
        }
    }
    
    console.log(`Total de intersecciones encontradas: ${intersections.length}`);
    intersections.forEach(int => {
        console.log(`${int.fruit1} ∩ ${int.fruit2} = "${int.letter}" en (${int.position.row}, ${int.position.col})`);
    });
    
    return intersections;
}

// Función auxiliar para encontrar intersección entre dos frutas
function findIntersection(fruit1, fruit2) {
    const pos1 = fruit1.position;
    const pos2 = fruit2.position;
    
    for (let i = 0; i < fruit1.name.length; i++) {
        for (let j = 0; j < fruit2.name.length; j++) {
            let row1, col1, row2, col2;
            
            if (pos1.direction === 'horizontal') {
                row1 = pos1.row;
                col1 = pos1.col + i;
            } else {
                row1 = pos1.row + i;
                col1 = pos1.col;
            }
            
            if (pos2.direction === 'horizontal') {
                row2 = pos2.row;
                col2 = pos2.col + j;
            } else {
                row2 = pos2.row + j;
                col2 = pos2.col;
            }
            
            // Si las posiciones coinciden y las letras son iguales
            if (row1 === row2 && col1 === col2 && fruit1.name[i] === fruit2.name[j]) {
                return {
                    position: { row: row1, col: col1 },
                    letter: fruit1.name[i]
                };
            }
        }
    }
    
    return null;
}

const fruits = [
    // Palabras Horizontales (14 palabras)
    {
        name: 'NECTARINA',
        image: 'https://fawzinoo.github.io/Fotos/nectarina.png',
        audio: 'https://fawzinoo.github.io/audios/La nectarina.mp3',
        position: { row: 0, col: 0, direction: 'horizontal' },
        number: 1
    },
    {
        name: 'LIMON',
        image: 'https://fawzinoo.github.io/Fotos/limon.png',
        audio: 'https://fawzinoo.github.io/audios/El limon.mp3',
        position: { row: 0, col: 11, direction: 'horizontal' },
        number: 4
    },
    {
        name: 'SANDIA',
        image: 'https://fawzinoo.github.io/Fotos/sandía.png',
        audio: 'https://fawzinoo.github.io/audios/La sandia.mp3',
        position: { row: 2, col: 11, direction: 'horizontal' },
        number: 6
    },
    {
        name: 'UVA',
        image: 'https://fawzinoo.github.io/Fotos/uva.png',
        audio: 'https://fawzinoo.github.io/audios/Las uvas.mp3',
        position: { row: 3, col: 2, direction: 'horizontal' },
        number: 7
    },
    {
        name: 'CHIRIMOYA',
        image: 'https://fawzinoo.github.io/Fotos/chirimoya.png',
        audio: 'https://fawzinoo.github.io/audios/La chirimoya.mp3',
        position: { row: 4, col: 5, direction: 'horizontal' },
        number: 8
    },
    {
        name: 'KIWI',
        image: 'https://fawzinoo.github.io/Fotos/kiwi.png',
        audio: 'https://fawzinoo.github.io/audios/El kiwi.mp3',
        position: { row: 6, col: 12, direction: 'horizontal' },
        number: 11
    },
    {
        name: 'PERA',
        image: 'https://fawzinoo.github.io/Fotos/pera.png',
        audio: 'https://fawzinoo.github.io/audios/La pera.mp3',
        position: { row: 7, col: 2, direction: 'horizontal' },
        number: 12
    },
    {
        name: 'AGUACATE',
        image: 'https://fawzinoo.github.io/Fotos/aguacate.png',
        audio: 'https://fawzinoo.github.io/audios/El aguacate.mp3',
        position: { row: 8, col: 10, direction: 'horizontal' },
        number: 14
    },
    {
        name: 'FRAMBUESA',
        image: 'https://fawzinoo.github.io/Fotos/frambuesa.png',
        audio: 'https://fawzinoo.github.io/audios/La frambuesa.mp3',
        position: { row: 10, col: 2, direction: 'horizontal' },
        number: 16
    },
    {
        name: 'MANZANA',
        image: 'https://fawzinoo.github.io/Fotos/manzana.png',
        audio: 'https://fawzinoo.github.io/audios/La manzana.mp3',
        position: { row: 12, col: 4, direction: 'horizontal' },
        number: 17
    },
    {
        name: 'PLATANO',
        image: 'https://fawzinoo.github.io/Fotos/platano.png',
        audio: 'https://fawzinoo.github.io/audios/El platano.mp3',
        position: { row: 14, col: 10, direction: 'horizontal' },
        number: 21
    },
    {
        name: 'CEREZA',
        image: 'https://fawzinoo.github.io/Fotos/cereza.png',
        audio: 'https://fawzinoo.github.io/audios/La cereza.mp3',
        position: { row: 15, col: 1, direction: 'horizontal' },
        number: 22
    },
    {
        name: 'PAPAYA',
        image: 'https://fawzinoo.github.io/Fotos/papaya.png',
        audio: 'https://fawzinoo.github.io/audios/La papaya.mp3',
        position: { row: 18, col: 3, direction: 'horizontal' },
        number: 24
    },
    {
        name: 'MANGO',
        image: 'https://fawzinoo.github.io/Fotos/mango.png',
        audio: 'https://fawzinoo.github.io/audios/El mango.mp3',
        position: { row: 18, col: 12, direction: 'horizontal' },
        number: 25
    },

    // Palabras Verticales (11 palabras)
    {
        name: 'NARANJA',
        image: 'https://fawzinoo.github.io/Fotos/naranja.png',
        audio: 'https://fawzinoo.github.io/audios/La naranja.mp3',
        position: { row: 12, col: 6, direction: 'vertical' },
        number: 1
    },
    {
        name: 'CAQUI',
        image: 'https://fawzinoo.github.io/Fotos/caqui.png',
        audio: 'https://fawzinoo.github.io/audios/El Caqui.mp3',
        position: { row: 0, col: 2, direction: 'vertical' },
        number: 2
    },
    {
        name: 'ALBARICOQUE',
        image: 'https://fawzinoo.github.io/Fotos/albaricoque.png',
        audio: 'https://fawzinoo.github.io/audios/El albaricoque.mp3',
        position: { row: 0, col: 8, direction: 'vertical' },
        number: 3
    },
    {
        name: 'MANDARINA',
        image: 'https://fawzinoo.github.io/Fotos/mandarina.png',
        audio: 'https://fawzinoo.github.io/audios/La mandarina.mp3',
        position: { row: 0, col: 13, direction: 'vertical' },
        number: 5
    },
    {
        name: 'FRESA',
        image: 'https://fawzinoo.github.io/Fotos/fresa.png',
        audio: 'https://fawzinoo.github.io/audios/La fresa.mp3',
        position: { row: 6, col: 4, direction: 'vertical' },
        number: 9
    },
    {
        name: 'GRANADA',
        image: 'https://fawzinoo.github.io/Fotos/granada.png',
        audio: 'https://fawzinoo.github.io/audios/La granada.mp3',
        position: { row: 6, col: 10, direction: 'vertical' },
        number: 10
    },
    {
        name: 'MELON',
        image: 'https://fawzinoo.github.io/Fotos/melon.png',
        audio: 'https://fawzinoo.github.io/audios/El melon.mp3',
        position: { row: 7, col: 17, direction: 'vertical' },
        number: 13
    },
    
    {
        name: 'CIRUELA',
        image: 'https://fawzinoo.github.io/Fotos/ciruela.png',
        audio: 'https://fawzinoo.github.io/audios/La ciruela.mp3',
        position: { row: 8, col: 14, direction: 'vertical' },
        number: 18
    },
    {
        name: 'COCO',
        image: 'https://fawzinoo.github.io/Fotos/coco.png',
        audio: 'https://fawzinoo.github.io/audios/El coco.mp3',
        position: { row: 13, col: 1, direction: 'vertical' },
        number: 19
    },
    {
        name: 'POMELO',
        image: 'https://fawzinoo.github.io/Fotos/pomelo.png',
        audio: 'https://fawzinoo.github.io/audios/El pomelo.mp3',
        position: { row: 13, col: 16, direction: 'vertical' },
        number: 20
    },
    {
        name: 'PIÑA',
        image: 'https://fawzinoo.github.io/Fotos/piña.png',
        audio: 'https://fawzinoo.github.io/audios/La pina.mp3',
        position: { row: 15, col: 8, direction: 'vertical' },
        number: 23
    }
];


        let currentFruitIndex = 0;
        let currentFruit = fruits[currentFruitIndex];
        let completedFruits = new Set();
        let availableFruits = []; 
         let incompleteFruits = [];

                // Variables del timer
        let timer = null;
        let timeLeft = 20;
        let currentRound = 1;
        let totalRounds = 0;

   function playAudio(audioUrl) {
    try {
        // Detener cualquier audio previo que pueda estar reproduciéndose
        if (window.currentAudio) {
            window.currentAudio.pause();
            window.currentAudio.currentTime = 0;
        }
        
        const audio = new Audio(audioUrl);
        window.currentAudio = audio; // Guardar referencia global
        
        audio.volume = 0.6; // Reducir volumen para evitar saturación
        audio.preload = 'auto';
        
        // Manejar errores de carga
        audio.onerror = function() {
            console.log('Error al cargar el audio:', audioUrl);
            window.currentAudio = null;
        };
        
        // Limpiar referencia cuando termine
        audio.onended = function() {
            window.currentAudio = null;
        };
        
        // Reproducir cuando esté listo
        const playPromise = audio.play();
        
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log('Audio reproducido correctamente');
            }).catch(error => {
                console.log('Error al reproducir audio:', error);
                window.currentAudio = null;
            });
        }
        
    } catch (error) {
        console.log('Error creando objeto Audio:', error);
    }
}
function stopAllAudio() {
    // Detener audio de frutas
    if (window.currentAudio) {
        try {
            window.currentAudio.pause();
            window.currentAudio.currentTime = 0;
        } catch(e) {}
        window.currentAudio = null;
    }
    
    // Detener oscilador de éxito
    if (window.currentOscillator) {
        try {
            window.currentOscillator.stop();
            window.currentOscillator.disconnect();
        } catch(e) {}
        window.currentOscillator = null;
    }
}

// Añadir función para verificar elementos DOM
function verifyDOMElements() {
    const timerMini = document.getElementById('timerMini');
    const timerDisplay = document.getElementById('timerDisplay');
    
    console.log('Verificando elementos DOM:');
    console.log('timerMini:', timerMini ? 'OK' : 'NO ENCONTRADO');
    console.log('timerDisplay:', timerDisplay ? 'OK' : 'NO ENCONTRADO');
    
    return timerMini && timerDisplay;
}

        // Función para iniciar el timer
function startTimer() {
    console.log('Iniciando timer para:', currentFruit.name);

    // Limpiar timer anterior si existe
    if (timer) {
        clearInterval(timer);
        timer = null;
    }

    timeLeft = 20;
    updateTimerDisplay();

    timer = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        console.log(`Timer: ${timeLeft} segundos restantes para ${currentFruit.name}`);

        // Cambiar color cuando quedan 10 segundos
        const timerMini = document.getElementById('timerMini');
        if (timerMini) {
            if (timeLeft <= 10) {
                timerMini.classList.add('warning');
            } else {
                timerMini.classList.remove('warning');
            }
        }

        // Tiempo agotado
        if (timeLeft <= 0) {
            console.log('¡TIEMPO AGOTADO! Ejecutando timeout...');
            clearInterval(timer);
            timer = null;

            // Ejecutar inmediatamente sin setTimeout
            handleTimeOut();
        }
    }, 1000);

    console.log('Timer iniciado correctamente');
}
        // Función para actualizar la visualización del timer
function updateTimerDisplay() {
    const timerDisplay = document.getElementById('timerDisplay');
    if (timerDisplay) {
        timerDisplay.textContent = timeLeft;
    } else {
        console.error('Elemento timerDisplay no encontrado');
    }
}

function updateScoreDisplay() {
    const scorePointsElement = document.getElementById('scorePoints');
    if (scorePointsElement) {
        scorePointsElement.textContent = completedFruits.size; // Usamos el tamaño del Set de frutas completadas
    } else {
        console.error('Elemento scorePoints no encontrado');
    }
}

        // Función para detener el timer
  function stopTimer() {
    console.log('Deteniendo timer...');
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    
    const timerMini = document.getElementById('timerMini');
    if (timerMini) {
        timerMini.classList.remove('warning');
    }
    console.log('Timer detenido');
}




function initializeVirtualKeyboard() {
    console.log('=== INICIALIZANDO TECLADO VIRTUAL ===');
    
    loadKeyboardLayoutPreference();
    buildVirtualKeyboardHTML(currentKeyboardLayout);

    const keys = document.querySelectorAll('.virtual-keyboard .key');
    console.log('Teclas encontradas:', keys.length);
    
    const LONG_PRESS_DURATION = 600;
    let pressTimer = null;
    let isLongPress = false;

    keys.forEach((keyNode, index) => {
        const key = keyNode.cloneNode(true);
        keyNode.parentNode.replaceChild(key, keyNode);

        const keyChar = key.dataset.key;
        const action = key.dataset.action;
        
        console.log(`Tecla ${index}: char="${keyChar}", action="${action}"`);

        const handleStartPress = (event) => {
            event.preventDefault();
            playKeySound(keyChar || action);
            isLongPress = false;
            key.style.transform = 'translateY(2px)';
            
            console.log(`Tecla presionada: char="${keyChar}", action="${action}"`);

            if (action === 'backspace') {
                console.log('BACKSPACE detectado');
                processVirtualBackspace();
                return;
            }


   if (action === 'settings') {
    console.log('SETTINGS detectado - Mostrando SweetAlert');
    
    Swal.fire({
        title: '⚙️ Configuración del Teclado',
        html: `
            <div style="text-align: left; margin: 10px 0;">
                <h4 style="margin: 15px 0 10px 0; color: #1f2937;">Distribución del teclado:</h4>
                <label style="display: block; margin: 8px 0; cursor: pointer;">
                    <input type="radio" name="keyboard" value="qwerty" ${currentKeyboardLayout === 'qwerty' ? 'checked' : ''} style="margin-right: 8px;">
                    <strong>QWERTY</strong>
                </label>
                <label style="display: block; margin: 8px 0; cursor: pointer;">
                    <input type="radio" name="keyboard" value="azerty" ${currentKeyboardLayout === 'azerty' ? 'checked' : ''} style="margin-right: 8px;">
                    <strong>AZERTY</strong>
                </label>
                
                <h4 style="margin: 20px 0 10px 0; color: #1f2937;">Sonido del teclado:</h4>
                <label style="display: block; margin: 8px 0; cursor: pointer;">
                    <input type="radio" name="sound" value="enabled" ${keyboardSoundEnabled ? 'checked' : ''} style="margin-right: 8px;">
                    <span>🔊 <strong>Activado</strong></span>
                </label>
                <label style="display: block; margin: 8px 0; cursor: pointer;">
                    <input type="radio" name="sound" value="disabled" ${!keyboardSoundEnabled ? 'checked' : ''} style="margin-right: 8px;">
                    <span>🔇 <strong>Silenciado</strong></span>
                </label>
            </div>
        `,
        showCancelButton: true,
        confirmButtonText: 'Aplicar',
        cancelButtonText: 'Cancelar',
        confirmButtonColor: '#4338ca',
        cancelButtonColor: '#6b7280',
        background: '#f8fafc',
        customClass: {
            popup: 'keyboard-selection-popup'
        },
        preConfirm: () => {
            const selectedKeyboard = document.querySelector('input[name="keyboard"]:checked');
            const selectedSound = document.querySelector('input[name="sound"]:checked');
            
            return {
                keyboard: selectedKeyboard ? selectedKeyboard.value : null,
                sound: selectedSound ? selectedSound.value : null
            };
        }
}).then((result) => {
        if (result.isConfirmed && result.value) {
            const { keyboard, sound } = result.value;
            let hasChanges = false;
            
            // Verificar cambios en distribución del teclado
            if (keyboard && currentKeyboardLayout !== keyboard) {
                currentKeyboardLayout = keyboard;
                hasChanges = true;
            }
            
            // Verificar cambios en sonido
            if (sound) {
                const newSoundEnabled = sound === 'enabled';
                if (keyboardSoundEnabled !== newSoundEnabled) {
                    keyboardSoundEnabled = newSoundEnabled;
                    hasChanges = true;
                }
            }
            
            if (hasChanges) {
                saveKeyboardLayoutPreference();
                
                // Reconstruir teclado si cambió la distribución
                if (keyboard && currentKeyboardLayout === keyboard) {
                    initializeVirtualKeyboard();
                }
                
                // Mostrar confirmación
                const soundStatus = keyboardSoundEnabled ? 'activado' : 'silenciado';
                Swal.fire({
                    title: '✅ ¡Configuración aplicada!',
                    text: `Teclado: ${currentKeyboardLayout.toUpperCase()}, Sonido: ${soundStatus}`,
                    icon: 'success',
                    timer: 2000,
                    showConfirmButton: false,
                    toast: true,
                    position: 'top-end',
                    background: '#10b981',
                    color: 'white'
                });
            } else {
                Swal.fire({
                    title: 'ℹ️ Sin cambios',
                    text: 'La configuración ya estaba así',
                    icon: 'info',
                    timer: 1500,
                    showConfirmButton: false,
                    toast: true,
                    position: 'top-end'
                });
            }
        }
        
        key.style.transform = '';
    });
    return;
}
            
            if (!keyChar) return;

            pressTimer = setTimeout(() => {
                isLongPress = true;
                if (keyChar === 'N') {
                    console.log('Pulsación larga en N -> Ñ');
                    processVirtualKeyPress('Ñ');
                }
            }, LONG_PRESS_DURATION);
        };

        const handleEndPress = (event) => {
            event.preventDefault();
            clearTimeout(pressTimer);
            key.style.transform = '';

            if (action === 'backspace' || action === 'settings') {
                return;
            }
            
            if (!keyChar) return;

            if (!isLongPress) {
                if (keyChar === 'N') {
                    processVirtualKeyPress('N');
                } else {
                    processVirtualKeyPress(keyChar);
                }
            }
        };

        key.addEventListener('mousedown', handleStartPress);
        key.addEventListener('mouseup', handleEndPress);
        key.addEventListener('mouseleave', () => {
            clearTimeout(pressTimer);
            key.style.transform = '';
        });

        key.addEventListener('touchstart', handleStartPress, { passive: false });
        key.addEventListener('touchend', handleEndPress);
        key.addEventListener('touchcancel', () => {
            clearTimeout(pressTimer);
            key.style.transform = '';
        });
    });
    
    console.log(`Teclado virtual (${currentKeyboardLayout.toUpperCase()}) inicializado correctamente.`);
    console.log('=== FIN INICIALIZACIÓN TECLADO ===');
}


async function initializeGame() {
    console.log('=== INICIALIZANDO JUEGO ===');
    
    if (!verifyDOMElements()) {
        console.error('Error: Elementos del DOM no encontrados');
        return;
    }
  
    initializeRandomFruits();
    updateFruitDisplay();
    await mostrarImagenGrandeTemporal(currentFruit.image); // SOLO AQUÍ
    generateGrid();
    startTimer();
    initializeVirtualKeyboard(); 
    updateScoreDisplay(); 
}





function playKeySound(key) {
    // Si el sonido está deshabilitado, no reproducir nada
    if (!keyboardSoundEnabled) {
        return;
    }
    
    try {
        if (!window.audioContext) {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const audioContext = window.audioContext;
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filterNode = audioContext.createBiquadFilter();
        
        // Conectar en cadena: oscillator -> filter -> gain -> destination
        oscillator.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Configurar filtro para sonido más moderno
        filterNode.type = 'lowpass';
        filterNode.frequency.setValueAtTime(2000, audioContext.currentTime);
        
        // Frecuencias más suaves y agradables
        let frequency = 440;
        let volumeMultiplier = 1;
        
        if (key === 'backspace') {
            frequency = 220;
            volumeMultiplier = 1.6;
        } else if (key === 'settings') {
            frequency = 880;
        } else if (typeof key === 'string' && key.length === 1) {
            const pentatonicScale = [261.63, 293.66, 329.63, 392.00, 440.00];
            const charCode = key.charCodeAt(0);
            frequency = pentatonicScale[charCode % pentatonicScale.length];
        }
        
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = 'sine';
        
        const attackTime = 0.005;
        const decayTime = 0.02;
        const sustainLevel = 0.3;
        const releaseTime = 0.08;
        
        const baseVolume = 0.35 * volumeMultiplier;
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(baseVolume, audioContext.currentTime + attackTime);
        gainNode.gain.linearRampToValueAtTime(sustainLevel * baseVolume, audioContext.currentTime + attackTime + decayTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + attackTime + decayTime + releaseTime);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + attackTime + decayTime + releaseTime);
        
        oscillator.onended = function() {
            try {
                oscillator.disconnect();
                filterNode.disconnect();
                gainNode.disconnect();
            } catch(e) {}
        };
        
    } catch (e) {
        console.log('Error en sonido de tecla:', e);
    }
}

let photoTimeoutId = null;
        // Función cuando se agota el tiempo
function handleTimeOut() {
    console.log('=== TIMEOUT EJECUTADO ===');
    console.log(`Tiempo agotado para: ${currentFruit.name}`);
    console.log(`Fruta actual index: ${currentFruitIndex}`);
    console.log(`Completadas: ${Array.from(completedFruits)}`);
    console.log(`Disponibles: ${availableFruits}`);

    // Cancela cualquier temporizador de foto pendiente
    if (typeof photoTimeoutId !== 'undefined' && photoTimeoutId) {
        clearTimeout(photoTimeoutId);
        photoTimeoutId = null;
    }

    // Añadir a frutas incompletas si no está completada
    if (!completedFruits.has(currentFruitIndex)) {
        incompleteFruits.push(currentFruitIndex);
        console.log(`Añadida ${currentFruit.name} (${currentFruitIndex}) a incompletas`);
    }

    console.log(`Frutas incompletas total: ${incompleteFruits}`);

    // Buscar siguiente fruta inmediatamente
    console.log('Buscando siguiente fruta...');
    findNextAvailableFruit();
}


async function findNextAvailableFruit() {
    console.log('=== BUSCANDO SIGUIENTE FRUTA ===');
    
    let nextIndex = -1;
    let currentIndexInArray = availableFruits.indexOf(currentFruitIndex);
    
    // Buscar desde la siguiente posición en adelante
    for (let i = currentIndexInArray + 1; i < availableFruits.length; i++) {
        if (!completedFruits.has(availableFruits[i])) {
            nextIndex = availableFruits[i];
            break;
        }
    }
    
    // Si no encontró nada, buscar desde el principio
    if (nextIndex === -1) {
        for (let i = 0; i < currentIndexInArray; i++) {
            if (!completedFruits.has(availableFruits[i])) {
                nextIndex = availableFruits[i];
                break;
            }
        }
    }
    
    if (nextIndex !== -1) {
        currentFruitIndex = nextIndex;
        currentFruit = fruits[currentFruitIndex];

        // SOLO aquí, y SOLO una vez
        await mostrarImagenGrandeTemporal(currentFruit.image);

        updateFruitDisplay();
        generateGrid();
        initializeVirtualKeyboard();
        startTimer();
    } else {
        await checkForIncompleteRounds();
    }
}

        // Función para mezclar array aleatoriamente (algoritmo Fisher-Yates)
 function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

// Inicializar frutas disponibles de forma aleatoria
function initializeRandomFruits() {
    console.log('Inicializando frutas aleatorias...');
    availableFruits = shuffleArray(fruits.map((_, index) => index));
    currentFruitIndex = availableFruits[0];
    currentFruit = fruits[currentFruitIndex];
    console.log('Primera fruta:', currentFruit.name);
    console.log('Orden aleatorio:', availableFruits.map(i => fruits[i].name));
}



  function openImageModal() {
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const fruitImage = document.getElementById('fruitImage');
            
            modalImage.src = fruitImage.src;
            modal.style.display = 'flex';
            
            // Prevenir scroll del body cuando el modal está abierto
            document.body.style.overflow = 'hidden';
        }

        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            modal.style.display = 'none';
            
            // Restaurar scroll del body
            document.body.style.overflow = 'auto';
        }
         // Cerrar modal con tecla Escape
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeImageModal();
            }
        });
         // Prevenir que el clic en la imagen cierre el modal
        document.getElementById('modalImage').addEventListener('click', function(event) {
            event.stopPropagation();
        });

        function updateFruitDisplay() {
            document.getElementById('fruitImage').src = currentFruit.image;

        }
        // Generar sonido de éxito
 function playSuccessSound() {
    try {
        // Detener cualquier oscilador previo
        if (window.currentOscillator) {
            try {
                window.currentOscillator.stop();
                window.currentOscillator.disconnect();
            } catch(e) {}
            window.currentOscillator = null;
        }
        
        if (!window.audioContext) {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const audioContext = window.audioContext;
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // Crear múltiples osciladores para un acorde armonioso
        const frequencies = [523.25, 659.25, 783.99]; // Do5, Mi5, Sol5 (acorde mayor)
        const oscillators = [];
        const gainNodes = [];
        const filterNodes = [];
        
        frequencies.forEach((freq, index) => {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            // Configurar filtro para sonido más cálido
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000 - (index * 200), audioContext.currentTime);
            filter.Q.setValueAtTime(1, audioContext.currentTime);
            
            // Conectar en cadena
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            // Configurar oscilador
            osc.frequency.setValueAtTime(freq, audioContext.currentTime);
            osc.type = 'triangle'; // Sonido más suave y cálido
            
            // Volumen decreciente para cada nota (armonía)
            const baseVolume = 0.12;
            const noteVolume = baseVolume * (1 - index * 0.3);
            
            // Envolvente elegante (ADSR)
            const attackTime = 0.02;   // Ataque suave
            const decayTime = 0.1;     // Decaimiento gradual
            const sustainLevel = 0.6;  // Sostenimiento medio
            const releaseTime = 1.2;   // Liberación larga y elegante
            
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(noteVolume, audioContext.currentTime + attackTime);
            gain.gain.linearRampToValueAtTime(noteVolume * sustainLevel, audioContext.currentTime + attackTime + decayTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + attackTime + decayTime + releaseTime);
            
            // Añadir ligera modulación para más expresividad
            if (index === 0) { // Solo a la nota principal
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                osc.frequency.linearRampToValueAtTime(freq * 1.02, audioContext.currentTime + 0.3);
                osc.frequency.linearRampToValueAtTime(freq, audioContext.currentTime + 0.8);
            }
            
            const totalDuration = attackTime + decayTime + releaseTime;
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + totalDuration);
            
            oscillators.push(osc);
            gainNodes.push(gain);
            filterNodes.push(filter);
        });
        
        // Guardar referencias para limpieza
        window.currentOscillator = oscillators[0]; // Usar el primero como referencia
        
        // Limpiar cuando termine el último oscilador
        oscillators[oscillators.length - 1].onended = function() {
            try {
                oscillators.forEach(osc => osc.disconnect());
                gainNodes.forEach(gain => gain.disconnect());
                filterNodes.forEach(filter => filter.disconnect());
            } catch(e) {}
            window.currentOscillator = null;
        };
        
    } catch (e) {
        console.log('Error en sonido de éxito:', e);
    }
}

function playPointScoredSound() {
    // Función mantenida para compatibilidad pero sin sonido
    // Solo se mantiene para que triggerPointScoredEffects() pueda llamarla
    // sin generar errores, pero no produce audio
    console.log('Sonido de punto desactivado - solo efecto visual');
}


function triggerPointScoredEffects() {
    const scoreDisplayElement = document.getElementById('scoreDisplayContainer'); // El contenedor principal
    
    if (scoreDisplayElement) {
        playPointScoredSound(); // Reproducir sonido

        scoreDisplayElement.classList.add('animate-score'); // Añadir clase para animación

        // Quitar la clase después de que la animación termine para poder reutilizarla
        setTimeout(() => {
            scoreDisplayElement.classList.remove('animate-score');
        }, 600); // Duración de la animación (0.6s)
    }
}

function processVirtualKeyPress(keyValue) {
    let currentTargetInput = logicallyActiveInput;

    if (!currentTargetInput || !currentTargetInput.closest('.green input')) {
        const firstGreenInput = document.querySelector('.green input');
        if (firstGreenInput) {
            firstGreenInput.focus(); // Esto actualizará logicallyActiveInput a través del listener 'focusin'
            currentTargetInput = logicallyActiveInput;
        }
    }

    if (!currentTargetInput) {
        console.log('No hay input activo para el teclado virtual.');
        return;
    }

    virtualKeyboardIsWriting = true; // Indicar que el teclado virtual va a operar
    currentTargetInput.readOnly = false;
    currentTargetInput.value = keyValue.toUpperCase();
    currentTargetInput.readOnly = true;
    virtualKeyboardIsWriting = false; // El teclado virtual ha terminado de operar en ESTE input

    const nextInput = getNextInput(currentTargetInput);
    if (nextInput) {
        setTimeout(() => {
            // Cuando el foco se mueva, virtualKeyboardIsWriting será false,
            // permitiendo que el listener 'focusin' global configure readOnly.
            nextInput.focus();
            ensureInputVisible(nextInput);
        }, 10); // Timeout corto para asegurar que el DOM se actualice
    }
    setTimeout(checkAnswerAutomatic, 100);
}
// ... (código existente) ...

function processVirtualBackspace() {
    let currentTargetInput = logicallyActiveInput;

    // Asegurarse de tener un input objetivo
    if (!currentTargetInput || !currentTargetInput.closest('.green input')) {
        const firstGreenInput = document.querySelector('.green input');
        if (firstGreenInput) {
            // Al enfocar, el listener 'focusin' global actualizará logicallyActiveInput
            // y se encargará de la visibilidad y el estado readOnly inicial.
            firstGreenInput.focus();
            currentTargetInput = logicallyActiveInput; // Actualizar currentTargetInput después del foco
        }
    }

    if (!currentTargetInput) {
        console.log('No hay input activo para el backspace virtual.');
        return; // Salir si no hay dónde operar
    }

    if (currentTargetInput.value) {
        // Caso 1: El input actual tiene contenido, borrarlo.
        virtualKeyboardIsWriting = true; // Indicar operación del teclado virtual
        currentTargetInput.readOnly = false; // Permitir modificación
        currentTargetInput.value = '';       // Borrar contenido
        currentTargetInput.readOnly = true;  // Restaurar solo lectura
        virtualKeyboardIsWriting = false; // Terminar operación del teclado virtual
    } else {
        // Caso 2: El input actual está vacío. Intentar moverse al anterior y borrar su contenido.
        const prevInput = getPreviousInput(currentTargetInput);
        if (prevInput) {
            // Mover el foco al input anterior.
            // El listener 'focusin' global se activará, actualizará logicallyActiveInput,
            // y llamará a ensureInputVisible.
            // En este punto, virtualKeyboardIsWriting es false, por lo que focusin
            // pondrá prevInput en readOnly=true.
            prevInput.focus();

            // Usar un micro-timeout para permitir que el evento de foco se procese completamente
            // (incluyendo la actualización de logicallyActiveInput por el listener 'focusin')
            // antes de intentar borrar el contenido del nuevo input activo.
            setTimeout(() => {
                // Ahora, logicallyActiveInput debería ser el prevInput.
                // Verificar que el foco se haya movido correctamente y que el nuevo input tenga valor.
                if (logicallyActiveInput && logicallyActiveInput === prevInput && logicallyActiveInput.value) {
                    virtualKeyboardIsWriting = true; // Indicar operación del teclado virtual
                    logicallyActiveInput.readOnly = false; // Permitir modificación
                    logicallyActiveInput.value = '';       // Borrar contenido del (ahora) input activo
                    logicallyActiveInput.readOnly = true;  // Restaurar solo lectura
                    virtualKeyboardIsWriting = false; // Terminar operación del teclado virtual
                }
                // ensureInputVisible ya es llamado por el listener 'focusin' global
                // con su propio setTimeout, por lo que no es estrictamente necesario aquí
                // a menos que se necesite un ajuste de visibilidad inmediato post-borrado.
            }, 10); // Un timeout muy corto (10ms) es usualmente suficiente.
        }
        // Si no hay prevInput, no se hace nada más.
    }
    setTimeout(checkAnswerAutomatic, 100); // Verificar respuesta después de la operación
}

function generateGrid() {
    const grid = document.getElementById('crossword');
    grid.innerHTML = '';
    
    const gridRows = 19;
    const gridCols = 18;
    const gridData = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
    
    // Primero, mapear todas las letras
    fruits.forEach(fruit => {
        const pos = fruit.position;
        for (let i = 0; i < fruit.name.length; i++) {
            let row, col;
            if (pos.direction === 'horizontal') {
                row = pos.row;
                col = pos.col + i;
            } else {
                row = pos.row + i;
                col = pos.col;
            }
            
            if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                if (!gridData[row][col]) {
                    gridData[row][col] = { type: 'white', letters: [] };
                }
                gridData[row][col].letters.push({
                    letter: fruit.name[i],
                    fruitIndex: fruits.indexOf(fruit),
                    letterIndex: i
                });
            }
        }
    });
    
    // Crear set de posiciones que pertenecen a la fruta actual
    const currentFruitPositions = new Set();
    const currentPos = currentFruit.position;
    
    for (let i = 0; i < currentFruit.name.length; i++) {
        let row, col;
        if (currentPos.direction === 'horizontal') {
            row = currentPos.row;
            col = currentPos.col + i;
        } else {
            row = currentPos.row + i;
            col = currentPos.col;
        }
        if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
            currentFruitPositions.add(`${row}-${col}`);
        }
    }
    
    // Generar el grid
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            const cell = document.createElement('div');
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            const positionKey = `${row}-${col}`;
            
            if (gridData[row][col] && gridData[row][col].type === 'white') {
                cell.className = 'cell white';
                
                // CORRECCIÓN: Usar el set de posiciones para determinar si pertenece a la fruta actual
                if (currentFruitPositions.has(positionKey)) {
                    cell.classList.add('green');
                    
                    // Verificar si hay letras completadas de OTRAS frutas en esta posición
                    const completedLetterFromOtherFruit = gridData[row][col].letters.find(
                        letterData => letterData.fruitIndex !== currentFruitIndex && completedFruits.has(letterData.fruitIndex)
                    );
                    
                    if (completedLetterFromOtherFruit) {
                        // Es una intersección con otra fruta completada
                        cell.textContent = completedLetterFromOtherFruit.letter;
                        cell.style.backgroundColor = '#86efac'; // Mantener color verde
                        cell.style.color = '#1f2937';
                        cell.classList.add('filled-intersection');
                    } else {
                        // Es una celda normal de la fruta actual - crear input
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.inputMode = 'none';
                        input.autocomplete = 'off';
                        input.style.caretColor = 'transparent';
                        
                        cell.appendChild(input);
                    }
                } else {
                    // No pertenece a la fruta actual
                    const completedLetter = gridData[row][col].letters.find(
                        letterData => completedFruits.has(letterData.fruitIndex)
                    );
                    
                    if (completedLetter) {
                        cell.textContent = completedLetter.letter;
                        cell.style.backgroundColor = '#fef3c7';
                        cell.style.color = '#1f2937';
                        cell.classList.add('filled');
                    }
                }
           } else {
    cell.className = 'cell black';
    cell.style.backgroundColor = 'transparent'; // Cambiado de '#000' a 'transparent'
}
            
            grid.appendChild(cell);
        }
    }
    
    setTimeout(() => {
        const firstInput = document.querySelector('.green input');
        if (firstInput) {
            firstInput.focus();
            ensureInputVisible(firstInput);
        }
        centerOnGreenWord();
    }, 100);
}

function centerOnGreenWord() {
    const gridContainer = document.querySelector('.grid-container');
    
    if (!gridContainer) {
        console.log('No hay contenedor del grid');
        return;
    }
    
    // CAMBIO: Obtener todas las celdas que DEBERÍAN ser verdes para la fruta actual
    const currentPos = currentFruit.position;
    const wordCells = [];
    
    // Calcular todas las posiciones de la palabra actual
    for (let i = 0; i < currentFruit.name.length; i++) {
        let row, col;
        if (currentPos.direction === 'horizontal') {
            row = currentPos.row;
            col = currentPos.col + i;
        } else {
            row = currentPos.row + i;
            col = currentPos.col;
        }
        
        // Buscar la celda en esa posición
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (cell) {
            wordCells.push({
                row: row,
                col: col,
                element: cell
            });
        }
    }
    
    if (wordCells.length === 0) {
        console.log('No se encontraron celdas para la palabra actual');
        return;
    }
    
    console.log(`Centrando palabra "${currentFruit.name}" con ${wordCells.length} celdas`);
    
    // Obtener la primera y última celda de la palabra
    const firstCell = wordCells[0].element;
    const lastCell = wordCells[wordCells.length - 1].element;
    
    // Calcular posiciones absolutas de la primera y última celda
    const firstCellRect = firstCell.getBoundingClientRect();
    const lastCellRect = lastCell.getBoundingClientRect();
    const containerRect = gridContainer.getBoundingClientRect();
    
    // Posiciones relativas al contenido scrolleable
    const firstCellLeft = firstCellRect.left - containerRect.left + gridContainer.scrollLeft;
    const firstCellTop = firstCellRect.top - containerRect.top + gridContainer.scrollTop;
    const lastCellRight = lastCellRect.right - containerRect.left + gridContainer.scrollLeft;
    const lastCellBottom = lastCellRect.bottom - containerRect.top + gridContainer.scrollTop;
    
    // Calcular los límites de toda la palabra
    const wordLeft = firstCellLeft;
    const wordTop = firstCellTop;
    const wordRight = lastCellRight;
    const wordBottom = lastCellBottom;
    const wordWidth = wordRight - wordLeft;
    const wordHeight = wordBottom - wordTop;
    
    // Dimensiones del contenedor visible
    const containerWidth = gridContainer.clientWidth;
    const containerHeight = gridContainer.clientHeight;
    
    // Margen para mejor centrado
    const margin = 40;
    
    // Calcular scroll horizontal
    let targetScrollLeft = gridContainer.scrollLeft;
    
    if (currentPos.direction === 'vertical') {
        // Para palabras verticales, centrar horizontalmente
        const wordCenterX = wordLeft + (wordWidth / 2);
        targetScrollLeft = wordCenterX - (containerWidth / 2);
    } else {
        // Para palabras horizontales
        if (wordWidth + (margin * 2) <= containerWidth) {
            // La palabra cabe completa con margen - centrarla
            const wordCenterX = wordLeft + (wordWidth / 2);
            targetScrollLeft = wordCenterX - (containerWidth / 2);
        } else {
            // La palabra es más ancha que el contenedor - mostrar desde el inicio
            targetScrollLeft = wordLeft - margin;
        }
    }
    
    // Calcular scroll vertical
    let targetScrollTop = gridContainer.scrollTop;
    
    if (currentPos.direction === 'horizontal') {
        // Para palabras horizontales, centrar verticalmente
        const wordCenterY = wordTop + (wordHeight / 2);
        targetScrollTop = wordCenterY - (containerHeight / 2);
    } else {
        // Para palabras verticales
        if (wordHeight + (margin * 2) <= containerHeight) {
            // La palabra cabe completa con margen - centrarla
            const wordCenterY = wordTop + (wordHeight / 2);
            targetScrollTop = wordCenterY - (containerHeight / 2);
        } else {
            // La palabra es más alta que el contenedor - mostrar desde el inicio
            targetScrollTop = wordTop - margin;
        }
    }
    
    // Asegurar que el scroll esté dentro de los límites válidos
    const maxScrollLeft = Math.max(0, gridContainer.scrollWidth - containerWidth);
    const maxScrollTop = Math.max(0, gridContainer.scrollHeight - containerHeight);
    
    targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
    targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop));
    
    console.log(`Scroll objetivo: left=${targetScrollLeft} (actual=${gridContainer.scrollLeft}), top=${targetScrollTop} (actual=${gridContainer.scrollTop})`);
    
    // Verificar si realmente necesitamos hacer scroll
    const scrollThreshold = 10;
    const needsHorizontalScroll = Math.abs(gridContainer.scrollLeft - targetScrollLeft) > scrollThreshold;
    const needsVerticalScroll = Math.abs(gridContainer.scrollTop - targetScrollTop) > scrollThreshold;
    
    if (needsHorizontalScroll || needsVerticalScroll) {
        gridContainer.scrollTo({
            left: targetScrollLeft,
            top: targetScrollTop,
            behavior: 'smooth'
        });
        console.log(`✅ Scroll aplicado - Nueva posición: left=${targetScrollLeft}, top=${targetScrollTop}`);
    } else {
        console.log('ℹ️ No es necesario hacer scroll, la palabra ya está bien posicionada');
    }
}


function shouldCellHaveSeparator(row, col) {
    const pos = currentFruit.position;
    
    // Solo aplicar a la fruta actual
    if (!isCurrentFruitCell(row, col)) {
        return false;
    }
    
    // Calcular la posición relativa en el nombre de la fruta
    let relativeIndex;
    if (pos.direction === 'horizontal') {
        relativeIndex = col - pos.col;
    } else {
        relativeIndex = row - pos.row;
    }
    
    // Buscar espacios en el nombre de la fruta y verificar si esta posición corresponde a un espacio
    const fruitName = currentFruit.name;
    let letterCount = 0;
    
    for (let i = 0; i < fruitName.length; i++) {
        if (fruitName[i] === ' ') {
            // Si encontramos un espacio y coincide con la posición relativa
            if (letterCount === relativeIndex) {
                return true;
            }
        } else {
            letterCount++;
        }
    }
    
    return false;
}

 function isCurrentFruitCell(row, col) {
    const pos = currentFruit.position;
    const nameWithoutSpaces = currentFruit.name.replace(/\s/g, '');
    const nameLength = nameWithoutSpaces.length + (currentFruit.name.split(' ').length - 1); // Contar espacios como posiciones
    
    if (pos.direction === 'horizontal') {
        return row === pos.row && col >= pos.col && col < pos.col + nameLength;
    } else {
        return col === pos.col && row >= pos.row && row < pos.row + nameLength;
    }
}

        function isCompletedFruitCell(row, col) {
            return fruits.some((fruit, index) => {
                if (!completedFruits.has(index)) return false;
                
                const pos = fruit.position;
                if (pos.direction === 'horizontal') {
                    return row === pos.row && col >= pos.col && col < pos.col + fruit.name.length;
                } else {
                    return col === pos.col && row >= pos.row && row < pos.row + fruit.name.length;
                }
            });
        }

        function getLetterAt(row, col) {
            for (let i = 0; i < fruits.length; i++) {
                if (completedFruits.has(i)) {
                    const fruit = fruits[i];
                    const pos = fruit.position;
                    
                    if (pos.direction === 'horizontal') {
                        if (row === pos.row && col >= pos.col && col < pos.col + fruit.name.length) {
                            return fruit.name[col - pos.col];
                        }
                    } else {
                        if (col === pos.col && row >= pos.row && row < pos.row + fruit.name.length) {
                            return fruit.name[row - pos.row];
                        }
                    }
                }
            }
            return '';
        }

function handleInput(event) {
    // Bloquear completamente los eventos de input del teclado físico
    event.preventDefault();
    return false;
}


// ... (código existente) ...
// ... (código existente) ...
function ensureInputVisible(input) {
    const gridContainer = document.querySelector('.grid-container');
    const virtualKeyboard = document.querySelector('.virtual-keyboard');
    let keyboardHeight = 0;

    if (virtualKeyboard && getComputedStyle(virtualKeyboard).display !== 'none') {
        keyboardHeight = virtualKeyboard.offsetHeight;
    }

    const cell = input.parentElement;
    const cellRect = cell.getBoundingClientRect();
    const containerRect = gridContainer.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const effectiveViewportBottom = viewportHeight - keyboardHeight;

    let scrollAmountPage = 0;

    // Si la parte inferior de la celda está debajo del borde visible (considerando el teclado)
    if (cellRect.bottom > effectiveViewportBottom) {
        scrollAmountPage = cellRect.bottom - effectiveViewportBottom + 20; // +20px de margen
        
        if (!pageScrolledDueToKeyboard) { // Solo guardar si no hemos forzado el scroll antes
            previousScrollY = window.scrollY;
        }
        pageScrolledDueToKeyboard = true; // Marcamos que hemos forzado el scroll de página

        window.scrollBy({
            top: scrollAmountPage,
            left: 0,
            behavior: 'smooth'
        });
        console.log(`Página desplazada por teclado: ${scrollAmountPage}px`);

    } else {
        // La celda NO está oculta por el teclado.
        // Si previamente desplazamos la página POR EL TECLADO, intentamos revertir.
        if (pageScrolledDueToKeyboard && previousScrollY !== null) {
            // Comprobamos si la celda actual estaría visible si volvemos al scroll anterior
            // Esto es una heurística: si la parte superior de la celda está razonablemente visible
            const wouldBeVisibleTop = cellRect.top - (window.scrollY - previousScrollY);
            const wouldBeVisibleBottom = cellRect.bottom - (window.scrollY - previousScrollY);

            // Solo revertir si la celda seguiría estando mayormente visible y no debajo del teclado
            // y si el scroll actual es mayor que el previo (es decir, bajamos la página)
            if (window.scrollY > previousScrollY && wouldBeVisibleTop > 0 && wouldBeVisibleBottom < effectiveViewportBottom) {
                 window.scrollTo({
                    top: previousScrollY,
                    left: window.scrollX,
                    behavior: 'smooth'
                });
                console.log(`Página revertida a scroll anterior: ${previousScrollY}px`);
            }
            // Una vez que intentamos revertir (o decidimos no hacerlo), reseteamos.
            pageScrolledDueToKeyboard = false; 
            previousScrollY = null;
        } else if (pageScrolledDueToKeyboard) {
            // Si pageScrolledDueToKeyboard es true pero previousScrollY es null (no debería pasar mucho)
            // o si la condición de reversión no se cumple, simplemente reseteamos la bandera.
            pageScrolledDueToKeyboard = false;
            previousScrollY = null;
        }
    }

    // --- Lógica de scroll interno del grid-container (sin cambios) ---
    const marginBuffer = 20;
    const cellLeftInContainer = cellRect.left - containerRect.left;
    const cellRightInContainer = cellLeftInContainer + cellRect.width;
    const visibleRightInContainer = gridContainer.clientWidth;
    let needsInternalScroll = false;
    let targetScrollLeft = gridContainer.scrollLeft;

    if (cellLeftInContainer < marginBuffer) { // Ajustado para usar solo marginBuffer
        targetScrollLeft = gridContainer.scrollLeft + cellLeftInContainer - marginBuffer;
        needsInternalScroll = true;
    } else if (cellRightInContainer > visibleRightInContainer - marginBuffer) {
        targetScrollLeft = gridContainer.scrollLeft + cellRightInContainer - gridContainer.clientWidth + marginBuffer;
        needsInternalScroll = true;
    }
    
    if (needsInternalScroll) {
        const maxScrollLeft = gridContainer.scrollWidth - gridContainer.clientWidth;
        targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
        
        gridContainer.scrollTo({
            left: targetScrollLeft,
            behavior: 'smooth'
        });
        console.log(`Scroll interno del grid ajustado a: ${targetScrollLeft}px`);
    }
}


 function handleKeyDown(event) {
    // Bloquear completamente todos los eventos de teclado físico/móvil
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    
    // No procesar ninguna tecla física
    return false;
}


 function getNextInput(currentInput) {
    const cell = currentInput.parentElement;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const pos = currentFruit.position;
    
    let nextRow, nextCol;
    if (pos.direction === 'horizontal') {
        nextRow = row;
        nextCol = col + 1;
    } else {
        nextRow = row + 1;
        nextCol = col;
    }
    
    // Buscar la siguiente casilla que sea un input (no una intersección pre-llenada)
    let attempts = 0;
    while (attempts < currentFruit.name.length) {
        const nextCell = document.querySelector(`[data-row="${nextRow}"][data-col="${nextCol}"]`);
        const nextInput = nextCell ? nextCell.querySelector('input') : null;
        
        if (nextInput) {
            return nextInput;
        }
        
        // Si no hay input, continuar a la siguiente posición
        if (pos.direction === 'horizontal') {
            nextCol++;
        } else {
            nextRow++;
        }
        attempts++;
    }
    
    return null;
}

function getPreviousInput(currentInput) {
    const cell = currentInput.parentElement;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const pos = currentFruit.position;
    
    let prevRow, prevCol;
    if (pos.direction === 'horizontal') {
        prevRow = row;
        prevCol = col - 1;
    } else {
        prevRow = row - 1;
        prevCol = col;
    }
    
    // Buscar la casilla anterior que sea un input (no una intersección pre-llenada)
    let attempts = 0;
    while (attempts < currentFruit.name.length) {
        const prevCell = document.querySelector(`[data-row="${prevRow}"][data-col="${prevCol}"]`);
        const prevInput = prevCell ? prevCell.querySelector('input') : null;
        
        if (prevInput) {
            return prevInput;
        }
        
        // Si no hay input, continuar a la posición anterior
        if (pos.direction === 'horizontal') {
            prevCol--;
        } else {
            prevRow--;
        }
        attempts++;
    }
    
    return null;
}
function checkAnswerAutomatic() {
    if (window.checkingAnswer) {
        return;
    }

    // Cancela el temporizador automático de la palabra
    if (timer) {
        clearInterval(timer);
        timer = null;
    }
    // Cancela cualquier timeout de foto pendiente
    if (typeof photoTimeoutId !== 'undefined' && photoTimeoutId) {
        clearTimeout(photoTimeoutId);
        photoTimeoutId = null;
    }

    const inputs = document.querySelectorAll('.green input');
    let userAnswer = '';
    let isComplete = true;

    const pos = currentFruit.position;

    for (let i = 0; i < currentFruit.name.length; i++) {
        if (currentFruit.name[i] === ' ') {
            userAnswer += ' ';
            continue;
        }

        let letterFound = false;
        let currentRow, currentCol;

        if (pos.direction === 'horizontal') {
            currentRow = pos.row;
            currentCol = pos.col + i;
        } else {
            currentRow = pos.row + i;
            currentCol = pos.col;
        }

        // Buscar en celdas con clase .green (tanto intersecciones como inputs)
        const greenCell = document.querySelector(`[data-row="${currentRow}"][data-col="${currentCol}"].green`);
        if (greenCell) {
            // Si tiene input, usar el valor del input
            const input = greenCell.querySelector('input');
            if (input) {
                if (input.value) {
                    userAnswer += input.value;
                    letterFound = true;
                }
            } else {
                // Si no tiene input, es una intersección - usar el texto
                if (greenCell.textContent) {
                    userAnswer += greenCell.textContent;
                    letterFound = true;
                }
            }
        }

        if (!letterFound) {
            isComplete = false;
            break;
        }
    }

    if (isComplete && userAnswer === currentFruit.name) {
        playSuccessSound();

        // Marcar como correctas todas las celdas verdes (inputs e intersecciones)
        document.querySelectorAll('.green').forEach(cell => {
            cell.classList.add('correct');
        });

        const previousScore = completedFruits.size;
        completedFruits.add(currentFruitIndex);

        if (completedFruits.size > previousScore) {
            triggerPointScoredEffects();

            // NUEVO: Enviar puntos al Google Sheet
            const newPoints = 1;
            sendPointsToSheet(newPoints, 'fruta_completada').then(success => {
                if (success) {
                    console.log(`✅ Puntos registrados en Google Sheet: ${newPoints} por fruta completada`);
                } else {
                    console.log('⚠️ No se pudieron registrar los puntos en Google Sheet');
                }
            });
        }

        updateScoreDisplay();
        incompleteFruits = incompleteFruits.filter(index => index !== currentFruitIndex);

        setTimeout(() => {
            playAudio(currentFruit.audio);

            const audio = window.currentAudio;
            let duracion = 2000;
            if (audio && audio.duration && !isNaN(audio.duration)) {
                duracion = audio.duration * 1000;
            }

            setTimeout(() => {
                nextFruit(); // SOLO esto, sin mostrar imagen aquí
            }, duracion);
        }, 800);
    }
}
async function nextFruit() {
    stopTimer();
    stopAllAudio();
    setTimeout(async () => {
        await findNextAvailableFruit();
    }, 100);
}

async function checkForIncompleteRounds() {
    if (incompleteFruits.length > 0) {
        currentRound++;
        availableFruits = shuffleArray([...incompleteFruits]);
        incompleteFruits = [];
        currentFruitIndex = availableFruits[0];
        currentFruit = fruits[currentFruitIndex];
        updateFruitDisplay();
        await mostrarImagenGrandeTemporal(currentFruit.image); // SOLO AQUÍ
        generateGrid();
        initializeVirtualKeyboard();
        startTimer();
    } else {
        // Aquí el usuario ha completado todas las palabras
        notifyGameCompleted().then(() => {
            startWinnerPolling();
        });
    }
}

   
   function resetGame() {
    stopTimer();
    completedFruits.clear();
    updateScoreDisplay();
    incompleteFruits = [];
    currentRound = 1;
    initializeRandomFruits();
    updateFruitDisplay();
    generateGrid();
    startTimer();
    initializeVirtualKeyboard(); // AÑADIR
}

let logicallyActiveInput = null;
let virtualKeyboardIsWriting = false;
let previousScrollY = null; // Para guardar la posición de scroll antes de un ajuste
let pageScrolledDueToKeyboard = false; // Bandera para indicar si ajustamos el scroll de la página

// ...
document.addEventListener('focusin', function(e) {
    if (e.target.tagName === 'INPUT' && e.target.closest('.cell.white')) {
        const inputField = e.target;
        // ... (lógica de readOnly y logicallyActiveInput) ...
        logicallyActiveInput = inputField;
        
        // Asegurar visibilidad después de que el foco se haya establecido
        // y logicallyActiveInput esté actualizado.
        // Usar un pequeño timeout para permitir que el DOM se estabilice
        // y que virtualKeyboardIsWriting se haya reseteado si es relevante.
        setTimeout(() => {
            if (logicallyActiveInput === inputField) { // Solo si el foco no cambió de nuevo rápidamente
                 ensureInputVisible(inputField);
            }
        }, 50); // 50ms puede ser un buen compromiso

        console.log('Input enfocado (focusin global):', logicallyActiveInput, 'readOnly:', inputField.readOnly);
    }
});
// ... (antes de initializeVirtualKeyboard) ...
const keyboardLayouts = {
    qwerty: [
        ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
        ['SETTINGS', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'BACKSPACE']
    ],
    azerty: [
        ['A', 'Z', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        ['Q', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M'],
        ['SETTINGS', 'W', 'X', 'C', 'V', 'B', 'N', 'BACKSPACE']
    ]
};
let currentKeyboardLayout = 'qwerty';
let keyboardSoundEnabled = true;

function loadKeyboardLayoutPreference() {
    const savedLayout = localStorage.getItem('crosswordKeyboardLayout');
    if (savedLayout && keyboardLayouts[savedLayout]) {
        currentKeyboardLayout = savedLayout;
    }
    
    // Cargar preferencia de sonido
    const savedSoundSetting = localStorage.getItem('crosswordKeyboardSound');
    if (savedSoundSetting !== null) {
        keyboardSoundEnabled = savedSoundSetting === 'true';
    }
}

function saveKeyboardLayoutPreference() {
    localStorage.setItem('crosswordKeyboardLayout', currentKeyboardLayout);
    localStorage.setItem('crosswordKeyboardSound', keyboardSoundEnabled.toString());
}

function buildVirtualKeyboardHTML(layoutName) {
    const keyboardContainer = document.querySelector('.virtual-keyboard');
    if (!keyboardContainer) {
        console.error('Contenedor del teclado virtual no encontrado.');
        return;
    }
    keyboardContainer.innerHTML = '';

    const layout = keyboardLayouts[layoutName];
    if (!layout) {
        console.error(`Layout ${layoutName} no encontrado. Usando QWERTY por defecto.`);
        layout = keyboardLayouts.qwerty;
    }

    layout.forEach(rowKeys => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'keyboard-row';
        rowKeys.forEach(keySymbol => {
            const button = document.createElement('button');
            button.className = 'key';

            if (keySymbol === 'BACKSPACE') {
                button.innerHTML = '⌫';
                button.dataset.action = 'backspace';
                button.classList.add('special', 'backspace');
            } else if (keySymbol === 'SETTINGS') {
                button.innerHTML = '⚙️';
                button.dataset.action = 'settings';
                button.classList.add('special');
            } else {
                button.textContent = keySymbol.toLowerCase();
                button.dataset.key = keySymbol.toUpperCase();
            }
            rowDiv.appendChild(button);
        });
        keyboardContainer.appendChild(rowDiv);
    });
}
function getUserName() {
    // 1. Intenta por query string
    const params = new URLSearchParams(window.location.search);
    let user = params.get('username');
    if (user) return user;
    // 2. Intenta por localStorage (varias claves)
    user = localStorage.getItem('crosswordUsername') ||
           localStorage.getItem('userName');
    if (user) return user;
    // 3. Intenta por objeto externo
    try {
        const externalGameUser = localStorage.getItem('externalGameUser');
        if (externalGameUser) {
            const userData = JSON.parse(externalGameUser);
            if (userData.username) return userData.username;
        }
    } catch (e) {}
    return '';
}
function getUserData() {
    const urlParams = new URLSearchParams(window.location.search);
    
    let userData = {
        username: getUserName(),
        orderNumber: urlParams.get('orderNumber') || null,
        sessionId: urlParams.get('sessionId') || null,
        timestamp: Date.now()
    };
    
    // Intentar obtener datos más completos del localStorage
    try {
        const externalGameUser = localStorage.getItem('externalGameUser');
        if (externalGameUser) {
            const storedData = JSON.parse(externalGameUser);
            userData = { ...userData, ...storedData };
        }
    } catch (e) {
        console.log('Error leyendo datos completos:', e);
    }
    
    return userData;
}

function notifyGameReady() {
    // Notificar a la página padre que el juego está listo
    if (window.parent !== window) {
        window.parent.postMessage({ type: 'GAME_READY' }, '*');
    }
}

// Listener para recibir datos del iframe padre
window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'USER_DATA') {
        console.log('Datos de usuario recibidos:', event.data);
        
        // Guardar datos recibidos
        localStorage.setItem('userName', event.data.username);
        localStorage.setItem('crosswordUsername', event.data.username);
        localStorage.setItem('externalGameUser', JSON.stringify(event.data));
        
        // Actualizar interfaz si es necesario
        if (typeof updateUserInterface === 'function') {
            updateUserInterface(event.data.username);
        }
    }
});


let userDataReceived = false;

window.addEventListener('message', function(event) {
    if (
        event.data &&
        event.data.type === 'USER_DATA' &&
        !userDataReceived
    ) {
        userDataReceived = true; // Marcar como recibido
        localStorage.setItem('userName', event.data.username);
        localStorage.setItem('crosswordUsername', event.data.username);
        localStorage.setItem('externalGameUser', JSON.stringify(event.data));
        showWelcomeDialog();
    }
});

// Control de historial y popstate
let ignoreFirstPop = true;

window.onload = function() {
    history.pushState(null, '', location.href);
};

window.addEventListener('popstate', function() {
    if (ignoreFirstPop) {
        ignoreFirstPop = false;
        return;
    }
    cerrarIframeYSalir();
});

function cerrarIframeYSalir() {
    if (window.parent !== window) {
        window.parent.postMessage({ type: 'CLOSE_GAME_IFRAME_AND_EXIT' }, '*');
    } else {
        window.location.href = 'https://fawzinoo.github.io/Rep/pre.html';
    }
}


function showWelcomeDialog() {
    // Mostrar fondo azul celeste al abrir el modal
    document.getElementById('welcomeBackdrop').style.display = 'block';
    const userData = getUserData();
    const userName = userData.username;

    if (!userName || userName === 'Invitado') {
        Swal.fire({
            title: '⚠️ Usuario no detectado',
            html: `
                <p>No se pudo detectar tu nombre de usuario.</p>
                <p><strong>Posibles causas:</strong></p>
                <ul style="text-align: left; margin: 10px 0;">
                    <li>No has iniciado sesión correctamente</li>
                    <li>La página se cargó directamente</li>
                    <li>Error en la comunicación entre páginas</li>
                </ul>
                <p>¿Quieres continuar como invitado?</p>
            `,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Sí, como invitado',
            cancelButtonText: 'No, salir',
            confirmButtonColor: '#f59e0b',
            cancelButtonColor: '#ef4444',
            allowOutsideClick: false,
            allowEscapeKey: false,
            customClass: {
                popup: 'welcome-dialog-popup',
                title: 'welcome-dialog-title',
                content: 'welcome-dialog-content'
            }
        }).then((result) => {
            if (result.isConfirmed) {
                document.getElementById('welcomeBackdrop').style.display = 'none';
                initializeGame();
            } else if (result.dismiss === Swal.DismissReason.cancel) {
                cerrarIframeYSalir();
            }
        });
    } else {
        Swal.fire({
            title: `✅ Preparado ${userName}`,
            html: `
                <div style="text-align: center; margin: 15px 0;">
                    <div style="font-size: 48px; margin-bottom: 10px;">🎮</div>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>¡Hola ${userName}!</strong></p>
                    <div style="background: #f0f9ff; padding: 10px; border-radius: 8px; margin: 10px 0;">
                        <p style="font-size: 14px; color: #0369a1; margin: 0;">
                            <strong>Usuario detectado correctamente</strong><br>
                            Jugador: ${userName}<br>
                            ${userData.sessionId ? `Sesión: ${userData.sessionId.substring(0, 8)}...` : ''}<br>
                            Game: Crucigrama de Frutas 🍎
                        </p>
                    </div>
                    <p style="margin-top: 15px; color: #059669;">
                        <strong>¿Estás listo para jugar?</strong><br>
                        <small>Se registrará tu participación automáticamente</small>
                    </p>
                </div>
            `,
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: 'Sí, ¡jugar!',
            cancelButtonText: 'No, salir',
            confirmButtonColor: '#059669',
            cancelButtonColor: '#ef4444',
            allowOutsideClick: false,
            allowEscapeKey: false,
            customClass: {
                popup: 'welcome-dialog-popup',
                title: 'welcome-dialog-title',
                content: 'welcome-dialog-content'
            }
        }).then(async (result) => {
            if (result.isConfirmed) {
                document.getElementById('welcomeBackdrop').style.display = 'none';
                initializeGame();
                // Si tienes lógica de preparación extra, puedes ponerla aquí
            } else if (result.dismiss === Swal.DismissReason.cancel) {
                cerrarIframeYSalir();
            }
        });
    }
}

function updateProgressStep(stepId, text) {
    const stepElement = document.getElementById(stepId);
    if (stepElement) {
        stepElement.textContent = text;
        stepElement.style.opacity = '1';
        stepElement.style.color = '#059669';
    }
}

function cerrarJuego() {
    window.history.back();
}

// Función adicional para debugging - mostrar información de usuario
function showUserDebugInfo() {
    const userData = getUserData();
    const urlParams = new URLSearchParams(window.location.search);
    
    console.log('=== DEBUG INFO USUARIO ===');
    console.log('URL params:', Object.fromEntries(urlParams));
    console.log('localStorage userName:', localStorage.getItem('userName'));
    console.log('localStorage crosswordUsername:', localStorage.getItem('crosswordUsername'));
    console.log('localStorage externalGameUser:', localStorage.getItem('externalGameUser'));
    console.log('Datos finales:', userData);
    console.log('========================');
    
    // Mostrar en pantalla para debugging fácil
    if (window.location.search.includes('debug=1')) {
        const debugDiv = document.createElement('div');
        debugDiv.style.cssText = `
            position: fixed; top: 10px; right: 10px; 
            background: rgba(0,0,0,0.8); color: white; 
            padding: 10px; border-radius: 5px; 
            font-size: 12px; z-index: 9999; max-width: 300px;
        `;
        debugDiv.innerHTML = `
            <strong>DEBUG - Datos Usuario:</strong><br>
            Usuario: ${userData.username}<br>
            Order: ${userData.orderNumber}<br>
            Session: ${userData.sessionId}<br>
            URL params: ${urlParams.get('username') ? 'Sí' : 'No'}<br>
            LocalStorage: ${localStorage.getItem('userName') ? 'Sí' : 'No'}
        `;
        document.body.appendChild(debugDiv);
        
        // Remover después de 10 segundos
        setTimeout(() => debugDiv.remove(), 10000);
    }
}

// Modificar el event listener del DOM para incluir debug
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM cargado - obteniendo datos de usuario...');
    
    const userData = getUserData();
    console.log('Datos de usuario obtenidos:', userData);
    
    // Mostrar información de debug
    showUserDebugInfo();
    
    // Notificar que el juego está listo
    setTimeout(notifyGameReady, 1000);
    

});

// ...existing code...

// Función para enviar puntos a Google Sheets
// ...existing code...

// Función mejorada para enviar puntos con más debugging
async function sendPointsToSheet(points, eventType = 'punto_normal') { // eventType por defecto
    const userData = getUserData();
    const userName = userData.username;
    
    // ... (tu validación de userName) ...
    
    
    
    const postData = {
        action: 'registerPoints',
        username: userName,
        points: points,
        eventType: eventType, // <--- AÑADIDO/MODIFICADO
        fruitName: currentFruit ? currentFruit.name : '', // O el detalle relevante del juego
        timestamp: new Date().toISOString(),
        sessionId: userData.sessionId || null,
        orderNumber: userData.orderNumber || null,
        gameMode: 'crucigrama_frutas' // O el gameMode actual
    };
    
    console.log('📤 Datos a enviar (modo no-cors):', postData);
    
    try {
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify(postData)
        });
        console.log(`✅ Intento de envío de puntos (${points}, evento: ${eventType}) para ${userName} realizado. Verifica logs.`);
        return true;
    } catch (error) {
        console.error('💥 Error de red enviando puntos:', error);
        return false;
    }
}

// EJEMPLO DE CÓMO PODRÍAS LLAMAR A handleGameWin:
// Supongamos que tienes una función que verifica si todas las palabras están correctas
function checkForAllWordsCorrect() {
    // ... tu lógica para verificar si el juego se ganó ...
    if (todasLasPalabrasSonCorrectas) {
        const puntosDeEsteJuego = calcularPuntosDelJuegoActual(); // Necesitas esta función
        handleGameWin(puntosDeEsteJuego);
    }
}

async function fetchRanking() {
 
  try {
    const response = await fetch(url);
    const data = await response.json();
    // data.ranking es un array de usuarios y puntos
    // Aquí puedes renderizar el ranking en tu HTML
    console.log(data.ranking);
  } catch (e) {
    console.error('Error obteniendo ranking:', e);
  }
}

// Función de prueba para enviar puntos manualmente
function testSendPoints() {
    console.log('🧪 Probando envío de puntos...');
    sendPointsToSheet(1, 'test_manual').then(result => {
        console.log('🧪 Resultado del test:', result);
    });
}

// Para probar, puedes ejecutar esto en la consola del navegador:
// testSendPoints();

// ...existing code...

// Modificar la función checkAnswerAutomatic para enviar puntos cuando se complete una fruta


// Función para enviar puntos finales al completar el juego
async function sendFinalScore() {
    const totalPointsInThisGame = completedFruits.size; // Puntos de este juego específico
    const totalFruitsInGame = fruits.length;
    const percentage = totalFruitsInGame > 0 ? Math.round((totalPointsInThisGame / totalFruitsInGame) * 100) : 0;
    
    // Enviar 0 puntos porque los puntos ya se sumaron por cada fruta.
    // El eventType 'juego_completado' es importante para el script si tiene lógica específica.
    // En nuestro script actual, resetCurrentGamePointsAndIncrementGames maneja el contador de juegos.
    // Esta llamada a registerPoints con 'juego_completado' podría ser redundante para el contador de juegos
    // si registerGameStart ya lo incrementó, pero no hace daño y puede ser útil para otros logs.
    const success = await sendPointsToSheet(0, 'juego_completado'); 
    
    if (success) {
        console.log(`✅ Evento 'juego_completado' enviado. Puntos de este juego: ${totalPointsInThisGame}/${totalFruitsInGame} (${percentage}%)`);
    } else {
        console.warn(`⚠️ Falló el envío del evento 'juego_completado'.`);
    }
    
    return { success, pointsThisGame: totalPointsInThisGame }; // Devolver también los puntos de este juego
}


async function registerGameStart() {
    const userData = getUserData();
    const userName = userData.username;
    const sessionName = await getSessionNameFromServer(); // <--- NUEVO

    if (!userName || userName === 'Invitado') {
        console.log('❌ No se puede registrar inicio - usuario no registrado');
        return false;
    }


    const postData = {
        action: 'registerGameStart',
        username: userName,
        gameMode: 'crucigrama_frutas',
        timestamp: new Date().toISOString(),
        sessionName: sessionName // <--- NUEVO
    };

    try {
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify(postData)
        });
        return true;
    } catch (error) {
        console.error('💥 Error de red registrando inicio de juego:', error);
        return false;
    }
}

async function checkIfAloneInSession(sessionName) {

    const postData = {
        action: 'countUsersInSession',
        sessionName: sessionName
    };
    try {
        const response = await fetch(scriptURL, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(postData)
        });
        const data = await response.json();
        return data.count === 1;
    } catch (e) {
        return false;
    }
}

async function waitForRival(sessionName) {
    let waitingAlert = null;
    let alone = await checkIfAloneInSession(sessionName);

    if (alone) {
        waitingAlert = Swal.fire({
            title: 'Espera a tu rival',
            text: 'Aún no hay otro jugador en tu sesión. Espera un momento...',
            icon: 'info',
            allowOutsideClick: false,
            showConfirmButton: false
        });

        // Polling cada 2 segundos
        const interval = setInterval(async () => {
            const stillAlone = await checkIfAloneInSession(sessionName);
            if (!stillAlone) {
                clearInterval(interval);
                Swal.close();
                initializeGame();
            }
        }, 2000);
    } else {
        Swal.close();
        initializeGame();
        startWinnerPolling();
    }
}










window.addEventListener('beforeunload', function () {
    const userName = getUserName();
    if (!userName) return;
    const postData = {
        action: 'clearUserSession',
        username: userName
    };
    navigator.sendBeacon(
        scriptURL,
        new Blob([JSON.stringify(postData)], { type: 'text/plain' })
    );
});





function autoCompletar24Palabras() {
    completedFruits.clear();
    // Marca las primeras 24 frutas como completadas
    for (let i = 0; i < 24; i++) {
        completedFruits.add(i);
    }
    updateScoreDisplay();
    generateGrid();
    Swal.fire({
        title: 'Test rápido',
        text: '¡24 palabras autocompletadas! Solo te falta la última para probar el flujo de ganador.',
        icon: 'info',
        timer: 2000,
        showConfirmButton: false
    });
}

// Crear el botón debajo del teclado
document.addEventListener('DOMContentLoaded', function() {
    const keyboard = document.querySelector('.virtual-keyboard');
    if (keyboard) {
        const testBtn = document.createElement('button');
        testBtn.textContent = '🧪 Autocompletar 24 palabras (TEST)';
        testBtn.style.margin = '10px auto 0 auto';
        testBtn.style.display = 'block';
        testBtn.style.background = '#059669';
        testBtn.style.color = 'white';
        testBtn.style.fontWeight = 'bold';
        testBtn.style.border = 'none';
        testBtn.style.borderRadius = '8px';
        testBtn.style.padding = '10px 18px';
        testBtn.style.fontSize = '16px';
        testBtn.style.cursor = 'pointer';
        testBtn.onclick = autoCompletar24Palabras;
        keyboard.parentNode.insertBefore(testBtn, keyboard.nextSibling);
    }
});

async function clearSessionOnServer(userName) {
    if (!userName) return;
    const postData = {
        action: 'clearUserSession',
        username: userName
    };
    try {
        await fetch(scriptURL, {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify(postData)
        });
        console.log('✅ Sesión borrada en backend para', userName);
    } catch (e) {
        console.warn('No se pudo limpiar la sesión en backend:', e);
    }
}

let winnerPollingInterval = null;

function startWinnerPolling() {
    if (winnerPollingInterval) clearInterval(winnerPollingInterval);
    winnerPollingInterval = setInterval(async () => {
        const userName = getUserName();
        if (!userName) return;
        const postData = {
            action: 'getScoreStatusAndRank',
            username: userName
        };
        try {
            const response = await fetch(scriptURL, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify(postData)
            });
            const data = await response.json();
            if (data && data.completed === "GANADOR") {
                clearInterval(winnerPollingInterval);
                winnerPollingInterval = null;
                Swal.fire({
                    title: '¡Eres el GANADOR! 🎉',
                    text: '¡Felicidades, has ganado la partida!',
                    icon: 'success',
                    confirmButtonText: 'Aceptar'
                }).then(() => {
                    clearSessionOnServer(userName);
                   if (window.parent !== window) {
    window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
} else {
    window.location.href = 'pre.html';
}
                });
                launchConfetti();
                // Borra el estado GANADOR en la hoja (columna F)
                fetch(scriptURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearWinnerStatus',
                        username: userName
                    })
                });
            } else if (data && data.completed === "PERDEDOR") {
                clearInterval(winnerPollingInterval);
                winnerPollingInterval = null;
                Swal.fire({
                    title: 'Has perdido',
                    text: 'Otro jugador ha completado antes que tú.',
                    icon: 'error',
                    confirmButtonText: 'Aceptar'
                }).then(() => {
                    clearSessionOnServer(userName);
                   if (window.parent !== window) {
    window.parent.postMessage({ type: 'CLOSE_GAME' }, '*');
} else {
    window.location.href = 'pre.html';
}
                });
                // Borra el estado PERDEDOR en la hoja (columna F)
                fetch(scriptURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify({
                        action: 'clearWinnerStatus',
                        username: userName
                    })
                });
            }
        } catch (e) {
            console.error('Error al obtener estado de ganador:', e);
        }
    }, 5000);
}

async function notifyGameCompleted() {
    const userName = getUserName();
    if (!userName) return;
    const postData = {
        action: 'setCompleted',
        username: userName,
        completed: 'COMPLETED'
    };
    await fetch(scriptURL, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: JSON.stringify(postData)
    });
}

let estadoPendiente = null;

// Cuando el usuario gana o pierde:
function usuarioGana() {
  if (document.hidden) {
    estadoPendiente = 'ganador';
  } else {
    Swal.fire('¡Ganaste!', 'Felicidades', 'success');
  }
}

function usuarioPierde() {
  if (document.hidden) {
    estadoPendiente = 'perdedor';
  } else {
    Swal.fire('Perdiste', 'Intenta de nuevo', 'error');
  }
}

// Cuando el usuario regresa a la pestaña:
document.addEventListener('visibilitychange', function() {
  if (!document.hidden && estadoPendiente) {
    if (estadoPendiente === 'ganador') {
      Swal.fire('¡Ganaste!', 'Felicidades', 'success');
    } else if (estadoPendiente === 'perdedor') {
      Swal.fire('Perdiste', 'Intenta de nuevo', 'error');
    }
    estadoPendiente = null;
  }
});

function mostrarImagenGrandeTemporal(imagenUrl) {
    return new Promise((resolve) => {
        if (!imagenUrl) {
            resolve();
            return;
        }

        // Elimina cualquier overlay anterior
        document.querySelectorAll('.fruit-image-overlay').forEach(el => el.remove());

        // Crea el overlay nuevo
        const overlay = document.createElement('div');
        overlay.className = 'fruit-image-overlay';
        overlay.style.position = 'fixed';
        overlay.style.top = 0;
        overlay.style.left = 0;
        overlay.style.width = '100vw';
        overlay.style.height = '100vh';
        overlay.style.background = 'rgba(0,0,0,0.85)';
        overlay.style.display = 'flex';
        overlay.style.justifyContent = 'center';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = 9999;

        const imgGrande = document.createElement('img');
        imgGrande.src = imagenUrl;
        imgGrande.style.maxWidth = '90vw';
        imgGrande.style.maxHeight = '90vh';
        imgGrande.style.borderRadius = '20px';
        imgGrande.style.boxShadow = '0 8px 40px #000a';

        overlay.appendChild(imgGrande);
        document.body.appendChild(overlay);

        // Permite cerrar el overlay haciendo clic
        overlay.addEventListener('click', () => {
            overlay.remove();
            resolve();
        });

        // Cierra automáticamente después de 3 segundos
        setTimeout(() => {
            overlay.remove();
            resolve();
        }, 3000);
    });
}

function precargarImagenes(frutas) {
    frutas.forEach(fruta => {
        const img = new Image();
        img.src = fruta.image;
    });
}

// Llama a esta función al iniciar el juego:
precargarImagenes(fruits);


document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('welcomeBackdrop').style.display = 'block';
    showWelcomeDialog();
});
    </script>
</body>
</html>
