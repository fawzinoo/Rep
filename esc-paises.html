<!DOCTYPE html>
<html lang="es">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
        integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <title>Silabas</title>
    <style>
        /* Estilos de la barra superior */
        .top-status-bar {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 6px auto 5px auto;
            gap: 2px;
            position: relative;
            z-index: 10;
        }

        .pill {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 1.0em;
            font-weight: 600;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            background: #fff;
            min-width: 60px;
            justify-content: center;
            letter-spacing: 0.3px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .back-arrow {
            background: #fff;
            color: #333;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            gap: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .back-arrow:hover {
            background-color: #f5f5f5;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .back-arrow i {
            color: #333;
        }

        .pill-faltan {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(255, 107, 53, 0.15);
            gap: 8px;
            border: none;
        }

        .pill-correctas {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(40, 167, 69, 0.15);
            gap: 8px;
            border: none;
        }

        .pill-incorrectas {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(220, 53, 69, 0.15);
            gap: 8px;
            border: none;
        }

        .pill-progreso {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(78, 205, 196, 0.15);
            font-weight: 600;
            font-size: 1.0em;
            min-width: 60px;
            text-align: center;
            transition: all 0.3s ease;
            border: none;
        }

        .pill-progreso:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.2);
        }

        /* Estilos básicos */
        body,
        html {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #505255, #00020a);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;

            /* Eliminar cualquier selección en toda la página */
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-tap-highlight-color: transparent !important;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;
            -moz-tap-highlight-color: transparent !important;
        }

        /* Eliminar cualquier selección en todos los elementos */
        *,
        *::before,
        *::after {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-tap-highlight-color: transparent !important;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;
            -moz-tap-highlight-color: transparent !important;
            outline: none !important;
            -webkit-touch-callout: none !important;

            /* Prevenir menú contextual en todos los elementos */
            -webkit-context-menu: none !important;
            -moz-context-menu: none !important;
        }

        /* Reglas específicas para imágenes */
        img {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-drag: none !important;
            -moz-user-drag: none !important;
            pointer-events: none !important;

            /* Prevenir menú contextual específicamente en imágenes */
            -webkit-context-menu: none !important;
            -moz-context-menu: none !important;
        }

        /* Reglas específicas para elementos de texto */
        div,
        span,
        p,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-highlight: none !important;
            -moz-highlight: none !important;
        }

        /* Eliminar el cursor de texto en elementos clickeables */
        .flashcard,
        .back,
        .front {
            cursor: pointer !important;
        }

        /* Sistema de ocultación de cursor para dispositivos móviles */
        @media (max-width: 768px) and (pointer: coarse) {

            /* Ocultar cursor por defecto en dispositivos táctiles */
            *,
            *::before,
            *::after {
                cursor: none !important;
                caret-color: transparent !important;
            }

            /* EXCEPCIÓN: permitir caret y cursor de texto en el campo de entrada */
            .type-input,
            .type-input:focus,
            .keyboard-visible .type-input {
                cursor: text !important;
                caret-color: auto !important;
                -webkit-user-select: text !important;
                -moz-user-select: text !important;
                -ms-user-select: text !important;
                user-select: text !important;
            }

            /* Ocultar cursor en otros elementos interactivos */
            button,
            .button,
            .pill,
            .flashcard,
            a,
            [onclick] {
                cursor: none !important;
            }
        }

        /* Clase para mostrar cursor cuando el teclado virtual está activo */
        .keyboard-visible *,
        .keyboard-visible *::before,
        .keyboard-visible *::after {
            cursor: default !important;
        }

        .keyboard-visible input,
        .keyboard-visible textarea,
        .keyboard-visible [contenteditable] {
            cursor: text !important;
            caret-color: auto !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }

        .keyboard-visible button,
        .keyboard-visible .button,
        .keyboard-visible .pill,
        .keyboard-visible .flashcard,
        .keyboard-visible a,
        .keyboard-visible [onclick] {
            cursor: pointer !important;
        }

        /* Forzar ocultación de cursor cuando no hay teclado */
        .keyboard-hidden *,
        .keyboard-hidden *::before,
        .keyboard-hidden *::after {
            cursor: none !important;
            caret-color: transparent !important;
        }

        .keyboard-hidden input,
        .keyboard-hidden textarea,
        .keyboard-hidden [contenteditable] {
            cursor: none !important;
            caret-color: transparent !important;
        }


        /* Prevenir selección con pseudo-elementos (excepto dentro del input de texto) */
        .back::selection,
        .back *::selection {
            background: transparent !important;
        }

        .back .type-input::selection {
            background: rgba(16, 185, 129, 0.35) !important;
        }

        .back::-moz-selection,
        .back *::-moz-selection {
            background: transparent !important;
        }

        .back .type-input::-moz-selection {
            background: rgba(16, 185, 129, 0.35) !important;
        }

        #flashcard-container-wrapper {
            position: relative;
            width: calc(100% - 20px);
            max-width: 600px;
        }

        #flashcard-container {
            width: 100%;
            height: 500px;
            max-height: 500px;
            perspective: 1000px;
            /* Para el efecto 3D */
            border-radius: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            position: relative;
            background: linear-gradient(to right, #1f3658, #3558e3);
            border: 3px solid #aab0b4;
            margin: 0;
        }

        .flashcard,
        .results-card {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.4, 0.2, 0.2, 1);
            border-radius: 15px;
            cursor: pointer;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;

            /* Prevenir selección de texto en toda la tarjeta */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .flashcard.is-visible {
            display: flex;
        }

        /* Parte frontal y trasera de la tarjeta */
        .front,
        .back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            /* Oculta la cara trasera al girar */
            border-radius: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            pointer-events: auto !important;
        }

        .front {
            width: 100%;
            height: 100%;
            padding: 0;
            border: none;
            background: transparent;
            box-shadow: none;
            font-size: 0;
            border-radius: 0;
            filter: none;
        }

        .card-back {
            transform: rotateY(180deg);
            /* Gira la parte trasera */
        }

        /* Estilo de la parte frontal */
        .front img,
        .back img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: inherit;
            display: block;

            /* Prevenir menú contextual y arrastrar en imágenes */
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-drag: none !important;
            -moz-user-drag: none !important;
            pointer-events: none !important;
        }

        /* Estilo de la parte trasera */
        .back {
            width: 100%;
            /* Fondo moderno con capas: gradientes radiales sutiles + base oscura para máxima legibilidad */
            background:
                radial-gradient(900px 700px at 10% 10%, rgba(99, 102, 241, 0.35), rgba(99, 102, 241, 0) 60%),
                radial-gradient(800px 600px at 90% 90%, rgba(16, 185, 129, 0.28), rgba(16, 185, 129, 0) 55%),
                linear-gradient(135deg, #0f172a 0%, #1e293b 55%, #0b1320 100%);
            color: #ffffff;
            /* Color del texto */
            transform: rotateY(180deg);
            /* Rotación para el efecto */
            padding: 20px;
            /* Margen interno */
            text-align: center;
            /* Centrado horizontal */
            font-size: 3rem;
            /* Tamaño del texto */
            font-family: 'Playfair Display', serif;
            /* Fuente elegante */
            border-radius: 10px;
            /* Bordes redondeados */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            /* Sombra más pronunciada */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            /* Sombra del texto más fuerte */
            display: flex;
            /* Flexbox para el centrado */
            justify-content: center;
            /* Centrar horizontalmente */
            align-items: center;
            /* Centrar verticalmente */
            flex-direction: column;
            /* Asegura que el texto fluya en columnas */
            height: 100%;
            /* Usa toda la altura disponible */
            max-width: 100%;
            /* Limita el ancho máximo */
            margin: 0 auto;
            /* Centra dentro del contenedor */
            line-height: 1.4;
            /* Espaciado entre líneas */

            /* Prevenir selección de texto - Completo */
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-tap-highlight-color: transparent !important;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0) !important;
            -moz-tap-highlight-color: transparent !important;
            outline: none !important;

            /* Prevenir arrastrar */
            -webkit-user-drag: none !important;
            -moz-user-drag: none !important;

            /* Eliminar cualquier outline o focus */
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
        }

        /* Ocultar texto cuando está en modo escucha */
        .back.hidden-text {
            color: transparent;
            text-shadow: none;
        }

        /* Asegurar que el indicador NUNCA se oculte ni herede color transparente */
        .back.hidden-text .super-pulse-indicator {
            color: #fff !important;
            /* Forzar color visible */
            -webkit-text-fill-color: #fff !important;
            /* Safari/iOS */
            opacity: 1 !important;
            display: block !important;
            visibility: visible !important;
        }

        /* Permitir que las letras usen su propio color aunque el contenedor fuerce el fill a blanco */
        .back.hidden-text .super-pulse-indicator .floating-emoji {
            -webkit-text-fill-color: currentColor !important;
            /* usa el color de .e1..e7 */
        }

        /* Asegurar que el emoji del micrófono no herede color transparente */
        .back.hidden-text .mic-emoji {
            color: #fff !important;
            -webkit-text-fill-color: #fff !important;
        }

        /* Indicador de escucha de voz */
        .listening-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 1.5rem;
            text-align: center;
            animation: pulse 1s infinite;
            z-index: 10;
        }

        @keyframes pulse {
            0% {
                opacity: 0.6;
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.05);
            }

            100% {
                opacity: 0.6;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* Contador moderno y elegante */
        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 25px;
        }

        .countdown-number {
            font-size: 8rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            animation: countdownPulse 1s ease-in-out;
            z-index: 1001;
        }

        @keyframes countdownPulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .countdown-circle {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: countdownRotate 1s linear;
        }

        @keyframes countdownRotate {
            0% {
                transform: rotate(0deg) scale(0.8);
                border-color: rgba(255, 255, 255, 0.3);
            }

            50% {
                transform: rotate(180deg) scale(1.1);
                border-color: rgba(255, 255, 255, 0.8);
            }

            100% {
                transform: rotate(360deg) scale(1);
                border-color: rgba(255, 255, 255, 0.5);
            }
        }

        .back::before,
        .back::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            filter: blur(20px);
            opacity: 0.35;
            z-index: 0;
            /* Colocar detrás del contenido */
        }

        /* Glow superior-izquierdo en tonos índigo */
        .back::before {
            width: 65%;
            height: 65%;
            top: -18%;
            left: -18%;
            background: radial-gradient(circle at 40% 40%, rgba(99, 102, 241, 0.55) 0%, rgba(99, 102, 241, 0.15) 45%, rgba(99, 102, 241, 0) 70%);
        }

        /* Glow inferior-derecho en tonos esmeralda */
        .back::after {
            width: 60%;
            height: 60%;
            bottom: -15%;
            right: -15%;
            background: radial-gradient(circle at 60% 60%, rgba(16, 185, 129, 0.5) 0%, rgba(16, 185, 129, 0.18) 40%, rgba(16, 185, 129, 0) 70%);
        }


        /* El efecto de voltear */
        .flashcard.flipped {
            transform: rotateY(180deg);
            /* Al hacer clic, se voltea la tarjeta */
        }

        .button-container {
            width: auto;
            display: flex;
            justify-content: center;
            gap: 12px;
            align-items: center;
            padding: 5px 5px;
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin: 10px auto 0;
            min-width: 280px;
        }


        /* Botones individuales */
        .button {
            width: 40px;
            height: 40px;
            min-width: 40px;
            padding: 0;
            font-size: 20px;
            cursor: pointer;
            border: none;
            border-radius: 50%;
            background-color: #3498db;
            color: #fff;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .button:hover {
            transform: translateY(-3px);
        }

        .button.skip {
            background: #e67e22;
        }

        .button.shuffle {
            background: #9b59b6;
        }

        .button.sound-toggle {
            background: #f0f0f0;
            color: #4b5563;
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12);
        }

        .button.sound-toggle:hover {
            transform: translateY(-2px);
            background: #f7f7f7;
        }

        .button.sound-toggle i {
            font-size: 18px;
        }





        .overlay-text {
            position: absolute;
            z-index: 1;
            /* Colocar por encima del contenido */
            color: white;
            /* Color del texto */
            font-size: 2rem;
            /* Tamaño del texto */
            font-weight: bold;
            /* Texto en negrita */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            /* Sombra del texto */
            text-align: left;
            /* Alineación a la izquierda */
            pointer-events: none;
            /* No interferir con los clics */
            margin: 5%;
            /* Margen relativo */
            line-height: 1.5;
            /* Espaciado entre líneas */
            top: 40%;
            /* Posición específica desde arriba */
            left: 0%;
            /* Posición específica desde la izquierda */
        }

        /* Estilos para .overlay-text1 */
        .overlay-text1 {
            position: absolute;
            top: 5px;
            z-index: 1;
            color: rgb(185, 232, 203);
            /* Color específico */
            font-size: 2rem;
            /* Tamaño del texto */
            font-weight: bold;
            /* Texto en negrita */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            /* Sombra del texto */
            text-align: center;
            /* Centrado */
            pointer-events: none;
            /* No interferir con clics */
            display: inline-block;
            /* Comportamiento inline */
            animation: pulse 1.5s infinite;
            /* Animación pulsante */
        }

        /* Estilos para .overlay-text2 */
        .overlay-text2 {
            position: absolute;
            z-index: 1;
            color: white;
            /* Color del texto */
            font-size: 2rem;
            /* Tamaño del texto */
            font-weight: bold;
            /* Negrita */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            /* Sombra del texto */
            text-align: left;
            /* Alineación a la izquierda */
            pointer-events: none;
            /* No interferir con clics */
            margin: 30px;
            /* Márgenes específicos */
            top: 40%;
            /* Posición específica desde arriba */
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes moveLeftToRight {
            0% {
                transform: translateX(0);
                /* Posición inicial */
            }

            50% {
                transform: translateX(10px);
                /* Mueve hacia la derecha */
            }

            100% {
                transform: translateX(0);
                /* Vuelve a la posición original */
            }
        }



        .back-arrow {
            background: #fff;
            color: #333;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            gap: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .back-arrow:hover {
            background-color: #f5f5f5;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .back-arrow i {
            color: #333;
        }

        .intentos-back {
            position: absolute;
            top: 18px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: #f0e49c;
            z-index: 2;
            pointer-events: none;
        }

        .pill-intentos {
            background: linear-gradient(135deg, #ebac6d 0%, #a88f07 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(255, 78, 80, 0.15);
            border-radius: 20px;
            padding: 2px 2px;
            font-size: 0.9em;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: none;
            margin-bottom: 4px;
        }

        .pill-intentos i {
            font-size: 0.9em;
        }


        @keyframes intentosFlash {
            0% {
                box-shadow: 0 0 0 0 #fff700, 0 2px 6px rgba(255, 78, 80, 0.15);
            }

            50% {
                box-shadow: 0 0 16px 8px #fff700, 0 2px 6px rgba(255, 78, 80, 0.15);
            }

            100% {
                box-shadow: 0 0 0 0 #fff700, 0 2px 6px rgba(255, 78, 80, 0.15);
            }
        }

        .pill-intentos.flash {
            animation: intentosFlash 0.7s;
        }

        /* --- NUEVO EFECTO DE ADVERTENCIA --- */
        @keyframes intentosWarningFlash {
            0% {
                box-shadow: 0 0 0 0 #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15);
            }

            50% {
                box-shadow: 0 0 16px 8px #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15);
            }

            100% {
                box-shadow: 0 0 0 0 #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15);
            }
        }

        .pill-intentos.flash-warning {
            animation: intentosWarningFlash 0.7s;
        }

        .super-pulse-indicator {
            position: absolute !important;
            /* Dentro del lado back */
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            text-align: center;
            z-index: 9999 !important;
            /* Z-index muy alto para estar por encima de todo */
            width: auto;
            pointer-events: none;
            /* Para que no interfiera con los clics */
            display: block !important;
            /* Forzar visibilidad */
            opacity: 1 !important;
            /* Forzar opacidad */
            visibility: visible !important;
            /* Forzar visibilidad */
            /* Asegurar que el tamaño de las letras orbitantes herede desde aquí */
            --letter-size: 1.6rem;
        }

        .super-pulse-container {
            position: relative;
            width: 140px;
            /* más espacio para una órbita segura */
            height: 140px;
            /* más espacio para una órbita segura */
            margin: 0 auto 30px;
            /* separar de mensajes inferiores */
            /* Variables para controlar una órbita estable (tipo luna-tierra) */
            --center-size: 70px;
            /* Tamaño del círculo blanco (pulse-center) */
            --center-scale-max: 1.1;
            /* Escala máxima por animación centerBounce */
            --letter-size: 1.5rem;
            /* Igual que .floating-emoji font-size para cálculo preciso */
            --safety-gap: 16px;
            /* Más separación para asegurar que no invada el círculo */
            /* Radio real de la órbita: mitad del centro (con su escala máxima) + semi ancho de letra + gap */
            --orbit-radius: calc((var(--center-size) * var(--center-scale-max) / 2) + (var(--letter-size) / 2) + var(--safety-gap));
        }

        .pulse-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.8);
        }

        .pulse-ring-1 {
            width: 60px;
            height: 60px;
            animation: superPulseRing 2s infinite ease-out;
            border-color: rgba(255, 215, 0, 0.9);
        }

        .pulse-ring-2 {
            width: 80px;
            height: 80px;
            animation: superPulseRing 2s infinite ease-out;
            animation-delay: 0.5s;
            border-color: rgba(0, 255, 127, 0.7);
        }

        .pulse-ring-3 {
            width: 100px;
            height: 100px;
            animation: superPulseRing 2s infinite ease-out;
            animation-delay: 1s;
            border-color: rgba(255, 69, 0, 0.6);
        }

        .pulse-ring-4 {
            width: 120px;
            height: 120px;
            animation: superPulseRing 2s infinite ease-out;
            animation-delay: 1.5s;
            border-color: rgba(138, 43, 226, 0.5);
        }

        @keyframes superPulseRing {
            0% {
                transform: translate(-50%, -50%) scale(0.3);
                opacity: 1;
                border-width: 4px;
            }

            50% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0.8;
                border-width: 2px;
            }

            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
                border-width: 1px;
            }
        }

        .pulse-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #f8fafc 0%, #e0e7ef 100%);
            background-size: 400% 400%;
            animation: centerGradient 3s ease infinite, centerBounce 1.5s ease-in-out infinite;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            z-index: 10;
            /* Asegura que el mic y el centro estén por encima de la órbita */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(120, 180, 255, 0.25);
        }

        @keyframes centerGradient {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes centerBounce {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.1) rotate(5deg);
            }
        }

        .mic-emoji {
            font-size: 2rem;
            margin-bottom: 0.5px;
            margin-top: 0;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15));
            animation: micWiggle 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes micWiggle {

            0%,
            100% {
                transform: rotate(-3deg);
            }

            50% {
                transform: rotate(3deg);
            }
        }

        .sound-waves {
            display: flex;
            gap: 6px;
            margin-top: 0;
            margin-bottom: 0;
            justify-content: center;
            align-items: center;
        }

        .wave-dot {
            width: 4px;
            height: 4px;
            background: #e0c605;
            border-radius: 50%;
            animation: waveUp 1s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
        }

        .wave-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .wave-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .wave-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes waveUp {

            0%,
            100% {
                transform: translateY(0px) scale(1);
                opacity: 0.7;
            }

            50% {
                transform: translateY(-8px) scale(1.3);
                opacity: 1;
            }
        }

        .floating-emojis {
            position: absolute;
            inset: 0;
            pointer-events: none;
            /* El radio de la órbita se calcula para NO entrar en el círculo central en ningún momento */
            --radius: var(--orbit-radius);
            transform-origin: 50% 50%;
            /* NO hay animación aquí - cada letra orbita individualmente */
            z-index: 4;
            /* por debajo del centro para no tapar el micrófono */
        }

        .floating-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: var(--letter-size, 1.5rem) !important;
            /* vinculado a variable + prioridad para evitar sobrescrituras */
            opacity: 0.9;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            transform-origin: 50% 50%;
            /* rota desde el centro del contenedor */
            -webkit-text-fill-color: currentColor !important;
            /* asegurar que el color de texto real sea el propio */
            /* Cada letra orbita individualmente para mantener el centro fijo */
            animation: letterOrbit 24s linear infinite;
            pointer-events: none;
        }

        /* Refuerzo de especificidad para asegurar que el tamaño cambie en contexto del indicador */
        .super-pulse-indicator .floating-emoji {
            font-size: var(--letter-size, 1.5rem) !important;
        }

        /* Distribución equidistante de E-S-P-A-Ñ-O-L (360/7 ≈ 51.4286°) */
        /* Colores elegantes desde el primer intento */
        .e1 {
            color: #8B5CF6 !important;
            font-weight: 700;
            animation-delay: -6s;
            text-shadow: 0 0 8px rgba(139, 92, 246, 0.4);
        }

        /* E - Púrpura elegante */
        .e2 {
            color: #06B6D4 !important;
            font-weight: 700;
            animation-delay: -9.43s;
            text-shadow: 0 0 8px rgba(6, 182, 212, 0.4);
        }

        /* S - Cian vibrante */
        .e3 {
            color: #F59E0B !important;
            font-weight: 700;
            animation-delay: -12.86s;
            text-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
        }

        /* P - Ámbar dorado */
        .e4 {
            color: #EF4444 !important;
            font-weight: 700;
            animation-delay: -16.29s;
            text-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
        }

        /* A - Rojo coral */
        .e5 {
            color: #10B981 !important;
            font-weight: 700;
            animation-delay: -19.71s;
            text-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }

        /* Ñ - Esmeralda */
        .e6 {
            color: #3B82F6 !important;
            font-weight: 700;
            animation-delay: -23.14s;
            text-shadow: 0 0 8px rgba(59, 130, 246, 0.4);
        }

        /* O - Azul real */
        .e7 {
            color: #EC4899 !important;
            font-weight: 700;
            animation-delay: -2.57s;
            text-shadow: 0 0 8px rgba(236, 72, 153, 0.4);
        }

        /* L - Rosa magenta */

        /* Se eliminan bailes individuales para que todos giren en la misma órbita */

        /* Órbita individual de cada letra manteniendo el centro fijo */
        @keyframes letterOrbit {
            0% {
                transform: translate(-50%, -50%) rotate(0deg) translateX(var(--radius)) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg) translateX(var(--radius)) rotate(-360deg);
            }
        }

        /* Animación anterior mantenida por compatibilidad */
        @keyframes slowOrbit {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes floatAround {

            0%,
            100% {
                transform: translateY(0px) translateX(0px) rotate(0deg) scale(1);
                opacity: 0.6;
            }

            25% {
                transform: translateY(-15px) translateX(10px) rotate(90deg) scale(1.2);
                opacity: 1;
            }

            50% {
                transform: translateY(-10px) translateX(-5px) rotate(180deg) scale(0.9);
                opacity: 0.8;
            }

            75% {
                transform: translateY(-20px) translateX(15px) rotate(270deg) scale(1.1);
                opacity: 1;
            }
        }

        @keyframes floatAroundE3 {

            0%,
            100% {
                transform: translateY(0px) translateX(0px) rotate(0deg) scale(1);
                opacity: 0.7;
            }

            25% {
                transform: translateY(-1px) translateX(20px) rotate(20deg) scale(1.1);
                opacity: 1;
            }

            50% {
                transform: translateY(1px) translateX(15px) rotate(40deg) scale(1.05);
                opacity: 0.9;
            }

            75% {
                transform: translateY(0px) translateX(-10px) rotate(10deg) scale(1.1);
                opacity: 1;
            }
        }

        .super-pulse-text {
            color: #fff;
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 2px 4px rgba(0, 0, 0, 0.5);
            animation: textGlow 2s ease-in-out infinite;
        }

        @keyframes textGlow {

            0%,
            100% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 2px 4px rgba(0, 0, 0, 0.5);
                transform: scale(1);
            }

            50% {
                text-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 0 30px rgba(255, 215, 0, 0.8), 0 2px 4px rgba(0, 0, 0, 0.5);
                transform: scale(1.02);
            }
        }

        .super-pulse-subtitle {
            color: #ffeb3b;
            font-size: 1.1rem;
            font-weight: 600;
            animation: subtitleSlide 4s ease-in-out infinite;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .super-pulse-subtitle {
            color: #ffeb3b;
            font-size: 1.05rem;
            font-weight: 600;
            /* mismo peso visual que el segundo intento */
            animation: subtitleSlide 4s ease-in-out infinite;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            margin-top: 6px;
        }

        /* Forzar que el subtítulo mantenga su color amarillo en cualquier intento */
        .super-pulse-indicator .super-pulse-subtitle {
            color: #ffeb3b !important;
            -webkit-text-fill-color: #ffeb3b !important;
            /* Safari/iOS */
        }

        /* Si el back está en hidden-text, mantener el color del subtítulo */
        .back.hidden-text .super-pulse-indicator .super-pulse-subtitle {
            color: #ffeb3b !important;
            -webkit-text-fill-color: #ffeb3b !important;
        }

        @keyframes subtitleSlide {

            0%,
            100% {
                transform: translateX(0px);
                opacity: 0.8;
            }

            25% {
                transform: translateX(5px);
                opacity: 1;
            }

            50% {
                transform: translateX(-5px);
                opacity: 0.9;
            }

            75% {
                transform: translateX(3px);
                opacity: 1;
            }
        }

        .back .super-pulse-indicator {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            z-index: 999 !important;
            width: auto !important;
            height: auto !important;
        }

        .super-pulse-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 25px;
            z-index: 1000;
        }

        /* Añade esto en tu sección de estilos */
        @keyframes fadeInOut {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }

            20% {
                opacity: 1;
                transform: scale(1.1) translateY(0);
            }

            80% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }

            100% {
                opacity: 0;
                transform: scale(0.8) translateY(-20px);
            }
        }

        @keyframes modernFadeInOut {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
                filter: blur(2px);
            }

            15% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.05);
                filter: blur(0px);
            }

            85% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
                filter: blur(0px);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
                filter: blur(1px);
            }
        }

        .mensaje-error {
            position: absolute;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            font-size: 2rem;
            font-weight: bold;
            color: #ff6b6b;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5),
                0 0 20px rgba(255, 107, 107, 0.3),
                0 0 30px rgba(255, 107, 107, 0.2);
            z-index: 1000;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 107, 107, 0.05) 100%);
            padding: 20px 40px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 107, 107, 0.2);
            animation: errorAppearNew 0.5s ease-out, errorDisappearNew 0.5s ease-in 1.5s forwards;
        }

        @keyframes errorAppearNew {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) perspective(500px) rotateX(-45deg);
                filter: brightness(2);
            }

            50% {
                transform: translate(-50%, -50%) perspective(500px) rotateX(5deg);
                filter: brightness(1.5);
            }

            100% {
                opacity: 1;
                transform: translate(-50%, -50%) perspective(500px) rotateX(0);
                filter: brightness(1);
            }
        }

        @keyframes errorDisappearNew {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
                filter: brightness(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.1);
                filter: brightness(1.2);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
                filter: brightness(0);
            }
        }

        @keyframes respuestaGlow {

            0%,
            100% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                    0 0 20px rgba(255, 255, 255, 0.3);
                transform: scale(1);
            }

            50% {
                text-shadow: 0 0 15px rgba(255, 255, 255, 0.8),
                    0 0 25px rgba(255, 255, 255, 0.5),
                    0 0 35px rgba(255, 255, 255, 0.3);
                transform: scale(1.05);
            }
        }

        .button:hover {
            transform: translateY(-3px);
        }

        .button:disabled {
            background-color: #bdc3c7;
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .overlay-text {
            position: absolute;
        }

        @keyframes errorGlow {
            0% {
                box-shadow: 0 0 0 0 #ff3b3b, 0 2px 6px rgba(220, 53, 69, 0.15);
                background: linear-gradient(135deg, #ff3b3b 0%, #c82333 100%);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 24px 12px #ff3b3b, 0 2px 16px rgba(220, 53, 69, 0.25);
                background: linear-gradient(135deg, #ff3b3b 40%, #ffb3b3 100%);
                transform: scale(1.08);
            }

            100% {
                box-shadow: 0 0 0 0 #ff3b3b, 0 2px 6px rgba(220, 53, 69, 0.15);
                background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
                transform: scale(1);
            }
        }

        .pill-incorrectas.glow-error {
            animation: errorGlow 0.7s;
        }

        @keyframes correctGlow {
            0% {
                box-shadow: 0 0 0 0 #00e676, 0 2px 6px rgba(40, 167, 69, 0.15);
                background: linear-gradient(135deg, #00e676 0%, #218838 100%);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 24px 12px #00e676, 0 2px 16px rgba(40, 167, 69, 0.25);
                background: linear-gradient(135deg, #00e676 40%, #b9f6ca 100%);
                transform: scale(1.08);
            }

            100% {
                box-shadow: 0 0 0 0 #00e676, 0 2px 6px rgba(40, 167, 69, 0.15);
                background: linear-gradient(135deg, #28a745 0%, #218838 100%);
                transform: scale(1);
            }
        }

        .pill-correctas.glow-correct {
            animation: correctGlow 0.7s;
        }

        @keyframes faltanGlow {
            0% {
                box-shadow: 0 0 0 0 #ffb347, 0 2px 6px rgba(255, 107, 53, 0.15);
                background: linear-gradient(135deg, #ffb347 0%, #f7931e 100%);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 24px 12px #ffb347, 0 2px 16px rgba(255, 107, 53, 0.25);
                background: linear-gradient(135deg, #ffb347 40%, #fff3cd 100%);
                transform: scale(1.08);
            }

            100% {
                box-shadow: 0 0 0 0 #ffb347, 0 2px 6px rgba(255, 107, 53, 0.15);
                background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
                transform: scale(1);
            }
        }

        .pill-faltan.glow-faltan {
            animation: faltanGlow 0.7s;
        }

        .flashcard.transition-out {
            animation: cardSlideUp 0.5s forwards;
            z-index: 2;
        }

        .flashcard.transition-in {
            animation: cardSlideIn 0.5s forwards;
            z-index: 3;
        }

        @keyframes cardSlideUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateY(-120%) scale(0.95);
                opacity: 0;
            }
        }

        @keyframes cardSlideIn {
            0% {
                transform: translateY(120%) scale(0.95);
                opacity: 0;
            }

            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .countdown-inline {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 300px;
            animation: fadeInOut 4s;
            z-index: 1;
            position: relative;
        }

        .countdown-inline-circle {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4 0%, #3558e3 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            box-shadow: 0 4px 16px rgba(78, 205, 196, 0.18);
            border: 3px solid #fff;
        }

        .countdown-inline-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.18);
            letter-spacing: 1px;
        }

        .countdown-inline-text {
            font-size: 1.1rem;
            color: #e0e7ef;
            margin-top: 2px;
            font-weight: 500;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
        }

        .pulse-timer {
            animation: pulse 1s;
        }

        .flashcard.transition-out {
            animation: cardSlideLeft 0.5s forwards;
            z-index: 2;
        }

        .flashcard.transition-in {
            animation: cardSlideFromRight 0.5s forwards;
            z-index: 3;
        }

        @keyframes cardSlideLeft {
            0% {
                transform: translateX(0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateX(-120%) scale(0.95);
                opacity: 0;
            }
        }

        @keyframes cardSlideFromRight {
            0% {
                transform: translateX(120%) scale(0.95);
                opacity: 0;
            }

            100% {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes bounce {

            0%,
            20%,
            50%,
            80%,
            100% {
                transform: translateY(0);
            }

            40% {
                transform: translateY(-20px);
            }

            60% {
                transform: translateY(-10px);
            }
        }

        /* === ANIMACIONES DE EUFORIA (Alegres y eufóricas) === */
        /* Nueva animación eufórica simplificada */
        @keyframes euforicaPop {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.3);
                background: linear-gradient(135deg, #ff9ff3, #f368e0);
            }

            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(-10px) scale(1.15);
                background: linear-gradient(135deg, #54a0ff, #5f27cd);
            }

            40% {
                transform: translateX(-50%) translateY(0px) scale(1.05);
                background: linear-gradient(135deg, #00d2d3, #01a3a4);
            }

            60% {
                transform: translateX(-50%) translateY(-5px) scale(1.02);
                background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            }

            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0px) scale(1);
                background: linear-gradient(135deg, #05c46b, #0be881);
            }
        }

        /* Animación para respuesta incorrecta */
        @keyframes errorShake {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(10px) scale(0.5);
            }

            20% {
                opacity: 1;
                transform: translateX(-60%) translateY(0px) scale(1.1);
            }

            40% {
                transform: translateX(-40%) translateY(0px) scale(1.05);
            }

            60% {
                transform: translateX(-55%) translateY(0px) scale(1.02);
            }

            80% {
                transform: translateX(-45%) translateY(0px) scale(1.01);
            }

            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0px) scale(1);
            }
        }

        /* Animación triste para respuesta correcta después de dos intentos fallidos */
        @keyframes tristeSlowFade {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(30px) scale(0.7);
                background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
            }

            40% {
                opacity: 0.5;
                transform: translateX(-50%) translateY(15px) scale(0.85);
                background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
            }

            70% {
                opacity: 0.8;
                transform: translateX(-50%) translateY(5px) scale(0.95);
                background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
            }

            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0px) scale(1);
                background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
            }
        }

        @keyframes celebrationBounce {

            0%,
            20%,
            50%,
            80%,
            100% {
                transform: translateX(-50%) translateY(0) scale(1);
            }

            10% {
                transform: translateX(-50%) translateY(-20px) scale(1.1);
            }

            30% {
                transform: translateX(-50%) translateY(-10px) scale(1.05);
            }

            60% {
                transform: translateX(-50%) translateY(-15px) scale(1.08);
            }

            90% {
                transform: translateX(-50%) translateY(-5px) scale(1.02);
            }
        }

        @keyframes euforiaWiggle {

            0%,
            100% {
                transform: rotate(0deg) scale(1);
            }

            25% {
                transform: rotate(5deg) scale(1.05);
            }

            50% {
                transform: rotate(0deg) scale(1.1);
            }

            75% {
                transform: rotate(-5deg) scale(1.05);
            }
        }

        @keyframes happyFloat {

            0%,
            100% {
                transform: translateY(0px) scale(1);
                opacity: 0.9;
            }

            50% {
                transform: translateY(-15px) scale(1.02);
                opacity: 1;
            }
        }

        @keyframes sparkle {

            0%,
            100% {
                opacity: 0.8;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }

        /* === ANIMACIONES DE PÉRDIDA (Tristes y desanimadas) === */
        @keyframes sadFadeIn {
            0% {
                opacity: 0;
                transform: scale(1.2);
                filter: brightness(0.3);
            }

            100% {
                opacity: 1;
                transform: scale(1);
                filter: brightness(1);
            }
        }

        @keyframes sadDrop {
            0% {
                transform: translateY(0px) rotate(0deg);
            }

            20% {
                transform: translateY(10px) rotate(-2deg);
            }

            40% {
                transform: translateY(5px) rotate(1deg);
            }

            60% {
                transform: translateY(8px) rotate(-1deg);
            }

            80% {
                transform: translateY(3px) rotate(0.5deg);
            }

            100% {
                transform: translateY(0px) rotate(0deg);
            }
        }

        @keyframes disappointedSway {

            0%,
            100% {
                transform: rotate(0deg) translateX(0px);
            }

            33% {
                transform: rotate(-2deg) translateX(-5px);
            }

            66% {
                transform: rotate(2deg) translateX(5px);
            }
        }

        @keyframes gentleFloat {

            0%,
            100% {
                transform: translateY(0px);
                opacity: 0.9;
            }

            50% {
                transform: translateY(-8px);
                opacity: 0.7;
            }
        }

        @keyframes fadingHope {

            0%,
            100% {
                opacity: 0.8;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* === ANIMACIONES DE EMPATE (Neutrales y equilibradas) === */
        @keyframes neutralZoom {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes balanceSway {

            0%,
            100% {
                transform: rotate(-8deg);
            }

            50% {
                transform: rotate(8deg);
            }
        }

        @keyframes steadyPulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.03);
                opacity: 0.95;
            }
        }

        @keyframes calmWave {

            0%,
            100% {
                transform: translateY(0px) translateX(0px);
            }

            33% {
                transform: translateY(-5px) translateX(3px);
            }

            66% {
                transform: translateY(0px) translateX(-3px);
            }
        }

        @keyframes steadyGlow {

            0%,
            100% {
                opacity: 0.8;
            }

            50% {
                opacity: 1;
            }
        }

        /* === ANIMACIONES DE EUFORIA MÁXIMA (Perfecto) === */
        @keyframes rainbowBackground {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes perfectEntrance {
            0% {
                opacity: 0;
                transform: scale(0.1) rotate(720deg);
                filter: brightness(3);
            }

            50% {
                transform: scale(1.3) rotate(360deg);
                filter: brightness(2);
            }

            100% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
        }

        @keyframes perfectExplosion {

            0%,
            100% {
                transform: translateY(0) rotate(0deg) scale(1);
                filter: drop-shadow(0 0 20px gold);
            }

            25% {
                transform: translateY(-40px) rotate(90deg) scale(1.4);
                filter: drop-shadow(0 0 40px gold);
            }

            50% {
                transform: translateY(-20px) rotate(180deg) scale(1.2);
                filter: drop-shadow(0 0 60px gold);
            }

            75% {
                transform: translateY(-30px) rotate(270deg) scale(1.3);
                filter: drop-shadow(0 0 40px gold);
            }
        }

        @keyframes perfectShine {

            0%,
            100% {
                text-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 40px gold, 0 0 60px gold;
                transform: scale(1);
            }

            50% {
                text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 60px gold, 0 0 80px gold, 0 0 100px gold;
                transform: scale(1.1);
            }
        }

        @keyframes goldenGlow {

            0%,
            100% {
                transform: translateY(0px) scale(1);
                opacity: 0.95;
                color: #FFD700;
            }

            50% {
                transform: translateY(-10px) scale(1.05);
                opacity: 1;
                color: #FFA500;
            }
        }

        @keyframes diamondSpark {

            0%,
            100% {
                opacity: 0.9;
                transform: scale(1) rotate(0deg);
                color: #E6E6FA;
            }

            25% {
                opacity: 1;
                transform: scale(1.1) rotate(5deg);
                color: #FFD700;
            }

            50% {
                opacity: 1;
                transform: scale(1.05) rotate(-5deg);
                color: #FF69B4;
            }

            75% {
                opacity: 1;
                transform: scale(1.1) rotate(3deg);
                color: #00CED1;
            }
        }

        /* Animación alternante para botones */
        @keyframes alternatePulse {

            0%,
            50% {
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(0, 200, 81, 0.2);
            }

            25% {
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(0, 200, 81, 0.4);
            }
        }

        @keyframes alternatePulseIncorrect {

            0%,
            50% {
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(255, 87, 34, 0.2);
            }

            75% {
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(255, 87, 34, 0.4);
            }
        }

        /* === ESTILOS PARA MODALES MODERNOS DE PALABRAS === */
        @keyframes fadeInOverlay {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes expandToFullscreen {
            from {
                width: 400px;
                height: 500px;
                border-radius: 25px;
            }

            to {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
            }
        }

        @keyframes slideInModal {
            from {
                transform: translateY(-30px) scale(0.95);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes wordCardFadeIn {
            from {
                transform: translateY(10px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 640px;
            width: min(90%, 640px);
            max-height: 90vh;
            overflow: hidden;
            animation: slideInModal 0.4s ease-out;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-header {
            padding: 30px 30px 20px;
            text-align: center;
            position: relative;
        }

        .modal-title-row {
            margin-bottom: 8px;
        }

        .modal-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin: 0;
            color: #1f2937;
            letter-spacing: -0.5px;
            text-decoration: underline;
            text-decoration-thickness: 2px;
            text-underline-offset: 4px;
        }

        .correct-modal .modal-title {
            text-decoration-color: #10b981;
        }

        .incorrect-modal .modal-title {
            text-decoration-color: #ef4444;
        }

        .modal-stats {
            font-size: 0.95rem;
            color: #6b7280;
            font-weight: 500;
        }

        .modal-content {
            padding: 0 30px 20px;
            max-height: 50vh;
            overflow-y: auto;
        }

        .words-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }

        @media (min-width: 960px) {
            .words-container {
                grid-template-columns: repeat(2, minmax(220px, 1fr));
                column-gap: 22px;
            }
        }

        .word-card {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.2s ease;
            animation: wordCardFadeIn 0.3s ease-out;
            animation-fill-mode: both;
        }

        .word-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .correct-word {
            border-left: 4px solid #10b981;
        }

        .incorrect-word {
            border-left: 4px solid #ef4444;
        }

        .word-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            flex: 1;
        }

        /* Resultados finales: tarjetas con número + palabra */
        .result-word-card {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 18px;
            border-radius: 16px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.12);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .result-word-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(15, 23, 42, 0.2);
        }

        .result-word-card.correct-result-card {
            border-left: 4px solid #10b981;
        }

        .result-word-card.incorrect-result-card {
            border-left: 4px solid #ef4444;
        }

        .result-word-text {
            font-size: 1.3rem;
            font-weight: 600;
            color: #111827;
        }

        .result-word-action {
            width: 42px;
            height: 42px;
            border-radius: 21px;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #fff;
            font-size: 1.2rem;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 18px rgba(239, 68, 68, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .result-word-card:hover .result-word-action {
            transform: translateZ(0) scale(1.05);
        }

        .word-checkmark {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            margin-left: 12px;
        }

        .correct-word .word-checkmark {
            background: #10b981;
            color: white;
        }

        .incorrect-word .word-checkmark {
            background: #ef4444;
            color: white;
        }

        .no-words-message {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }

        .no-words-icon {
            font-size: 3rem;
            display: block;
            margin-bottom: 16px;
        }

        .no-words-message p {
            font-size: 1.1rem;
            font-weight: 500;
            margin: 0;
        }

        .modal-footer {
            padding: 20px 30px 30px;
            text-align: center;
        }

        .modal-close-btn {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            border: none;
            color: white;
            padding: 14px 32px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
            min-width: 120px;
        }

        .modal-close-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(99, 102, 241, 0.4);
        }

        .modal-close-btn:active {
            transform: translateY(0);
        }

        .correct-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .correct-btn:hover {
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .incorrect-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .incorrect-btn:hover {
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        /* === DIALOGO DE ESCRITURA EN BACK === */
        .type-dialog-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 78%;
            max-width: 410px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 16px;
            padding: 5px 16px 5px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
            z-index: 1000;
            /* Centra los elementos inline como los botones sin contenedor */
            text-align: center;
            /* Evita espacio extra entre líneas de elementos inline (botones) */
            line-height: 0;
        }

        /* Restablecer line-height en bloques internos para no afectar su texto */
        .type-dialog-container .type-input-row,
        .type-dialog-container .check-button-row,
        .type-dialog-container .type-message,
        .type-dialog-container .type-word-title {
            line-height: normal;
        }

        .type-message {
            position: absolute;
            top: -56px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 16px;
            border-radius: 12px;
            font-weight: 800;
            letter-spacing: .5px;
            white-space: nowrap;
            z-index: 5;
        }

        .type-message.success {
            color: #fff;
            background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
            animation: euforiaEntrance .6s ease-out, celebrationBounce 1.8s ease-in-out 1;
            box-shadow: 0 0 20px rgba(255, 255, 255, .4), 0 0 40px rgba(255, 0, 128, .25);
        }

        .type-message.error {
            color: #ff6b6b;
            background: rgba(255, 255, 255, 0.12);
            border: 2px solid rgba(255, 107, 107, 0.45);
            animation: errorAppearNew .4s ease-out;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
        }

        /* Título visible con la palabra objetivo (se muestra solo al acertar) */
        .type-word-title {
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 10px 16px;
            border-radius: 14px;
            font-size: 1.8rem;
            font-weight: 900;
            color: #fff;
            background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15), 0 0 20px rgba(255, 255, 255, .22);
            letter-spacing: .5px;
            text-align: center;
            pointer-events: none;
            white-space: nowrap;
        }

        /* Animación eufórica simplificada */
        .type-word-title.success {
            animation: euforicaPop 1.2s ease-out;
            box-shadow: 0 0 20px rgba(255, 255, 255, .4), 0 0 40px rgba(255, 0, 128, .25);
        }

        /* Estilo para respuesta incorrecta */
        .type-word-title.error-response {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: #fff;
            animation: errorShake 0.6s ease-out;
            box-shadow: 0 0 20px rgba(255, 107, 107, .4), 0 0 30px rgba(238, 90, 36, .25);
        }

        /* Estilo para respuesta correcta después de dos intentos fallidos */
        .type-word-title.sad-correct {
            animation: tristeSlowFade 1.2s ease-out;
            box-shadow: 0 0 20px rgba(255, 255, 255, .4), 0 0 40px rgba(255, 0, 128, .25);
        }

        .type-input-row {
            display: flex;
            width: 100%;
            margin-bottom: 4px;
            /* un poquito arriba respecto a los botones */
        }

        .special-chars {
            /* Ya no se usa: los botones se insertan sin contenedor */
            display: none !important;
        }

        .check-button-row {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            margin-top: 8px;
            /* 2px exactos respecto a los botones */
        }

        .char-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 10px 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 44px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            /* Sin contenedor: hacerlos inline y espaciados */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin: 0 6px 0;
            /* sin margen vertical: el gap superior lo da .type-input-row y abajo lo controla .check-button-row */
            vertical-align: top;
            /* Evita gaps por alineación de baseline */
            line-height: 1;
            /* Asegura altura correcta del contenido del botón */
        }

        /* Asegurar que el primer botón tras la fila del input no tenga margen superior */
        .type-input-row+.char-btn {
            margin-top: 0;
        }

        .char-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .char-btn:hover {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(6, 182, 212, 0.25));
            border-color: rgba(16, 185, 129, 0.6);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1);
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .char-btn:hover::before {
            left: 100%;
        }

        .char-btn:active {
            transform: translateY(-1px) scale(1.02);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.4), rgba(6, 182, 212, 0.35));
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3), inset 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.1s ease;
        }

        .char-btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3), 0 6px 20px rgba(16, 185, 129, 0.15);
        }

        /* Mostrar los botones de caracteres solo en PC */
        @media (max-width: 1024px),
        (pointer: coarse) {
            .char-btn {
                display: none !important;
            }
        }

        .type-input {
            flex: 1;
            font-size: 1.35rem;
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            background: rgba(0, 0, 0, 0.25);
            color: #fff;
            outline: none;
            /* Permitir selección y edición precisa aunque haya reglas globales que la bloqueen */
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
            caret-color: auto !important;
        }

        .type-input[readonly] {
            cursor: text;
            /* Opcional: mantiene el cursor de texto para indicar que es un campo de entrada */
        }

        .type-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Ocultar placeholder cuando el input tiene foco (mostrar solo el caret) */
        .type-input:focus::placeholder {
            color: transparent;
            opacity: 0;
        }

        .type-input:focus::-webkit-input-placeholder {
            color: transparent;
            opacity: 0;
        }

        .type-input:focus::-moz-placeholder {
            color: transparent;
            opacity: 0;
        }

        .type-input:focus:-ms-input-placeholder {
            color: transparent;
            opacity: 0;
        }

        .type-input:focus::-ms-input-placeholder {
            color: transparent;
            opacity: 0;
        }

        /* Animación de error para input vacío */
        .type-input.input-error-empty {
            background: rgba(220, 53, 69, 0.3);
            border-color: #dc3545;
            animation: inputErrorShake 0.6s ease-in-out;
            box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.3);
        }

        .type-input.input-error-empty::placeholder {
            color: rgba(255, 255, 255, 0.9);
            animation: placeholderPulse 1s ease-in-out infinite;
        }

        /* Rehabilitar el color de selección dentro del input aunque .back lo anule */
        .back .type-input::selection {
            background: rgba(16, 185, 129, 0.35) !important;
            color: #fff !important;
        }

        .back .type-input::-moz-selection {
            background: rgba(16, 185, 129, 0.35) !important;
            color: #fff !important;
        }

        @keyframes inputErrorShake {

            0%,
            100% {
                transform: translateX(0);
            }

            15% {
                transform: translateX(-5px);
            }

            30% {
                transform: translateX(5px);
            }

            45% {
                transform: translateX(-3px);
            }

            60% {
                transform: translateX(3px);
            }

            75% {
                transform: translateX(-1px);
            }

            90% {
                transform: translateX(1px);
            }
        }

        @keyframes placeholderPulse {

            0%,
            100% {
                opacity: 0.9;
            }

            50% {
                opacity: 0.6;
            }
        }

        .check-button {
            background: linear-gradient(135deg, #4ecdc4, #3558e3);
            border: none;
            color: white;
            padding: 14px 32px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            /* Sombra más marcada para sensación de botón elevado */
            box-shadow: 0 8px 24px rgba(53, 88, 227, 0.45), 0 2px 8px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(53, 88, 227, 0.35);
            transition: transform .15s ease, box-shadow .2s ease, filter .2s ease;
            min-width: 200px;
        }

        .check-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 28px rgba(53, 88, 227, 0.55), 0 4px 10px rgba(0, 0, 0, 0.14);
        }

        .check-button:active {
            transform: translateY(0);
            /* Ligeramente más "hundido" al hacer click */
            box-shadow: 0 4px 12px rgba(53, 88, 227, 0.40), inset 0 2px 8px rgba(0, 0, 0, 0.18);
        }

        .no-duplicate-button {
            background-color: #e67e22;
            border: none;
            color: white;
            padding: 14px 24px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(230, 126, 34, 0.35);
            transition: transform .15s ease, box-shadow .2s ease;
            margin-left: 12px;
            /* Ocultar en PC/Desktop */
            display: none;
        }

        .no-duplicate-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(230, 126, 34, 0.5);
            background-color: #d35400;
        }

        .no-duplicate-button:active {
            transform: translateY(0);
        }

        .no-duplicate-button.button-pressed {
            animation: buttonPress 0.3s ease;
            background-color: #d35400;
        }

        .check-button.button-pressed {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(1px) scale(0.98);
            box-shadow: 0 2px 8px rgba(53, 88, 227, 0.6);
            transition: all 0.1s ease;
        }



        .check-button-row {
            justify-content: center;
            align-items: center;
        }

        /* En móviles, ocultar botones de caracteres especiales (teclado virtual los cubre) */
        .special-chars {
            display: none !important;
        }


        /* Animación para la aparición del botón */
        @keyframes slideInFromRight {
            0% {
                opacity: 0;
                transform: translateX(20px);
            }

            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }



        .check-button-row {
            justify-content: center;
            align-items: center;
        }


        /* Animación para la aparición del botón */
        @keyframes slideInFromRight {
            0% {
                opacity: 0;
                transform: translateX(20px);
            }

            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .type-input-container {
            position: relative;
            width: 100%;
            display: flex;
            align-items: center;
        }

        .type-input-container .type-input {
            width: 100%;
            padding-right: 45px;
            /* Espacio para el botón clear */
        }

        .clear-button-inside {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #1e3a8a, #1e40af);
            border: 1px solid rgba(30, 58, 138, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 0.9rem;
            padding: 5px 7px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 30px;
            height: 30px;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(30, 58, 138, 0.3);
        }

        .clear-button-inside:hover {
            background: linear-gradient(135deg, #1e40af, #2563eb);
            border-color: rgba(30, 58, 138, 0.4);
            color: #fff;
            box-shadow: 0 4px 12px rgba(30, 58, 138, 0.4);
            transform: translateY(-50%) translateY(-1px) scale(1.02);
        }

        .clear-button-inside:active {
            background: linear-gradient(135deg, #1e3a8a, #1d4ed8);
            transform: translateY(-50%) scale(0.98);
            box-shadow: 0 2px 6px rgba(30, 58, 138, 0.5);
        }

        /* Animación escalonada para las tarjetas de palabras */
        .word-card:nth-child(1) {
            animation-delay: 0s;
        }

        .word-card:nth-child(2) {
            animation-delay: 0.05s;
        }

        .word-card:nth-child(3) {
            animation-delay: 0.1s;
        }

        .word-card:nth-child(4) {
            animation-delay: 0.15s;
        }

        .word-card:nth-child(5) {
            animation-delay: 0.2s;
        }

        .word-card:nth-child(6) {
            animation-delay: 0.25s;
        }

        .word-card:nth-child(7) {
            animation-delay: 0.3s;
        }

        .word-card:nth-child(8) {
            animation-delay: 0.35s;
        }

        /* === ESTILOS PARA MODAL DE BANDERA === */
        .flag-card-container {
            width: 100%;
            height: 500px;
            max-height: 500px;
            max-width: 400px;
            background: linear-gradient(to right, #1f3658, #3558e3);
            border-radius: 25px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            border: 3px solid #aab0b4;
            overflow: hidden;
            position: relative;
            animation: slideInModal 0.4s ease-out;
            display: flex;
            flex-direction: column;
        }

        .flag-controls-floating {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .flag-control-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #374151;
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
        }

        .flag-control-btn:hover {
            background: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .flag-control-btn.close-btn {
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border-color: rgba(239, 68, 68, 0.3);
        }

        .flag-control-btn.close-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: translateY(-2px) scale(1.05);
        }

        .flag-card-body-full {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            overflow: hidden;
            position: relative;
            border-radius: 0 0 22px 22px;
        }

        .flag-display {
            width: 100%;
            height: 100%;
            border-radius: 0 0 22px 22px;
            box-shadow: none;
            border: none;
            transition: all 0.3s ease;
            display: block;
        }

        /* Responsive design para modal de bandera */
        @media (max-width: 480px) {
            .flag-card-container {
                width: 100%;
                height: 550px;
                max-height: 550px;
                max-width: 400px;
                margin: 10px;
                border-radius: 25px;
                border: 3px solid #aab0b4;
                background: linear-gradient(to right, #1f3658, #3558e3);
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .flag-controls-floating {
                top: 10px;
                right: 10px;
                gap: 6px;
            }

            .flag-card-body-full {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
                overflow: hidden;
                position: relative;
                border-radius: 0 0 22px 22px;
            }

            .flag-display {
                width: 100%;
                height: 100%;
                border-radius: 0 0 22px 22px;
                box-shadow: none;
                border: none;
                transition: all 0.3s ease;
                display: block;
            }

            .flag-control-btn {
                width: 36px;
                height: 36px;
                border-radius: 10px;
            }

            /* Ocultar el botón de pantalla completa en móviles */
            .fullscreen-btn {
                display: none !important;
            }
        }

        .flag-modal {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            animation: slideInModal 0.4s ease-out;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .flag-header {
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.9));
        }

        .flag-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
            color: #1f2937;
            letter-spacing: -0.3px;
        }

        .flag-close-btn {
            background: rgba(239, 68, 68, 0.1);
            border: none;
            color: #ef4444;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .flag-close-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: scale(1.1);
        }

        .flag-content {
            padding: 30px;
            text-align: center;
            background: linear-gradient(135deg, #f8fafc, #f1f5f9);
        }

        .flag-image {
            max-width: 100%;
            height: auto;
            max-height: 300px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        .flag-image:hover {
            transform: scale(1.02);
        }

        /* Cursor pointer para las tarjetas clickeables */
        .word-card {
            cursor: pointer;
        }

        .word-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        /* Responsive design para modal de bandera */
        @media (max-width: 480px) {
            .flag-modal {
                width: 95%;
                margin: 10px;
            }

            .flag-header {
                padding: 15px 20px;
            }

            .flag-content {
                padding: 20px;
            }

            .flag-title {
                font-size: 1.3rem;
            }

            .flag-image {
                max-height: 200px;
            }
        }

        /* === ESTILOS PARA OVERLAY DE CONECTIVIDAD === */
        .connectivity-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, rgba(220, 38, 51, 0.95) 0%, rgba(153, 27, 39, 0.98) 100%);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease-in-out;
            color: white;
            font-family: Arial, sans-serif;
            padding: 20px;
            box-sizing: border-box;
        }

        .connectivity-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .connectivity-content {
            text-align: center;
            max-width: 600px;
            animation: connectivityPulse 2s ease-in-out infinite;
        }

        .connectivity-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            display: block;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: disconnectedBlink 1.5s ease-in-out infinite;
        }

        .connectivity-title {
            font-size: 2rem;
            font-weight: bold;
            margin: 0 0 15px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            letter-spacing: -0.5px;
        }

        .connectivity-message {
            font-size: 1.2rem;
            margin: 0 0 30px 0;
            line-height: 1.5;
            opacity: 0.9;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .connectivity-status {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px 20px;
            border-radius: 50px;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            font-weight: 600;
            border: 2px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 25px;
            animation: statusPulse 2s ease-in-out infinite;
        }

        .connectivity-loading-dots {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 20px;
        }

        .connectivity-dot {
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            animation: dotBounce 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        .connectivity-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .connectivity-dot:nth-child(2) {
            animation-delay: 0.3s;
        }

        .connectivity-dot:nth-child(3) {
            animation-delay: 0.6s;
        }

        .connectivity-retry-section {
            margin-top: 25px;
        }

        .connectivity-retry-btn {
            background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);
            color: #dc3545;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px 25px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
        }

        .connectivity-retry-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #ffffff 0%, #f1f3f4 100%);
        }

        .connectivity-retry-btn:active {
            transform: translateY(0);
        }

        .connectivity-retry-btn.checking {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        /* Animaciones para el overlay de conectividad */
        @keyframes connectivityPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }
        }

        @keyframes disconnectedBlink {

            0%,
            50%,
            100% {
                opacity: 1;
                transform: rotate(0deg);
            }

            25% {
                opacity: 0.5;
                transform: rotate(-5deg);
            }

            75% {
                opacity: 0.7;
                transform: rotate(5deg);
            }
        }

        @keyframes statusPulse {

            0%,
            100% {
                border-color: rgba(255, 255, 255, 0.2);
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
            }

            50% {
                border-color: rgba(255, 255, 255, 0.5);
                box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
            }
        }

        @keyframes dotBounce {

            0%,
            100% {
                transform: translateY(0px);
                opacity: 0.7;
            }

            50% {
                transform: translateY(-15px);
                opacity: 1;
            }
        }

        /* Efectos de reconexión exitosa */
        .connectivity-overlay.reconnected {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.95) 0%, rgba(32, 134, 56, 0.98) 100%);
        }

        .connectivity-overlay.reconnected .connectivity-icon {
            animation: successSpin 1s ease-in-out;
        }

        .connectivity-overlay.reconnected .connectivity-title {
            color: #d4edda;
        }

        .connectivity-overlay.reconnected .connectivity-message {
            color: #d4edda;
        }

        @keyframes successSpin {
            0% {
                transform: rotate(0deg) scale(1);
                opacity: 0.5;
            }

            50% {
                transform: rotate(180deg) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: rotate(360deg) scale(1);
                opacity: 1;
            }
        }

        /* Responsive design para overlay de conectividad */
        @media (max-width: 768px) {
            .connectivity-icon {
                font-size: 3.5rem;
            }

            .connectivity-title {
                font-size: 1.8rem;
            }

            .connectivity-message {
                font-size: 1.1rem;
            }

            .connectivity-status {
                font-size: 0.95rem;
                padding: 10px 18px;
            }

            .connectivity-retry-btn {
                font-size: 0.95rem;
                padding: 10px 20px;
            }
        }

        @media (max-width: 480px) {
            .connectivity-title {
                font-size: 1.6rem;
            }

            .connectivity-message {
                font-size: 1rem;
            }

            .connectivity-icon {
                font-size: 3rem;
            }

            .connectivity-status {
                font-size: 0.9rem;
                padding: 8px 15px;
            }

            .connectivity-retry-btn {
                font-size: 0.9rem;
                padding: 8px 18px;
            }

            .connectivity-dot {
                width: 8px;
                height: 8px;
            }

            /* Estilos responsivos para botones en móviles */
            .check-button-row {
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .check-button,
            .no-duplicate-button {
                font-size: 0.95rem;
                padding: 12px 16px;
                margin: 2px;
            }

            .no-duplicate-button {
                margin-left: 0;
                /* Oculto por defecto, se mostrará con JavaScript */
                display: none;
            }

            /* Clase para mostrar el botón cuando el input está activo */
            .no-duplicate-button.show-on-focus {
                display: inline-flex !important;
            }
        }

        /* Estilos para tablets y pantallas medianas */
        @media (min-width: 769px) and (max-width: 1023px) {

            /* Ocultar botón "No sé" duplicado en tablets */
            .no-duplicate-button {
                display: none !important;
            }
        }

        /* Estilos específicos para PC/Desktop (pantallas grandes) */
        @media (min-width: 1024px) {

            /* Ocultar botón "No sé" duplicado en PC */
            .no-duplicate-button {
                display: none !important;
            }

            .connectivity-content {
                max-width: 700px;
                padding: 40px;
                background: rgba(0, 0, 0, 0.1);
                border-radius: 25px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .connectivity-icon {
                font-size: 4.5rem;
                margin-bottom: 25px;
            }

            .connectivity-title {
                font-size: 2.2rem;
                margin-bottom: 20px;
            }

            .connectivity-message {
                font-size: 1.3rem;
                margin-bottom: 35px;
                max-width: 500px;
                margin-left: auto;
                margin-right: auto;
            }

            .connectivity-status {
                padding: 15px 30px;
                font-size: 1.1rem;
                margin-bottom: 30px;
            }

            .connectivity-retry-btn {
                padding: 15px 35px;
                font-size: 1.1rem;
                gap: 10px;
            }

            .connectivity-retry-btn:hover {
                transform: translateY(-3px);
            }

            .connectivity-dot {
                width: 12px;
                height: 12px;
            }
        }



        /* === ESTILOS PARA MODAL DE CONTINUACIÓN === */
        .continue-game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20000;
            opacity: 0;
            animation: fadeInOverlay 0.4s ease-out forwards;
        }

        .continue-game-modal {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.95) 100%);
            backdrop-filter: blur(25px);
            border-radius: 25px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);
            max-width: 500px;
            width: 90%;
            overflow: hidden;
            animation: slideInModal 0.5s ease-out;
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }

        .continue-modal-header {
            padding: 35px 35px 25px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            position: relative;
            overflow: hidden;
        }

        .continue-modal-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><defs><pattern id="stars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.5" fill="white" opacity="0.2"/><circle cx="12" cy="8" r="0.3" fill="white" opacity="0.15"/><circle cx="8" cy="15" r="0.4" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="20" fill="url(%23stars)"/></svg>') repeat;
            animation: sparkle 25s linear infinite;
            opacity: 0.3;
        }

        .continue-modal-icon {
            font-size: 3.5rem;
            margin-bottom: 15px;
            display: block;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
            animation: bounce 2s infinite;
            position: relative;
            z-index: 2;
        }

        .continue-modal-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin: 0 0 8px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 2;
        }

        .continue-modal-subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin: 0;
            font-weight: 400;
            position: relative;
            z-index: 2;
        }

        .continue-modal-content {
            padding: 30px 35px;
        }

        .continue-progress-info {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            border: 1px solid rgba(102, 126, 234, 0.2);
            text-align: center;
        }

        .continue-progress-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 15px;
        }

        .continue-progress-stats {
            display: flex;
            justify-content: space-around;
            gap: 15px;
        }

        .continue-stat-item {
            flex: 1;
            text-align: center;
        }

        .continue-stat-number {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .continue-stat-number.correct {
            color: #10b981;
        }

        .continue-stat-number.incorrect {
            color: #ef4444;
        }

        .continue-stat-number.remaining {
            color: #f59e0b;
        }

        .continue-stat-label {
            font-size: 0.9rem;
            color: #6b7280;
            font-weight: 500;
        }

        .continue-modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .continue-btn {
            flex: 1;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .continue-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .continue-btn:hover::before {
            left: 100%;
        }

        .continue-btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .continue-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .continue-btn-secondary {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            color: #374151;
            border: 2px solid rgba(102, 126, 234, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        .continue-btn-secondary:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg, #ffffff 0%, #f1f5f9 100%);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border-color: rgba(102, 126, 234, 0.3);
        }

        .continue-btn:active {
            transform: translateY(0);
        }

        @media (max-width: 480px) {
            .continue-game-modal {
                width: 95%;
                margin: 20px;
            }

            .continue-modal-header {
                padding: 25px 20px 20px;
            }

            .continue-modal-content {
                padding: 20px;
            }

            .continue-modal-buttons {
                flex-direction: column;
                gap: 12px;
            }

            .continue-modal-title {
                font-size: 1.5rem;
            }

            .continue-modal-icon {
                font-size: 3rem;
            }
        }

        /* Estilos para el título creativo */
        .creative-title-container {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667eea 100%);
            padding: 1px 10px 1px 10px;
            position: relative;
            overflow: hidden;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .title-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><defs><pattern id="stars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.5" fill="white" opacity="0.3"/><circle cx="12" cy="8" r="0.3" fill="white" opacity="0.2"/><circle cx="8" cy="15" r="0.4" fill="white" opacity="0.25"/></pattern></defs><rect width="100" height="20" fill="url(%23stars)"/></svg>') repeat;
            animation: sparkle 20s linear infinite;
        }

        .creative-title {
            margin: 0;
            text-align: center;
            color: white;
            font-size: 22px;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
            position: relative;
            z-index: 2;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .globe-icon {
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 28px;
            animation: rotate 4s ease-in-out infinite;
        }

        .title-text {
            background: linear-gradient(45deg, #FFD700, #FFF, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes sparkle {
            0% {
                transform: translateX(-100px);
            }

            100% {
                transform: translateX(100px);
            }
        }

        @keyframes rotate {

            0%,
            100% {
                transform: rotate(0deg) scale(1);
            }

            50% {
                transform: rotate(10deg) scale(1.1);
            }
        }

        @keyframes glow {
            0% {
                filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.3));
            }

            100% {
                filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.6));
            }
        }

        /* === TECLADO VIRTUAL MODERNO === */
        .virtual-keyboard-overlay {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50000;
            display: none;
            align-items: flex-end;
            justify-content: center;
            pointer-events: auto;
            /* permitir interacción para cerrar y usar teclado */
        }

        /* Ocultar teclado virtual solo en pantallas de PC/Desktop grandes */
        @media (min-width: 1200px) {
            .virtual-keyboard-overlay {
                display: none !important;
            }
        }

        .virtual-keyboard {
            pointer-events: auto;
            width: 100%;
            max-width: 740px;
            /* un poco más ancho para dar más espacio a las teclas */
            margin: 0 auto;
            padding: 10px 6px 14px;
            /* reducir padding lateral para ganar ancho útil */
            border-radius: 18px 18px 0 0;
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.96));
            box-shadow: 0 -8px 30px rgba(0, 0, 0, 0.4);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            transform: translateY(100%);
            transition: transform 260ms cubic-bezier(0.22, 1, 0.36, 1);
        }

        .virtual-keyboard.show {
            transform: translateY(0);
        }

        .vk-row {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            /* separación mínima para ensanchar teclas */
            margin-top: 2px;
            /* espacio entre filas reducido */
        }

        /* Fila superior: mismo gap mínimo para máxima anchura */
        .vk-row[data-row="1"] {
            gap: 2px;
        }

        .vk-row.shifted {
            grid-template-columns: repeat(8, 1fr);
            /* sin tecla Enter: 8 columnas */
        }

        .vk-key {
            height: 44px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
            color: #fff;
            font-weight: 700;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: transform 0.06s ease, box-shadow 0.12s ease, background 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
        }

        .vk-key:active {
            transform: translateY(1px) scale(0.99);
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3) inset;
        }

        .vk-key.primary {
            background: linear-gradient(180deg, #2563eb, #1d4ed8);
            border-color: rgba(37, 99, 235, 0.6);
        }

        .vk-key.warn {
            background: linear-gradient(180deg, #e67e22, #d35400);
            border-color: rgba(230, 126, 34, 0.6);
        }

        .vk-key.danger {
            background: linear-gradient(180deg, #ef4444, #dc2626);
            border-color: rgba(239, 68, 68, 0.6);
        }

        .vk-footer {
            display: grid;
            grid-template-columns: auto minmax(96px, 1fr) 56px;
            /* controles + barra espaciadora reducida + ocultar */
            gap: 8px;
            margin-top: 2px;
            /* reducir separación bajo las filas/acentos */
            align-items: center;
        }

        .vk-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .vk-group {
            display: inline-flex;
            gap: 6px;
            align-items: center;
        }

        .vk-radio {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
        }

        .vk-radio input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .vk-radio span {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            padding: 0 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
            color: #fff;
            font-weight: 700;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
            user-select: none;
            cursor: pointer;
        }

        .vk-radio input:checked+span {
            background: linear-gradient(180deg, #2563eb, #1d4ed8);
            border-color: rgba(37, 99, 235, 0.6);
        }

        .vk-key.space {
            grid-column: 2 / span 1;
            margin-top: 2px;
            margin-bottom: 2px;
        }

        .vk-key.hide {
            grid-column: 3 / span 1;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .vk-key.hide i {
            pointer-events: none;
        }

        .vk-key.small {
            font-size: 14px;
            font-weight: 600;
        }

        /* Bloque de acentos */
        .vk-accents {
            margin-top: 2px;
        }

        .vk-accents .row-accents {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            /* 5 acentos + 1 borrar */
            gap: 2px;
            /* igualar separación a 2px */
        }

        /* Estilo elegante para las teclas de acentos */
        .vk-accents .vk-key {
            background: linear-gradient(180deg, #a78bfa, #7c3aed);
            /* violeta suave a profundo */
            border-color: rgba(167, 139, 250, 0.65);
            box-shadow: 0 2px 10px rgba(124, 58, 237, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.25);
            text-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);
            height: 36px;
            /* más bajas */
            font-size: 15px;
        }

        /* Tecla borrar de acentos: color distinto (rojo elegante) */
        .vk-accents .vk-key[data-key="backspace"] {
            background: linear-gradient(180deg, #f43f5e, #e11d48);
            border-color: rgba(244, 63, 94, 0.6);
            box-shadow: 0 2px 10px rgba(225, 29, 72, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .vk-accents .vk-key[data-key="backspace"]:active {
            background: linear-gradient(180deg, #e11d48, #be123c);
        }

        .vk-accents .vk-key:active {
            background: linear-gradient(180deg, #946cf8, #6d28d9);
        }

        .vk-accents .row-n-tilde {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin-top: 8px;
        }

        .vk-accents .row-n-tilde .vk-key {
            grid-column: 3;
        }

        /* Efecto visual al pulsar teclas del teclado virtual */
        @keyframes keyHoverFlash {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.35), 0 0 16px rgba(79, 70, 229, 0.6);
                transform: translateY(0) scale(1.02);
                filter: brightness(1.08);
            }

            100% {
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
                transform: translateY(0) scale(1);
                filter: brightness(1);
            }
        }

        .vk-key.press-glow {
            animation: keyHoverFlash 1s ease-out;
        }

        /* Mejora de legibilidad del teclado en pantallas móviles/táctiles */
        @media (max-width: 768px),
        (pointer: coarse) {

            /* Teclas principales más altas y con fuente mayor */
            .vk-key {
                height: 52px;
                font-size: 18px;
            }

            .vk-key.small {
                font-size: 16px;
            }

            .vk-key.hide {
                height: 52px;
            }

            .vk-row {
                gap: 3px;
                margin-top: 2px;
            }

            .vk-row[data-row="1"] {
                gap: 3px;
            }

            .vk-footer {
                gap: 8px;
                margin-top: 2px;
            }

            /* Acentos un poco más grandes también */
            .vk-accents {
                margin-top: 2px;
            }

            .vk-accents .vk-key {
                height: 42px;
                font-size: 17px;
            }

            .vk-accents .row-accents,
            .vk-accents .row-n-tilde {
                gap: 3px;
            }
        }

        /* Logo en esquina superior izquierda - EFECTO MANCHA */
        .logo-corner {
            position: fixed;
            top: 10px;
            left: 20px;
            width: 60px;
            height: 60px;
            z-index: 1000;
            cursor: pointer;
            animation: splashEffect 13s infinite ease-in-out;
        }

        .logo-corner:hover {
            transform: scale(1.1);
            animation-play-state: paused;
        }

        .logo-corner img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
            transition: filter 0.3s ease;
        }

        .logo-corner:hover img {
            filter: drop-shadow(0 4px 12px rgba(255, 107, 53, 0.4));
        }

        /* Animación de salpicadura de mancha - cada 10s, dura 3s */
        @keyframes splashEffect {

            /* 0-3s: Animación de salpicadura */
            0% {
                transform: scale(1) rotate(0deg);
                filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
                border-radius: 15px;
            }

            5% {
                transform: scale(1.2) rotate(-5deg) skewX(10deg);
                filter: drop-shadow(0 4px 12px rgba(255, 107, 53, 0.4));
                border-radius: 50% 20% 40% 30%;
            }

            10% {
                transform: scale(0.9) rotate(3deg) skewY(5deg);
                filter: drop-shadow(0 6px 16px rgba(220, 53, 69, 0.5));
                border-radius: 30% 60% 20% 50%;
            }

            15% {
                transform: scale(1.1) rotate(-2deg) skewX(-5deg);
                filter: drop-shadow(0 3px 10px rgba(245, 158, 11, 0.4));
                border-radius: 40% 30% 60% 20%;
            }

            20% {
                transform: scale(1.05) rotate(1deg);
                filter: drop-shadow(0 4px 8px rgba(239, 68, 68, 0.3));
                border-radius: 25% 45% 35% 55%;
            }

            23% {
                transform: scale(1) rotate(0deg);
                filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
                border-radius: 15px;
            }

            /* 23-100%: Reposo hasta la siguiente salpicadura */
            24%,
            100% {
                transform: scale(1) rotate(0deg);
                filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
                border-radius: 15px;
            }
        }

        /* Responsivo para móvil */
        @media (max-width: 480px) {
            .logo-corner {
                width: 50px;
                height: 50px;
                top: 2px;
                left: 5px;
                /* Mantiene la misma animación de mancha */
                animation: splashEffect 13s infinite ease-in-out;
            }

            .logo-corner:hover {
                transform: scale(1.05);
                /* Menos agresivo en móvil */
            }
        }

        /* Responsivo para PC/Desktop - Acercar logo al título */
        @media (min-width: 1024px) {
            .logo-corner {
                top: 5px;
                left: calc(45% - 200px);
                /* Posicionado cerca del título centrado */
            }
        }
    </style>
</head>

<body>

    <!-- Logo en esquina superior izquierda -->
    <div class="logo-corner">
        <img src="https://fawzinoo.github.io/Fotos/f.png" alt="Logo F" draggable="false">
    </div>

    <!-- Overlay de Conectividad -->
    <div id="connectivity-overlay" class="connectivity-overlay">
        <div class="connectivity-content">
            <span class="connectivity-icon">📡</span>
            <h1 class="connectivity-title">Sin Conexión</h1>
            <p class="connectivity-message">
                Parece que tu conexión a Internet es débil o se ha perdido.<br>
                Esta aplicación necesita conexión para funcionar correctamente.
            </p>

            <div class="connectivity-status">
                <i class="fas fa-wifi"></i>
                <span id="connectivity-status-text">Verificando conexión...</span>
            </div>

            <div class="connectivity-loading-dots">
                <div class="connectivity-dot"></div>
                <div class="connectivity-dot"></div>
                <div class="connectivity-dot"></div>
            </div>

            <div class="connectivity-retry-section">
                <button id="connectivity-retry-btn" class="connectivity-retry-btn">
                    <i class="fas fa-redo"></i>
                    <span>Intentar de nuevo</span>
                </button>
            </div>
        </div>
    </div>



    <!-- Título creativo -->
    <div class="creative-title-container">
        <div class="title-background"></div>
        <h1 class="creative-title">
        <i class="fas  fa-quote-left globe-icon"></i>
            <span class="title-text">Silabas</span>
        </h1>
    </div>

    <div class="top-status-bar">

        <div class="pill back-arrow" onclick="goBack()">
            <span><i class="fas fa-arrow-left"></i></span>
        </div>
        <div class="pill pill-faltan">
            <span>T: <span id="total-cards"></span></span>
        </div>
        <div class="pill pill-correctas">
            <span><i class="fas fa-check"></i> <span id="correctas-count">0</span></span>
        </div>
        <div class="pill pill-incorrectas">
            <span><i class="fas fa-times"></i> <span id="incorrectas-count">0</span></span>
        </div>


    </div>


    <div id="flashcard-container-wrapper">

        <!--------------------------------------------------------------------->

        <div id="flashcard-container">
            <div class="editor-name">@Profe Faouzi</div>

            <script>
                // Genera tarjetas silábicas incluyendo ga, go, gu, ge, gi, y también gue, gui, que, qui
                (function () {
                    const container = document.getElementById('flashcard-container');

                    // Gradiente por vocal final
                    const gradMap = {
                        a: '#43c6ac, #677007',
                        o: '#43c6ac, #076770',
                        u: '#43c6ac, #0a4b7a',
                        e: '#43c6ac, #2a6f37',
                        i: '#43c6ac, #3558e3'
                    };
                    const baseVowels = ['a', 'o', 'u', 'e', 'i'];


                    // Para 'g' se añaden: gue, gui, que, qui (después de ga go gu ge gi)
                    const accentOverrides = {
                        'Rbebe': 'Rbebé',
                        'Rcinturon': 'Rcinturón',
                        'Rfutbol': 'Rfútbol',
                        'Rlapiz': 'Rlápiz',
                        'Rmuneca': 'Rmuñeca',
                        'Respana': 'REspaña',
                        'Rbanera': 'Rbañera',
                        'Rpina': 'Rpiña',
                        'Rsofa': 'Rsofá',
                        'Rtunel': 'Rtúnel',
                        'Rtelefono': 'RTeléfono',
                        'Rcenuda': 'Rceñuda',
                        'Rbanistas': 'Rbañistas',
                        'Rmono': 'Rmoño',
                        'Rdatiless': 'Rdátiles'
                    };

                    const data = {
                        b: ['Rbanco', 'Rbotas', 'Rburro', 'Rbebe', 'Rbicicleta'],
                        c: ['Rcasa', 'Rcocina', 'Rcuchara', 'Rcerilla', 'Rcinturon'],
                        ch: ['Rchaqueta', 'Rchocolate', 'Rchurro', 'Rcheque', 'Rchicle'],
                        d: ['Rdatiless', 'Rdos', 'Rdulces', 'Rdedo', 'Rdinero'],
                        f: ['Rfarola', 'Rfoto', 'Rfutbol', 'Rfecha', 'Rfichas'],
                        g: ['Rgato', 'Rgota', 'Rgusano', 'Rgel', 'Rgimnasio', 'Rguerra', 'Rguitarra', 'Rqueso', 'Rquince'],
                        h: ['Rhacha', 'Rhoja', 'Rhumo', 'Rhelado', 'Rhigo'],
                        j: ['Rjarra', 'Rjoyas', 'Rjuguete', 'Rjefe', 'Rjirafa'],
                        k: ['Rkayak', 'Rkoala', 'Rkufiya', 'Rketchup', 'Rkiwi'],
                        l: ['Rlapiz', 'Rloro', 'Rluz', 'Rlechuga', 'Rlibro'],
                        m: ['Rmanzana', 'Rmonedas', 'Rmuneca', 'Rmesa', 'Rmisil'],
                        n: ['Rnaranja', 'Rnota', 'Rnudo', 'Rnevera', 'Rnido'],
                        ñ: ['Respana', 'Rmono', 'Rcenuda', 'Rbanera', 'Rbanistas'],
                        p: ['Rpan', 'Rpozo', 'Rpulseraa', 'Rpez', 'Rpina'],
                        r: ['Rradio', 'Rropa', 'Rruleta', 'Rreloj', 'Rrinoceronte', 'Rpera', 'Rperro'],
                        s: ['Rsalero', 'Rsofa', 'Rsudadera', 'Rsello', 'Rsilla'],
                        t: ['Rtaza', 'Rtorre', 'Rtunel', 'Rtelefono', 'Rtigre'],
                        v: ['Rvaso', 'Rvolante', 'Rvestido', 'Rvinilo'],
                        y: ['Ryate', 'Ryogur', 'Ryunque', 'Ryema'],
                        z: ['Rzapatos', 'Rzorro', 'Rzumo', 'Rzinc']
                    };

                    // Expose ordered words for audio mapping
                    window.orderedWords = [];

                    const baseImg = 'https://fawzinoo.github.io/Fotos/';
                    const rmAccents = s => s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    const toFile = s => {
                        // Si la palabra ya empieza con "R", mantenerla tal como está
                        if (s.startsWith('R')) {
                            return rmAccents(s)
                                .replace(/ñ/g, 'n')
                                .replace(/[^a-zA-Z0-9]+/g, ''); // No convertir a minúsculas
                        }

                        // Para palabras que no empiezan con "R", procesarlas normalmente
                        const processed = rmAccents(s)
                            .toLowerCase()
                            .replace(/ñ/g, 'n')
                            .replace(/[^a-z0-9]+/g, '');

                        return 'r' + processed;
                    };
                    
                    const displayFixesLocal = {
                        'Pulseraa': 'Pulsera',
                        'Datiless': 'Dátiles'
                    };

                    const toAnswerWord = s => {
                        if (!s) return '';
                        const trimmed = s.trim();
                        const core = trimmed.startsWith('R') ? trimmed.slice(1) : trimmed;
                        if (!core) return '';
                        const result = core.charAt(0).toUpperCase() + core.slice(1);
                        return displayFixesLocal[result] || result;
                    };

                    function gradForSyllable(syll) {
                        const vowels = syll.match(/[aeiou]/g);
                        const last = vowels ? vowels[vowels.length - 1] : 'a';
                        return gradMap[last] || gradMap.a;
                    }

                    function cap(word) {
                        return word.charAt(0).toUpperCase() + word.slice(1);
                    }

                    // Global counter for audio index mapping
                    let audioIndexCounter = 0;

                    function makeCard(syll, imageWord, grad, answerLabel) {
                        const card = document.createElement('div');
                        card.className = 'flashcard';
                        card.setAttribute('data-bg', '1');
                        card.setAttribute('data-audio-index', audioIndexCounter++);
                        card.style.cssText = 'box-shadow:0 8px 32px rgba(67,198,172,0.12);border-radius:20px;';

                        // Front
                        const front = document.createElement('div');
                        front.className = 'front';
                        front.style.cssText =
                            'position:absolute;inset:0;overflow:hidden;font-size:0;' +
                            'background:transparent;box-shadow:none;border:none;border-radius:0;' +
                            'display:block;';
                        const answerWord = toAnswerWord(answerLabel);
                        const frontImg = document.createElement('img');
                        frontImg.src = baseImg + toFile(imageWord) + '.jpg';
                        frontImg.alt = answerWord;
                        frontImg.loading = 'eager';
                        frontImg.decoding = 'async';
                        frontImg.style.cssText =
                            'position:absolute;top:0;left:0;width:100%;height:150%;object-fit:cover;z-index:0;display:block;' +
                            'clip-path:inset(0 0 32% 0);' +
                            'filter:brightness(0.82) saturate(1.1);border-radius:inherit;';
                        front.appendChild(frontImg);
                        try { card.dataset.frontText = cap(syll); } catch { }
                        try { card.dataset.answer = answerWord; } catch { }

                        // Back
                        const back = document.createElement('div');
                        back.className = 'back';
                        back.style.cssText = 'position:relative;width:100%;height:100%;overflow:hidden;';

                        const title = document.createElement('span');
                        title.className = 'front-word efecto-glow';
                        const backWord = answerLabel || imageWord;
                        title.setAttribute('data-original-word', backWord);
                        title.style.cssText =
                            'position:absolute;bottom:40px;left:50%;transform:translateX(-50%);' +
                            'z-index:2;font-size:2rem;text-align:center;width:90%;';
                        back.appendChild(title);

                        const img = document.createElement('img');
                        img.src = baseImg + toFile(imageWord) + '.jpg';
                        img.loading = 'eager';
                        img.decoding = 'async';
                        img.style.cssText =
                            'position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;border-radius:20px;';
                        back.appendChild(img);

                        card.appendChild(front);
                        card.appendChild(back);
                        container.appendChild(card);
                    }

                    // Render
                    Object.entries(data).forEach(([cons, words]) => {
                        // Sílabas por defecto (a, o, u, e, i)
                        let syllables = baseVowels.map(v => cons + v);

                        // Caso especial para 'g': añadir gue, gui, que, qui
                        if (cons === 'g') {
                            syllables = [
                                'ga', 'go', 'gu', 'ge', 'gi',
                                'gue', 'gui', 'que', 'qui'
                            ];
                        } else if (cons === 'z') {
                            // Excepción: no usar "ze", pasar de "zu" a "zi"
                            syllables = ['za', 'zo', 'zu', 'zi'];
                        }

                        words.forEach((word, i) => {
                            const s = syllables[i] || (cons + baseVowels[i % baseVowels.length]);
                            const grad = gradForSyllable(s);
                            const displayWord = accentOverrides[word] || word;
                            makeCard(s, word, grad, displayWord);
                        });
                    });
                })();
            </script>




            <style>
                /* Icono solo para el de arriba; no rompe el texto que actualiza el JS */
                #porcentaje-guardado {
                    display: inline-flex;
                    align-items: center;
                    position: relative;
                    /* Para hints posicionados */
                    overflow: visible;
                }

                #porcentaje-guardado::before {
                    content: "\f295";
                    /* fa-percent */
                    font-family: "Font Awesome 6 Free";
                    font-weight: 900;
                    font-size: 16px;
                    margin-right: 6px;
                }
            </style>

            <!-- Override: cambiar icono del porcentaje de aciertos -->
            <style>
                #porcentaje-guardado::before {
                    content: "\f091";
                    /* fa-trophy */
                    font-family: "Font Awesome 6 Free";
                    font-weight: 900;
                    font-size: 16px;
                    margin-right: 6px;
                }

                /* Estilo unificado: pills de avance con fondo gris y texto/iconos dorados */
                #porcentaje-guardado,
                #last-game-pill {
                    background: #6b7280 !important;
                    /* gris */
                    color: #FFD700 !important;
                    /* dorado para cifras e iconos */
                    border: 1px solid rgba(255, 255, 255, 0.2) !important;
                }

                /* Asegurar que los iconos hereden el color dorado */
                #porcentaje-guardado i,
                #last-game-pill i {
                    color: inherit !important;
                }

                /* Transición para ocultar/mostrar el cuadro de stats */
                #stats-box {
                    transition: opacity 320ms ease, transform 320ms ease, filter 320ms ease;
                }

                #stats-box.hidden {
                    opacity: 0;
                    transform: scale(0.75);
                    filter: blur(2px);
                    pointer-events: none;
                }

                /* Hints: texto limpio sin brillos/luces, en amarillo sólido */
                .pill-hint {
                    position: absolute;
                    right: 100%;
                    top: 50%;
                    transform: translateY(-50%);
                    margin-right: 14px;
                    white-space: nowrap;
                    z-index: 100;
                    overflow: hidden;
                    /* para el tipeo */
                    pointer-events: none;
                    /* no bloquea clics */
                    /* Tipografía y color moderno */
                    font-weight: 900;
                    font-size: 18px;
                    letter-spacing: 0.3px;
                    line-height: 1.1;
                    color: #ffeb3b;
                    /* amarillo sólido */
                    text-shadow: none;
                    /* sin efecto de luz */
                    -webkit-text-stroke: 1.25px #000;
                    /* contorno negro para "revistido de negro" */
                    paint-order: stroke fill;
                    /* Efectos */
                    opacity: 0;
                    width: 0ch;
                    /* arranca sin ancho y “tipea” */
                    will-change: transform, opacity;
                    animation:
                        typing var(--type-dur, 1200ms) steps(var(--chars, 12)) var(--delay, 0ms) both,
                        hintEnter 640ms cubic-bezier(0.22, 1, 0.36, 1) calc(var(--delay, 0ms) + var(--intro-delay, 180ms)) both,
                        hintFadeOut 480ms ease-in var(--fade-delay, 2200ms) forwards;
                }

                .pill-hint::before {
                    /* Quitar aura/halo */
                    content: none !important;
                    display: none !important;
                }

                .pill-hint::after {
                    display: none;
                }

                @keyframes typing {
                    from {
                        width: 0ch;
                    }

                    to {
                        width: calc(var(--chars, 12) * 1ch);
                    }
                }

                @keyframes hintEnter {
                    0% {
                        opacity: 0;
                        transform: translateY(-50%) translateX(14px) scale(0.96) rotate(-1.5deg);
                        filter: blur(3px);
                    }

                    60% {
                        opacity: 1;
                        transform: translateY(-50%) translateX(-2px) scale(1.02) rotate(0.3deg);
                        filter: blur(0.5px);
                    }

                    100% {
                        opacity: 1;
                        transform: translateY(-50%) translateX(0) scale(1) rotate(0);
                        filter: blur(0);
                    }
                }

                /* caretBlink eliminado: sin cursor parpadeante */
                @keyframes hintFadeOut {
                    0% {
                        opacity: 1;
                        transform: translateY(-50%) translateX(0);
                        filter: blur(0);
                    }

                    100% {
                        opacity: 0;
                        transform: translateY(-50%) translateX(-6px);
                        filter: blur(2px);
                    }
                }
            </style>

            <!-- Firma del editor dentro del contenedor de tarjetas -->
            <style>
                .editor-name {
                    position: absolute;
                    bottom: 5px;
                    left: 15px;
                    /* abajo izquierda del contenedor */
                    font-size: 9px;
                    animation: colorTintineo 3s infinite;
                    font-weight: bold;
                    text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
                    z-index: 21;
                    /* sobre el contenido base */
                    pointer-events: none;
                    /* no bloquea clics */
                }

                @keyframes colorTintineo {
                    0% {
                        color: #ff0000;
                    }

                    20% {
                        color: #ffff00;
                    }

                    40% {
                        color: #0000ff;
                    }

                    60% {
                        color: #ffffff;
                    }

                    80% {
                        color: #000000;
                    }

                    100% {
                        color: #ff0000;
                    }
                }
            </style>

            <!-- Cuadro unificado para ambos porcentajes (misma talla de pills, separados por línea) -->
            <div id="stats-box" style="
        position: absolute;
        bottom: 6px;
        right: 8px;
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        /* Caja elegante sin alterar el tamaño de los pills */
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 14px;
        padding: 6px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.18);
        border: 1px solid rgba(255,255,255,0.14);
        transform: scale(0.8);
        transform-origin: bottom right;
    ">
                <!-- Porcentaje de aciertos (sin cambiar su tamaño) -->
                <div class="pill" id="porcentaje-guardado" style="
        background: #6b7280; /* gris como en sel-idiomas */
        color: #FFD700;      /* dorado para la cifra */
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.2);
        min-width: 65px;
        text-align: center;
    "><span id="current-percentage">0%</span></div>

                <!-- Separador fino entre ambos -->
                <div style="
        width: 100%;
        height: 1px;
        background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.35), rgba(255,255,255,0));
                "></div>
                <div class="pill" id="last-game-pill" style="
        background: #6b7280; /* gris como en sel-idiomas */
        color: #FFD700;      /* dorado para cifra e icono */
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.2);
        min-width: 65px;
        position: relative; /* Para hints posicionados */
        overflow: visible;
    ">
                    <span><i class="fas fa-chart-line"></i> <span id="last-game-percentage">0%</span></span>
                </div>
            </div>

        </div>
    </div>

    <audio id="soundResetButton" src="https://fawzinoo.github.io/audios/bellding-254774.mp3" preload="auto"></audio>
    <audio id="shuffleSound" src="https://fawzinoo.github.io/audios/naipe.mp3" preload="auto"></audio>
    <audio id="buttonClickSound" src="https://fawzinoo.github.io/audios/botonn.mp3" preload="auto"></audio>
    <audio id="keyboardSound" src="https://fawzinoo.github.io/audios/teclas1.mp3" preload="auto"></audio>
    <audio id="keyboardSound" src="https://fawzinoo.github.io/audios/tecla.mp3" preload="auto"></audio>
    <audio id="trashSound" src="https://fawzinoo.github.io/audios/trash.mp3" preload="auto"></audio>

    <div class="button-container" role="toolbar" aria-label="Controles de práctica">
        <button class="button" id="reset-button" title="Reiniciar" aria-label="Reiniciar">
            <i class="fas fa-rotate-left" aria-hidden="true"></i>
        </button>
        <button class="button skip" id="skip-button" title="No sé" aria-label="No sé">
            <i class="fas fa-forward" aria-hidden="true"></i>
        </button>
        <button class="button shuffle" id="shuffle-button" title="Mezclar" aria-label="Mezclar">
            <i class="fas fa-random" aria-hidden="true"></i>
        </button>
        <button class="button sound-toggle" id="sound-toggle-btn" title="Silenciar sonidos de botones"
            aria-label="Silenciar sonidos de botones">
            <i class="fas fa-volume-up" aria-hidden="true"></i>
        </button>
    </div>


    <!-- Análisis de audio para verificación fonética -->
    <script src="https://unpkg.com/meyda/dist/web/meyda.min.js"></script>

    <!-- Agregar la librería de confeti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

    <script>

        document.addEventListener('DOMContentLoaded', () => {
            const flashcardContainer = document.getElementById('flashcard-container');
            if (flashcardContainer) {
                // Listener en fase de CAPTURA para interceptar clics "fantasma" y manejar la lógica de volteo
                flashcardContainer.addEventListener('click', (event) => {
                    // 1. Lógica para ignorar el "clic fantasma"
                    if (window.ignoreClickAfterButton) {
                        const rect = window.ignoreClickAfterButton;
                        // Comprueba si el clic ocurrió dentro de los límites del botón desaparecido
                        if (event.clientX >= rect.left && event.clientX <= rect.right &&
                            event.clientY >= rect.top && event.clientY <= rect.bottom) {

                            // Restablece la bandera y detiene completamente el evento.
                            window.ignoreClickAfterButton = null;
                            event.stopPropagation();
                            event.preventDefault();
                            return; // El clic fue ignorado, no hacer nada más.
                        }
                        // Si el clic no fue en el área fantasma, limpiar la bandera para futuros clics.
                        window.ignoreClickAfterButton = null;
                    }

                    // 2. Lógica para evitar el volteo al hacer clic en el área de escritura
                    const typeDialog = event.target.closest('.type-dialog-container');
                    if (typeDialog) {
                        // Si el clic fue dentro del área de escritura, no hagas nada.
                        // No es necesario stopPropagation porque la lógica de volteo está más abajo.
                        return;
                    }

                    // 3. Lógica para voltear la tarjeta (si ninguna de las condiciones anteriores se cumplió)
                    const currentCard = document.querySelector('.flashcard.is-visible');
                    if (currentCard && !currentCard.classList.contains('flipped')) {
                        // Solo voltea si la tarjeta es visible y está en el anverso.
                        flipCard(currentCard);
                    }
                }, true); // <-- ¡IMPORTANTE! Usar la fase de captura.
            }
        });



        function vibrar(ms = 80) {
            if (window.navigator && window.navigator.vibrate) {
                window.navigator.vibrate(ms);
            }
        }

        function playErrorSound() {
            const errorAudio = new Audio('https://fawzinoo.github.io/audios/error.mp3');
            errorAudio.volume = 0.5;
            errorAudio.play().catch(() => { });
        }

        // ======= Control de mute para sonidos de botones (calco de sel-idiomas) =======
        const BTN_SOUNDS_LS_KEY = 'idiomas_btn_sounds_muted';
        function areButtonSoundsMuted() {
            try {
                return localStorage.getItem(BTN_SOUNDS_LS_KEY) === '1';
            } catch (e) {
                return false;
            }
        }

        function applyButtonSoundsMutedToElements() {
            const muted = areButtonSoundsMuted();
            ['buttonClickSound', 'shuffleSound', 'soundResetButton', 'keyboardSound', 'trashSound'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.muted = muted;
                }
            });
        }

        function updateSoundToggleIcon() {
            const btn = document.getElementById('sound-toggle-btn');
            if (!btn) return;
            const icon = btn.querySelector('i');
            const muted = areButtonSoundsMuted();
            if (icon) {
                icon.classList.toggle('fa-volume-up', !muted);
                icon.classList.toggle('fa-volume-mute', muted);
                icon.classList.toggle('fa-volume-high', !muted);
                icon.classList.toggle('fa-volume-xmark', muted);
            }
            btn.title = muted ? 'Sonidos de botones silenciados' : 'Silenciar sonidos de botones';
            btn.setAttribute('aria-pressed', muted ? 'true' : 'false');
        }

        function setButtonSoundsMuted(muted) {
            try {
                localStorage.setItem(BTN_SOUNDS_LS_KEY, muted ? '1' : '0');
            } catch (e) { }
            applyButtonSoundsMutedToElements();
            updateSoundToggleIcon();
        }

        document.addEventListener('DOMContentLoaded', () => {
            applyButtonSoundsMutedToElements();
            updateSoundToggleIcon();
            const toggle = document.getElementById('sound-toggle-btn');
            if (toggle) {
                toggle.addEventListener('click', () => {
                    vibrar(40);
                    setButtonSoundsMuted(!areButtonSoundsMuted());
                });
            }
        });

        function playButtonSound() {
            // Agregar vibración leve a todos los botones
            vibrar(50); // Vibración más suave que los botones principales

            const buttonAudio = document.getElementById('buttonClickSound');
            if (buttonAudio) {
                buttonAudio.currentTime = 0; // Reiniciar el audio
                buttonAudio.volume = 0.7;
                if (!areButtonSoundsMuted()) {
                    buttonAudio.play().catch(() => { });
                }
            }
        }

        function playKeyboardSound() {
            const keyboardSound = document.getElementById('keyboardSound');
            if (keyboardSound) {
                keyboardSound.currentTime = 0;
                keyboardSound.volume = 0.4;
                if (!areButtonSoundsMuted()) {
                    keyboardSound.play().catch(() => { });
                }
            }
        }

        function playTrashSound() {
            const trashSound = document.getElementById('trashSound');
            if (trashSound) {
                trashSound.currentTime = 0;
                trashSound.volume = 0.6;
                if (!areButtonSoundsMuted()) {
                    trashSound.play().catch(() => { });
                }
            }
        }

        function quitarAcentos(str) {
            return (str || '')
                .toLowerCase()
                .normalize('NFD')
                .replace(/\p{Diacritic}+/gu, '')
                .trim();
        }

        function goBack() {
            // Reproducir sonido de botón
            playButtonSound();

            // Verificar si hay historial de navegación
            if (window.history.length > 1) {
                // Usar history.back() para regresar a la página anterior
                window.history.back();
            } else if (document.referrer && document.referrer !== window.location.href) {
                // Si no hay historial pero sí hay referrer, ir al referrer
                window.location.href = document.referrer;
            } else {
                // Como último recurso, redirigir a la página principal
                window.location.href = 'https://fawzinoo.github.io/Rep/Vocabulario.html';
            }
        }

        // --- NUEVO SISTEMA DE RECONOCIMIENTO DE VOZ (CLIENTE) ---

        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;

        // Sistema de tarjetas completadas
        let completedCards = new Set();
        let correctCount = 0;
        let incorrectCount = 0;
        let currentCardIndex = 0;
        let voiceAttempts = 0; // Contador para los intentos de voz
        let canFlipBack = true;
        let canFlip = true; // Controla si se puede voltear la tarjeta
        // Timer para programar la actualización del porcentaje tras re-aparecer el cuadro
        let percentageUpdateTimeoutId = null;
        let statsShowTimeoutId = null;
        let statsHideTimeoutId = null;

        // Estado: ventana entre 1er y 2º intento
        let betweenAttempts = false;
        // Timeouts para gestionar ventana entre intentos
        let errorDelayTimeoutId = null;       // 2s de mensaje Incorrecto tras primer fallo
        let resumeRecognitionTimeoutId = null; // ~100ms antes de reanudar reconocimiento



        // Flags para controlar el botón "No sé" en estados de back
        let showingErrorMessage = false;           // true mientras se muestra el mensaje "Incorrecto"
        let lockedAfterSecondIncorrect = false;    // bloquea el botón tras segundo intento fallido hasta pasar de tarjeta
        let lockedAfterCorrect = false;            // bloquea el botón tras acierto hasta pasar de tarjeta

        function setSkipEnabled(enabled) {
            const skipBtn = document.getElementById('skip-button');
            if (!skipBtn) return;
            skipBtn.disabled = !enabled;
            skipBtn.style.opacity = enabled ? '1' : '0.5';
            skipBtn.style.pointerEvents = enabled ? 'auto' : 'none';
            // Sincronizar también el estado con el botón móvil "No sé" (si existe en la tarjeta visible)
            try {
                const visibleBack = document.querySelector('.flashcard.is-visible .back');

                if (mobileSkip) {
                    mobileSkip.disabled = !enabled;
                    // También actualizar accesibilidad
                    mobileSkip.setAttribute('aria-disabled', (!enabled).toString());
                }
            } catch { }
        }

        // Habilita "No sé" solo en dos momentos:
        // 1) Cuando la tarjeta visible está en front (antes del primer intento)
        // 2) Tras el primer fallo, en la ventana entre intentos (betweenAttempts=true)
        function updateSkipButtonState() {
            const card = document.querySelector('.flashcard.is-visible');
            if (!card) { setSkipEnabled(false); return; }
            const isFront = !card.classList.contains('flipped');
            if (isFront) {
                // Permitido al estar en front (antes del 1er intento)
                setSkipEnabled(true);
                return;
            }
            // Back: activar por defecto salvo condiciones de bloqueo
            // Bloqueos explícitos: mientras se muestran mensajes de error, y después del segundo incorrecto
            if (showingErrorMessage || lockedAfterSecondIncorrect || lockedAfterCorrect) {
                setSkipEnabled(false);
                return;
            }
            // MODIFICADO: Mantener "No sé" disponible siempre, incluso entre intentos
            // Para modo escritura, permitir "No sé" por defecto en back
            setSkipEnabled(true);
        }

        // === Helpers de UI: botón móvil "No sé" ===
        function showMobileSkipButton() {
            try {
                // Mostrar el botón móvil en la tarjeta visible
                const scope = document.querySelector('.flashcard.is-visible') || document;
                scope.querySelectorAll('.mobile-skip-button').forEach(btn => {
                    btn.classList.add('keyboard-visible');
                    btn.setAttribute('aria-hidden', 'false');
                    btn.style.pointerEvents = 'auto';
                });
            } catch (e) { /* noop */ }
        }

        function hideMobileSkipButton(immediate = true) {
            try {
                // Ocultar el botón móvil en la tarjeta visible
                const scope = document.querySelector('.flashcard.is-visible') || document;
                scope.querySelectorAll('.mobile-skip-button').forEach(btn => {
                    btn.classList.remove('keyboard-visible');
                    btn.setAttribute('aria-hidden', 'true');
                    // No animamos por ahora; immediate no cambia comportamiento, pero se conserva firma
                    btn.style.pointerEvents = 'none';
                });
            } catch (e) { /* noop */ }
        }

        // Permitir saltar tarjeta como "No sé"
        function skipCurrentCardAsUnknown() {
            console.log('🎯 skipCurrentCardAsUnknown iniciada');
            // Respetar estado de habilitación del botón
            const btn = document.getElementById('skip-button');
            if (btn && btn.disabled) {
                console.log('❌ Botón skip deshabilitado, cancelando');
                return;
            }

            // Cancelar timeouts pendientes de la ventana entre intentos
            if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
            if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }

            // Limpiar estados de bloqueo
            betweenAttempts = false;
            showingErrorMessage = false;
            lockedAfterSecondIncorrect = false;
            lockedAfterCorrect = false;

            // Evitar doble procesamiento si no hay tarjetas o ya está completada
            const flashcardsList = Array.from(document.querySelectorAll('.flashcard'));
            if (flashcardsList.length === 0) return;
            if (completedCards.has(currentCardIndex)) {
                // Si ya está completada, simplemente avanza
                goToNextCard();
                return;
            }

            // Marcar como incorrecta
            try {
                const currentCard = flashcardsList[currentCardIndex];
                const back = currentCard.querySelector('.back');
                const targetWord = currentCard.dataset.answer || (back ? back.textContent.trim() : '');
                if (targetWord) {
                    incorrectWords.push(targetWord);
                }
            } catch (e) { }
            incorrectCount += 1;
            completedCards.add(currentCardIndex);

            // Persistir y actualizar UI
            saveGameProgress();
            updateCounters();
            updateCardCounter();

            // Resetear contador de intentos para la siguiente tarjeta
            voiceAttempts = 0;

            // Habilitar botón mezclar al saltar tarjeta
            const shuffleBtn = document.getElementById('shuffle-button');
            if (shuffleBtn) {
                shuffleBtn.disabled = false;
            }

            // Si está visible el teclado virtual en móvil, ocultarlo y esconder el botón móvil "No sé"
            try {
                const vk = document.getElementById('vk');
                const vkOverlay = document.getElementById('vk-overlay');
                if (vk && vk.classList.contains('show')) {
                    vk.classList.remove('show');
                    setTimeout(() => { if (vkOverlay) vkOverlay.style.display = 'none'; }, 220);
                }

            } catch { }

            // Avanzar a la siguiente tarjeta
            goToNextCard();
        }

        function scheduleStatsBoxUpdate() {
            const statsBox = document.getElementById('stats-box');
            if (!statsBox) {
                // Fallback: aplicar inmediatamente
                updateCounters();
                if (typeof updateSuccessPercentage === 'function') updateSuccessPercentage();
                return;
            }
            // Cancelar temporizadores anteriores
            if (statsShowTimeoutId) { clearTimeout(statsShowTimeoutId); statsShowTimeoutId = null; }
            if (statsHideTimeoutId) { clearTimeout(statsHideTimeoutId); statsHideTimeoutId = null; }
            if (percentageUpdateTimeoutId) { clearTimeout(percentageUpdateTimeoutId); percentageUpdateTimeoutId = null; }

            // 1) Mostrar cuadro ahora mismo
            statsBox.classList.remove('hidden');
            // 2) En 2s, aplicar actualización del marcador
            statsShowTimeoutId = setTimeout(() => {
                updateCounters();
                if (typeof updateSuccessPercentage === 'function') updateSuccessPercentage();
                // 3) Mantener visible y ocultar 3s después
                statsHideTimeoutId = setTimeout(() => {
                    statsBox.classList.add('hidden');
                }, 3000);
            }, 2000);
        }

        // Función para normalizar el texto: quitar acentos, puntuación y a minúsculas.
function normalizeText(text) {
    if (!text) return "";
    return text.trim();
}

        // === SISTEMA DE PERMISOS DE MICRÓFONO ===
        let microphonePermissionGranted = null; // null = no preguntado, true = permitido, false = denegado
        let microphonePermissionAsked = false;

        // Helper: saber si el modal de micrófono ya está visible
        function isMicModalVisible() {
            const overlay = document.getElementById('microphone-permission-overlay');
            return !!(overlay && overlay.classList.contains('show') && overlay.style.display !== 'none');
        }

        // Verificar si ya se han pedido permisos anteriormente
        function checkPreviousMicrophonePermission() {
            const permission = localStorage.getItem('microphonePermissionGranted');
            if (permission !== null) {
                microphonePermissionGranted = permission === 'true';
                microphonePermissionAsked = true;
                console.log(`🎤 Permiso de micrófono previo: ${microphonePermissionGranted ? 'CONCEDIDO' : 'DENEGADO'}`);
            }
        }

        // Mostrar modal de permisos personalizado
        function showMicrophonePermissionModal() {
            return new Promise((resolve) => {
                const overlay = document.getElementById('microphone-permission-overlay');
                const allowBtn = document.getElementById('microphone-permission-allow');
                if (!overlay || !allowBtn) {
                    console.error('❌ No se pudo encontrar el modal de permisos');
                    resolve(false);
                    return;
                }
                // Mostrar overlay simple (como en la imagen)
                overlay.classList.add('show');
                overlay.style.pointerEvents = 'auto';
                overlay.style.display = 'flex';
                overlay.style.zIndex = '999999';

                const onAllow = async () => {
                    overlay.classList.remove('show');
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        microphonePermissionGranted = true;
                        microphonePermissionAsked = true;
                        localStorage.setItem('microphonePermissionGranted', 'true');
                        stream.getTracks().forEach(t => t.stop());
                        resolve(true);
                    } catch (e) {
                        microphonePermissionGranted = false;
                        microphonePermissionAsked = true;
                        localStorage.setItem('microphonePermissionGranted', 'false');
                        resolve(false);
                    } finally {
                        allowBtn.removeEventListener('click', onAllow);
                    }
                };
                allowBtn.addEventListener('click', onAllow, { once: true });
            });
        }

        // Función principal para manejar permisos de micrófono
        async function handleMicrophonePermission() {
            // Respetar estado previo desde localStorage (cargado por checkPreviousMicrophonePermission)
            if (microphonePermissionAsked && microphonePermissionGranted) {
                console.log('✅ Permisos de micrófono previamente concedidos');
                return true;
            }
            if (microphonePermissionAsked && !microphonePermissionGranted) {
                console.log('❌ Permisos de micrófono previamente denegados');
                return false;
            }

            // Primera vez: mostrar modal personalizado sin consultar APIs que disparen el prompt nativo
            console.log('🆕 Primera solicitud de permisos de micrófono (modal personalizado primero)');
            const result = await showMicrophonePermissionModal();
            if (!result) {
                console.log('❌ Permisos denegados');
                return false;
            }
            console.log('🎉 ¡Permisos de micrófono completamente concedidos!');
            return true;
        }

        // Inicializar sistema de permisos
        async function initializeMicrophonePermissions() {
            checkPreviousMicrophonePermission();
            // Intentar usar Permissions API si está disponible
            try {
                if (navigator.permissions && navigator.permissions.query) {
                    // Nota: Algunos navegadores no soportan { name: 'microphone' }
                    const status = await navigator.permissions.query({ name: 'microphone' });
                    if (status.state === 'granted') {
                        microphonePermissionGranted = true;
                        microphonePermissionAsked = true;
                        localStorage.setItem('microphonePermissionGranted', 'true');
                    } else if (status.state === 'denied') {
                        microphonePermissionGranted = false;
                        microphonePermissionAsked = true;
                        localStorage.setItem('microphonePermissionGranted', 'false');
                    } else {
                        // 'prompt'
                        microphonePermissionAsked = false;
                    }
                    status.onchange = () => {
                        const st = status.state;
                        microphonePermissionGranted = (st === 'granted');
                        microphonePermissionAsked = (st !== 'prompt');
                        localStorage.setItem('microphonePermissionGranted', microphonePermissionGranted ? 'true' : 'false');
                    };
                }
            } catch (e) {
                console.warn('Permissions API no disponible para micrófono:', e);
            }
            console.log('🎤 Sistema de permisos de micrófono inicializado');
        }


        function startVoiceRecognition(targetWord, backElement) {
            // Deshabilitado: el modo de juego es por escritura. Se mantiene solo "No sé" con el detector mínimo al voltear a back.
            console.log('Reconocimiento de voz deshabilitado: usar entrada escrita.');
            return;
        }

        // Función separada para el reconocimiento de voz real
        function startSpeechRecognition(targetWord, backElement) {
            // Deshabilitado: el modo de juego es por escritura. No iniciar reconocimiento ni UI.
            console.log('Reconocimiento de voz (speech) deshabilitado.');
            return;
        }
        // Indicador de escucha: deshabilitado en modo escrito
        function showListeningIndicator(backElement) { /* noop */ }
        function ensureIndicatorVisible(backElement) { /* noop */ }
        function removeListeningIndicator(backElement) { /* noop */ }
        // Limpieza del back: ya no preservamos indicadores de voz
        function clearBackContent(backElement) {
            if (!backElement) return;
            backElement.innerHTML = `
                    <div class=\"type-message\" id=\"type-message\" style=\"display:none;\"></div>
                    <div class=\"type-word-title\" id=\"type-word-title\" style=\"display:none;\"></div>
                    <div class=\"type-dialog-container\"> 
                        <div class=\"type-input-row\"> 
                            <input id=\"type-input\" class=\"type-input\" type=\"text\" autocomplete=\"off\" placeholder=\"Escribe aquí...\" />
                            <button id=\"check-button\" class=\"check-button\">comprobar</button>
                        </div>
                    </div>
                `;
            // Como fallback, intenta limpiar en la tarjeta visible
            const visibleBack = document.querySelector('.flashcard.is-visible .back');
            if (visibleBack) {
                visibleBack.querySelectorAll('.listening-indicator').forEach(el => el.remove());
            }
        }


        let isShuffling = false;
        // Límite de usos del botón Mezclar por partida
        let shuffleClickCount = 0;
        const SHUFFLE_MAX_CLICKS = 3;

        // Restaurar contador de Mezclar desde localStorage (persiste hasta fin de juego)
        try {
            const savedShuffle = parseInt(localStorage.getItem('silabas3_shuffleCount') || '0', 10);
            if (!isNaN(savedShuffle) && savedShuffle >= 0) {
                shuffleClickCount = savedShuffle;
            }
        } catch (e) { /* ignore */ }

        document.getElementById('shuffle-button').addEventListener('click', () => {
            // Si alcanzó el límite, mostrar aviso creativo y no mezclar
            if (shuffleClickCount >= SHUFFLE_MAX_CLICKS) {
                vibrar(60);
                const existing = document.getElementById('shuffle-limit-toast');
                if (existing) existing.remove();
                const toast = document.createElement('div');
                toast.id = 'shuffle-limit-toast';
                toast.innerHTML = `
            <div style="
                display: flex; align-items: center; justify-content: center;
                gap: 12px; font-size: 16px; font-weight: 600;">
                <span>Has mezclado 3 veces. ¡Ahora confía en tu memoria! 🧠</span>
            </div>`;
                toast.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(40,0,60,0.95) 0%, rgba(80,0,120,0.95) 100%);
            color: #fff; padding: 18px 24px; border-radius: 16px; font-weight: 600; font-size: 15px;
            z-index: 10000; backdrop-filter: blur(10px); border: 1px solid rgba(156,39,176,0.35);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 24px rgba(156,39,176,0.2);
            animation: modernFadeInOut 2.2s ease; min-width: 280px; text-align: center;`;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2200);
                return;
            }

            if (isShuffling) return;
            isShuffling = true;
            shuffleClickCount++;
            try { localStorage.setItem('silabas3_shuffleCount', String(shuffleClickCount)); } catch (e) { }

            vibrar(80);
            document.getElementById('shuffleSound').play().catch(() => { });
            shuffleCards();

            setTimeout(() => {
                isShuffling = false;
            }, 800); // Evita abusos rápidos
        });

        // Botón "No sé"
        const skipBtn = document.getElementById('skip-button');
        if (skipBtn) {
            skipBtn.addEventListener('click', () => {
                vibrar(60);
                playButtonSound();
                skipCurrentCardAsUnknown();
            });
        }

        let _successAudioEl = null;
        function playSuccessSound(onEnded) {
            try {
                if (!_successAudioEl) {
                    _successAudioEl = new Audio('https://fawzinoo.github.io/audios/win.mp3');
                    _successAudioEl.preload = 'auto';
                    _successAudioEl.volume = 0.7;
                    try { _successAudioEl.load(); } catch { }
                } else {
                    try { _successAudioEl.pause(); _successAudioEl.currentTime = 0; } catch { }
                }
                _successAudioEl.onended = null;
                if (typeof onEnded === 'function') _successAudioEl.onended = onEnded;
                _successAudioEl.play().catch(() => { if (typeof onEnded === 'function') onEnded(); });
                return _successAudioEl;
            } catch (e) {
                if (typeof onEnded === 'function') onEnded();
                return null;
            }
        }

        function showCountdown(card) {
            // Limpiar detección de teclado móvil si existe
            const back = card.querySelector('.back');
            if (back._cleanupKeyboardDetection) {
                back._cleanupKeyboardDetection();
                delete back._cleanupKeyboardDetection;
            }
            // Evitar countdowns duplicados
            if (back._countdownRunning) {
                console.log('⏳ Countdown ya en curso, se ignora');
                return;
            }
            back._countdownRunning = true;
            // Mantener visible el cuadro de escritura durante el countdown
            // Limpiar cualquier fallback previo
            try {
                if (back._countdownFallbackTimeout) {
                    clearTimeout(back._countdownFallbackTimeout);
                    back._countdownFallbackTimeout = null;
                }
            } catch (e) { }

            // Elimina cualquier timer previo
            back.querySelectorAll('.countdown-inline').forEach(el => el.remove());

            // Verificar si es la última tarjeta (tras marcar la actual como completada, remaining debe ser 0 si era la última)
            const flashcards = Array.from(document.querySelectorAll('.flashcard'));
            const remainingCards = flashcards.filter((_, index) => !completedCards.has(index)).length;
            const isLastCard = remainingCards <= 0;

            // Crea el contenedor del timer
            const timerDiv = document.createElement('div');
            timerDiv.className = 'countdown-inline';
            const messageText = isLastCard ? 'Finalizando...' : 'Siguiente tarjeta en...';
            timerDiv.innerHTML = `
        <div class="countdown-inline-circle">
            <span class="countdown-inline-number">3</span>
        </div>
        <div class="countdown-inline-text">${messageText}</div>
    `;
            back.appendChild(timerDiv);

            let count = 3;
            const numberSpan = timerDiv.querySelector('.countdown-inline-number');

            // Fallback de seguridad: forzar avance si el contador no termina
            try {
                back._countdownFallbackTimeout = setTimeout(() => {
                    try { timerDiv.remove(); } catch { }
                    back._countdownFallbackTimeout = null;
                    back._countdownRunning = false;
                    console.log('⛑️ Fallback de countdown: avanzando a la siguiente tarjeta');
                    goToNextCard();
                }, 5000);
            } catch (e) { }

            function updateCounter() {
                numberSpan.textContent = count;
                timerDiv.classList.remove('pulse-timer');
                void timerDiv.offsetWidth;
                timerDiv.classList.add('pulse-timer');
                if (count > 0) {
                    count--;
                    setTimeout(updateCounter, 1000);
                } else {
                    timerDiv.remove();
                    try {
                        if (back._countdownFallbackTimeout) {
                            clearTimeout(back._countdownFallbackTimeout);
                            back._countdownFallbackTimeout = null;
                        }
                    } catch (e) { }
                    back._countdownRunning = false;
                    console.log('🏁 Countdown terminado: llamando goToNextCard()');
                    goToNextCard();
                }
            }
            updateCounter();
        }

        function goToNextCard() {
            // Evitar flips accidentales por eventos residuales (tap/click) al avanzar
            // Bloquea momentáneamente el volteo hasta que termine la transición
            canFlip = false;
            // Cerrar cualquier teclado virtual activo y limpiar estados móviles
            try {
                const vkOverlay = document.getElementById('vk-overlay');
                const vk = document.getElementById('vk');
                if (vk && vkOverlay) {
                    vk.classList.remove('show');
                    vkOverlay.style.display = 'none';
                }
                // Clases globales de teclado/caret
                document.body.classList.remove('keyboard-visible');
                document.documentElement.classList.remove('keyboard-visible');
                document.body.classList.add('keyboard-hidden');
                document.documentElement.classList.add('keyboard-hidden');

            } catch (e) { }

            // Reactivar el botón de mezclar al pasar a la siguiente tarjeta
            document.getElementById('shuffle-button').disabled = false;

            // REPRODUCIR SONIDO DE NAIPE al cambiar de tarjeta
            document.getElementById('shuffleSound').play().catch(() => { });

            const flashcards = Array.from(document.querySelectorAll('.flashcard'));
            completedCards.add(currentCardIndex);
            updateCardCounter();

            // GUARDAR PROGRESO AUTOMÁTICAMENTE al completar una tarjeta
            saveGameProgress();

            canFlipBack = true; // Permitir voltear en la nueva tarjeta
            updateCounters();
            voiceAttempts = 0; // Reiniciar intentos para la nueva tarjeta
            // Cancelar cualquier timeout entre intentos por seguridad
            if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
            if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }
            showingErrorMessage = false;
            lockedAfterSecondIncorrect = false;
            lockedAfterCorrect = false;

            // Buscar la siguiente tarjeta pendiente empezando DESPUÉS de la actual (búsqueda circular)
            const total = flashcards.length;
            let nextIndex = -1;
            for (let step = 1; step <= total; step++) {
                const i = (currentCardIndex + step) % total;
                if (!completedCards.has(i)) {
                    nextIndex = i;
                    break;
                }
            }

            if (nextIndex !== -1) {
                currentCardIndex = nextIndex;
                showCard(currentCardIndex);
                // Rehabilitar el volteo tras un pequeño retardo para evitar flip indeseado
                setTimeout(() => { canFlip = true; }, 300);
            } else {
                // Guardar porcentaje del último partido jugado
                saveLastGamePercentage();

                // Decidir qué función llamar según el resultado
                if (correctCount > incorrectCount) {
                    // Verificar si es perfecto (sin errores)
                    if (incorrectCount === 0) {
                        showCompletionEuforiaMaxima(); // PERFECTO: sin errores
                    } else {
                        showCompletioneuforia(); // GANA: con algunos errores
                    }
                } else if (incorrectCount > correctCount) {
                    showCompletionPerdida(); // Perdió: mensaje motivacional
                } else {
                    showCompletionEmpate(); // Empate: mensaje equilibrado
                }
                // En pantallas finales no necesitamos flip, pero por seguridad reactivamos
                setTimeout(() => { canFlip = true; }, 300);
            }
        }

        function showCard(index) {
            // Al mostrar una tarjeta (siempre front), forzar cierre del teclado virtual
            try {
                const vkOverlay = document.getElementById('vk-overlay');
                const vk = document.getElementById('vk');
                if (vk && vkOverlay) {
                    vk.classList.remove('show');
                    vkOverlay.style.display = 'none';
                }
                document.body.classList.remove('keyboard-visible');
                document.documentElement.classList.remove('keyboard-visible');
                document.body.classList.add('keyboard-hidden');
                document.documentElement.classList.add('keyboard-hidden');
            } catch (e) { }
            const flashcards = Array.from(document.querySelectorAll('.flashcard'));
            flashcards.forEach(card => {
                card.classList.remove('is-visible', 'flipped');
                const back = card.querySelector('.back');
                // Elimina cualquier contador de intentos
                back.querySelectorAll('.intentos-back').forEach(el => el.remove());
                if (card.dataset.answer) {
                    back.innerHTML = card.dataset.answer;
                }
            });

            if (flashcards[index]) {
                flashcards[index].classList.add('is-visible');
            }
            preloadUpcomingImages(index, flashcards);
            updateCounters();
            // Al mostrar una tarjeta, estamos en front: habilitar skip
            betweenAttempts = false;
            updateSkipButtonState();
        }

        function preloadUpcomingImages(index, flashcards) {
            if (!Array.isArray(flashcards) || flashcards.length === 0) return;
            const total = flashcards.length;
            const indices = [index, (index + 1) % total, (index + 2) % total];
            indices.forEach(i => {
                const card = flashcards[i];
                if (!card) return;
                card.querySelectorAll('img').forEach(img => {
                    if (!img || !img.src) return;
                    if (img.complete) return;
                    const warm = new Image();
                    warm.src = img.src;
                });
            });
        }

        function updateProgress() {
            const flashcards = Array.from(document.querySelectorAll('.flashcard'));
            const totalCards = flashcards.length;
            const percentage = totalCards > 0 ? Math.round((completedCards.size / totalCards) * 100) : 0;
            const porcentajeDiv = document.getElementById('porcentaje-guardado');
            const porcentajeSpan = document.getElementById('current-percentage');
            if (porcentajeDiv && porcentajeSpan) {
                porcentajeSpan.textContent = `${percentage}%`;
            }
        }

        function updateCounters() {
            // Correctas
            const correctasPill = document.querySelector('.pill-correctas');
            const prevCorrect = Number(correctasPill.getAttribute('data-prev') || 0);
            document.getElementById('correctas-count').textContent = correctCount;

            if (correctCount > prevCorrect) {
                correctasPill.classList.remove('glow-correct');
                void correctasPill.offsetWidth; // Reinicia animación
                correctasPill.classList.add('glow-correct');
            }
            correctasPill.setAttribute('data-prev', correctCount);

            // Incorrectas
            const incorrectasPill = document.querySelector('.pill-incorrectas');
            const prevIncorrect = Number(incorrectasPill.getAttribute('data-prev') || 0);
            document.getElementById('incorrectas-count').textContent = incorrectCount;

            if (incorrectCount > prevIncorrect) {
                incorrectasPill.classList.remove('glow-error');
                void incorrectasPill.offsetWidth; // Reinicia animación
                incorrectasPill.classList.add('glow-error');
            }
            incorrectasPill.setAttribute('data-prev', incorrectCount);

            updateCardCounter();
        }

        function showCompletionEuforiaMaxima() {
            // LIMPIAR PROGRESO GUARDADO al completar el juego
            clearCurrentProgress();
            // Desactivar Mezclar en fin de juego
            try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch { }

            // Reproducir audio de victoria máxima
            const audioVictoriaMaxima = new Audio('https://fawzinoo.github.io/audios/victoriamaxima.mp3');
            audioVictoriaMaxima.play().catch(error => {
                console.log('Error al reproducir audio de victoria máxima:', error);
            });

            // Crear overlay que cubra toda la pantalla
            const fullScreenOverlay = document.createElement('div');
            fullScreenOverlay.id = 'euforia-maxima-overlay';
            fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(45deg, #FFD700 0%, #FFA500 25%, #FF4500 50%, #FF1493 75%, #9932CC 100%);
        background-size: 400% 400%;
        animation: rainbowBackground 3s ease infinite, perfectEntrance 1s ease-out;
    `;

            fullScreenOverlay.innerHTML = `
        <div id="trophy-container" style="font-size: 4rem; margin-bottom: 20px; animation: perfectExplosion 1.5s infinite;">🏆</div>
        <div style="font-size: 4rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255,255,255,1); animation: perfectShine 2s ease-in-out infinite;">
            ¡PERFECTO!
        </div>
        <div style="font-size: 2.5rem; margin-bottom: 10px; opacity: 0.95; animation: goldenGlow 2.5s ease-in-out infinite;">
            ¡Sin errores! ¡Eres increíble!
        </div>
        <div style="font-size: 1.8rem; opacity: 0.9; animation: diamondSpark 2s infinite;">
            ¡PUNTUACIÓN MÁXIMA!
        </div>
    `;

            // Añadir el overlay al body
            document.body.appendChild(fullScreenOverlay);

            // Efecto de confeti DOBLE para perfecto
            confetti({
                particleCount: 200,
                spread: 100,
                origin: { y: 0.4 }
            });

            // Segundo confeti con delay
            const confettiTimeoutId = setTimeout(() => {
                confetti({
                    particleCount: 150,
                    spread: 80,
                    origin: { y: 0.7 }
                });
            }, 500);

            // DETENER la animación de la copa después de 3 segundos
            const trophyTimeoutId = setTimeout(() => {
                const trophyContainer = fullScreenOverlay.querySelector('#trophy-container');
                if (trophyContainer) {
                    trophyContainer.style.animation = 'none';
                }
            }, 3000);

            // Permitir salto por clic o toque en cualquier parte
            let skipped = false;
            const clearAll = () => {
                if (skipped) return; skipped = true;
                try { audioVictoriaMaxima.pause(); audioVictoriaMaxima.currentTime = 0; } catch (e) { }
                try { clearTimeout(confettiTimeoutId); } catch (e) { }
                try { clearTimeout(trophyTimeoutId); } catch (e) { }
                if (typeof confetti === 'function' && typeof confetti.reset === 'function') {
                    try { confetti.reset(); } catch (e) { }
                }
                if (fullScreenOverlay && fullScreenOverlay.parentNode) {
                    fullScreenOverlay.remove();
                }
                document.removeEventListener('click', onSkip, true);
                document.removeEventListener('touchstart', onSkip, true);
                showCompletionMessage();
            };
            const onSkip = () => clearAll();
            document.addEventListener('click', onSkip, true);
            document.addEventListener('touchstart', onSkip, true);

            // Fallback automático
            const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
        }

        function showCompletioneuforia() {
            // LIMPIAR PROGRESO GUARDADO al completar el juego
            clearCurrentProgress();
            // Desactivar Mezclar en fin de juego
            try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch { }

            // Reproducir audio de victoria normal
            const audioVictoriaNormal = new Audio('https://fawzinoo.github.io/audios/victorianormal.mp3');
            audioVictoriaNormal.play().catch(error => {
                console.log('Error al reproducir audio de victoria normal:', error);
            });

            // Crear overlay que cubra toda la pantalla
            const fullScreenOverlay = document.createElement('div');
            fullScreenOverlay.id = 'euforia-overlay';
            fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #28a745 0%, #20c997 50%, #17a2b8 100%);
        animation: euforiaEntrance 0.8s ease-out;
    `;

            fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: celebrationBounce 1.2s infinite;">🥇</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: euforiaWiggle 1.5s ease-in-out infinite;">
            ¡FANTÁSTICO!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: happyFloat 2s ease-in-out infinite;">
            ¡Excelente resultado!
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: sparkle 1.8s infinite;">
            Calculando puntuación...
        </div>
    `;

            // Añadir el overlay al body
            document.body.appendChild(fullScreenOverlay);

            // Efecto de confeti normal
            confetti({
                particleCount: 150,
                spread: 70,
                origin: { y: 0.6 }
            });

            // Permitir salto por clic o toque en cualquier parte
            let skipped = false;
            const clearAll = () => {
                if (skipped) return; skipped = true;
                try { audioVictoriaNormal.pause(); audioVictoriaNormal.currentTime = 0; } catch (e) { }
                if (typeof confetti === 'function' && typeof confetti.reset === 'function') {
                    try { confetti.reset(); } catch (e) { }
                }
                if (fullScreenOverlay && fullScreenOverlay.parentNode) {
                    fullScreenOverlay.remove();
                }
                document.removeEventListener('click', onSkip, true);
                document.removeEventListener('touchstart', onSkip, true);
                showCompletionMessage();
            };
            const onSkip = () => clearAll();
            document.addEventListener('click', onSkip, true);
            document.addEventListener('touchstart', onSkip, true);

            const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
        }

        function showCompletionPerdida() {
            // LIMPIAR PROGRESO GUARDADO al completar el juego
            clearCurrentProgress();
            // Desactivar Mezclar en fin de juego
            try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch { }

            // Reproducir audio de derrota
            const audioDerrota = new Audio('https://fawzinoo.github.io/audios/derrota.mp3');
            audioDerrota.play().catch(error => {
                console.log('Error al reproducir audio de derrota:', error);
            });

            // Crear overlay que cubra toda la pantalla
            const fullScreenOverlay = document.createElement('div');
            fullScreenOverlay.id = 'perdida-overlay';
            fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 50%, #fd79a8 100%);
        animation: sadFadeIn 1s ease-in;
    `;

            fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: sadDrop 2s ease-out infinite;">😔</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: disappointedSway 2.5s ease-in-out infinite;">
            ¡A seguir practicando!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: gentleFloat 3s ease-in-out infinite;">
            La práctica hace al maestro
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: fadingHope 2.2s infinite;">
            Calculando resultados...
        </div>
    `;

            // Añadir el overlay al body
            document.body.appendChild(fullScreenOverlay);

            // NO hay confeti para perdida

            // Permitir salto por clic o toque en cualquier parte
            let skipped = false;
            const clearAll = () => {
                if (skipped) return; skipped = true;
                try { audioDerrota.pause(); audioDerrota.currentTime = 0; } catch (e) { }
                if (fullScreenOverlay && fullScreenOverlay.parentNode) {
                    fullScreenOverlay.remove();
                }
                document.removeEventListener('click', onSkip, true);
                document.removeEventListener('touchstart', onSkip, true);
                showCompletionMessage();
            };
            const onSkip = () => clearAll();
            document.addEventListener('click', onSkip, true);
            document.addEventListener('touchstart', onSkip, true);

            const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
        }

        function showCompletionEmpate() {
            // LIMPIAR PROGRESO GUARDADO al completar el juego
            clearCurrentProgress();
            // Desactivar Mezclar en fin de juego
            try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch { }

            // Reproducir audio de empate (palpitaciones)
            const audioEmpate = new Audio('https://fawzinoo.github.io/audios/empate.mp3');
            audioEmpate.play().catch(error => {
                console.log('Error al reproducir audio de empate:', error);
            });

            // Crear overlay que cubra toda la pantalla
            const fullScreenOverlay = document.createElement('div');
            fullScreenOverlay.id = 'empate-overlay';
            fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #74b9ff 0%, #0984e3 50%, #6c5ce7 100%);
        animation: neutralZoom 0.6s ease-out;
    `;

            fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: balanceSway 2s ease-in-out infinite;">⚖️</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: steadyPulse 2s infinite;">
            ¡Empate perfecto!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: calmWave 2.5s ease-in-out infinite;">
            Resultado equilibrado
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: steadyGlow 2s infinite;">
            Analizando desempeño...
        </div>
    `;

            // Añadir el overlay al body
            document.body.appendChild(fullScreenOverlay);

            // NO hay confeti para empate

            // Permitir salto por clic o toque en cualquier parte
            let skipped = false;
            const clearAll = () => {
                if (skipped) return; skipped = true;
                try { audioEmpate.pause(); audioEmpate.currentTime = 0; } catch (e) { }
                if (fullScreenOverlay && fullScreenOverlay.parentNode) {
                    fullScreenOverlay.remove();
                }
                document.removeEventListener('click', onSkip, true);
                document.removeEventListener('touchstart', onSkip, true);
                showCompletionMessage();
            };
            const onSkip = () => clearAll();
            document.addEventListener('click', onSkip, true);
            document.addEventListener('touchstart', onSkip, true);

            const finishTimeoutId = setTimeout(() => { clearAll(); }, 9000);
        }
        function showCompletionMessage() {

            const container = document.getElementById('flashcard-container');
            // Mantener Mezclar desactivado en la pantalla final
            try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch { }

            if (correctCount > incorrectCount) {
                if (incorrectCount === 0) {
                    // CASO 1A: Victoria PERFECTA (sin errores) - Diseño moderno dorado/negro
                    container.innerHTML = `
                <div style="
                    display: flex; 
                    flex-direction: column; 
                    justify-content: center; 
                    align-items: center; 
                    height: 100%; 
                    color: white; 
                    text-align: center;
                    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #1a1a1a 100%);
                    border-radius: 25px;
                    position: relative;
                    overflow: hidden;
                    border: 2px solid #FFD700;
                ">
                    <div style="
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: radial-gradient(circle at 30% 20%, rgba(255,215,0,0.1) 0%, transparent 50%),
                                    radial-gradient(circle at 70% 80%, rgba(255,215,0,0.05) 0%, transparent 50%);
                    "></div>
                    
                    <div id="final-trophy" style="font-size: 4rem; margin-bottom: 30px; animation: perfectExplosion 2s infinite; filter: drop-shadow(0 0 20px #FFD700);">🏆</div>
                    
                    <div style="
                        background: linear-gradient(135deg, rgba(26,26,26,0.95) 0%, rgba(45,45,45,0.95) 100%);
                        padding: 25px 35px;
                        border-radius: 20px;
                        backdrop-filter: blur(20px);
                        border: 1px solid rgba(255,215,0,0.3);
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 0 20px rgba(255,215,0,0.1);
                        margin-bottom: 20px;
                        width: 280px;
                    ">
                        <div style="font-size: 1.1rem; margin-bottom: 20px; color: #FFD700; font-weight: 600; letter-spacing: 1px;">
                            ⭐ PUNTUACIÓN MÁXIMA ⭐
                        </div>
                        <div id="correct-words-btn" style="
                            font-size: 1.1rem; 
                            color: #ffffff; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(0,200,81,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                            font-weight: 500;
                            animation: pulse 2s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                            ✅ Correctas: ${correctCount} (Ver)
                        </div>
                        <div style="
                            font-size: 1.1rem; 
                            color: white; 
                            opacity: 0.7; 
                            font-weight: 500;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, rgba(136,136,136,0.2) 0%, rgba(136,136,136,0.1) 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(136,136,136,0.3);
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        ">
                            ❌ Incorrectas: ${incorrectCount}
                        </div>
                        <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #FFD700; font-weight: 400; text-align: center;">
                            Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                        </div>
                    </div>
                </div>
            `;
                } else {
                    // CASO 1B: Victoria NORMAL - Diseño moderno azul/gris
                    container.innerHTML = `
                <div style="
                    display: flex; 
                    flex-direction: column; 
                    justify-content: center; 
                    align-items: center; 
                    height: 100%; 
                    color: white; 
                    text-align: center;
                    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
                    border-radius: 25px;
                    position: relative;
                    overflow: hidden;
                    border: 2px solid #4FC3F7;
                ">
                    <div style="
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: radial-gradient(circle at 30% 20%, rgba(79,195,247,0.1) 0%, transparent 50%),
                                    radial-gradient(circle at 70% 80%, rgba(79,195,247,0.05) 0%, transparent 50%);
                    "></div>
                    
                    <div id="celebration-emoji" style="font-size: 4rem; margin-bottom: 30px; animation: perfectExplosion 2s infinite; filter: drop-shadow(0 0 20px #4FC3F7);">🥇</div>
                    
                    <div style="
                        background: linear-gradient(135deg, rgba(30,60,114,0.95) 0%, rgba(42,82,152,0.95) 100%);
                        padding: 25px 35px;
                        border-radius: 20px;
                        backdrop-filter: blur(20px);
                        border: 1px solid rgba(79,195,247,0.3);
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 0 20px rgba(79,195,247,0.1);
                        margin-bottom: 20px;
                        width: 280px;
                    ">
                        <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡ENHORABUENA!
                        </div>
                         <div id="correct-words-btn" style="
                            font-size: 1.1rem; 
                            color: #ffffff; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(0,200,81,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                            font-weight: 500;
                            animation: alternatePulse 4s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                            ✅ Correctas: ${correctCount} (Ver)
                        </div>
                        <div id="incorrect-words-btn" style="
                              font-size: 1.1rem; 
                            color: white; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(255,87,34,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                            font-weight: 500;
                            animation: alternatePulseIncorrect 4s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                            ❌ Incorrectas: ${incorrectCount} (Ver)
                        </div>
                        <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #B0BEC5; font-weight: 400; text-align: center;">
                            Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                        </div>
                    </div>
                </div>
            `;
                }
            } else if (incorrectCount > correctCount) {
                // CASO 2: Pérdida - Diseño moderno púrpura/gris
                container.innerHTML = `
            <div style="
                display: flex; 
                flex-direction: column; 
                justify-content: center; 
                align-items: center; 
                height: 100%; 
                color: white; 
                text-align: center;
                background: linear-gradient(135deg, #4A148C 0%, #6A1B9A 50%, #4A148C 100%);
                border-radius: 25px;
                position: relative;
                overflow: hidden;
                border: 2px solid #BA68C8;
            ">
                <div style="font-size: 4rem; margin-bottom: 25px; filter: drop-shadow(0 0 15px #BA68C8);">😔</div>
              
               
                <div style="
                    background: linear-gradient(135deg, rgba(74,20,140,0.95) 0%, rgba(106,27,154,0.95) 100%);
                    padding: 20px 30px;
                    border-radius: 18px;
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(186,104,200,0.3);
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    width: 280px;
                ">
                 <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡A SEGUIR PRACTICANDO!
                        </div>
                    <div id="correct-words-btn" style="
                        font-size: 1.1rem; 
                        margin-bottom: 12px;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(0,200,81,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                        font-weight: 500;
                        animation: alternatePulse 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                        ✅ Correctas: ${correctCount} (Ver)
                    </div>
                    <div id="incorrect-words-btn" style="
                        font-size: 1.1rem;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(255,87,34,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                        font-weight: 500;
                        animation: alternatePulseIncorrect 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                        ❌ Incorrectas: ${incorrectCount} (Ver)
                    </div>
                    <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #BA68C8; font-weight: 400; text-align: center;">
                        Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                    </div>
                </div>
            </div>
        `;
            } else {
                // CASO 3: Empate - Diseño moderno gris/plateado
                container.innerHTML = `
            <div style="
                display: flex; 
                flex-direction: column; 
                justify-content: center; 
                align-items: center; 
                height: 100%; 
                color: white; 
                text-align: center;
                background: linear-gradient(135deg, #37474F 0%, #546E7A 50%, #37474F 100%);
                border-radius: 25px;
                position: relative;
                overflow: hidden;
                border: 2px solid #90A4AE;
            ">
                <div style="font-size: 4rem; margin-bottom: 25px; filter: drop-shadow(0 0 15px #90A4AE);">⚖️</div>
             
               
                <div style="
                    background: linear-gradient(135deg, rgba(55,71,79,0.95) 0%, rgba(84,110,122,0.95) 100%);
                    padding: 20px 30px;
                    border-radius: 18px;
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(144,164,174,0.3);
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    width: 280px;
                ">
                   <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡EMPATE PERFECTO!
                        </div>
                      <div id="correct-words-btn" style="
                        font-size: 1.1rem; 
                        margin-bottom: 12px;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(0,200,81,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                        font-weight: 500;
                        animation: alternatePulse 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                        ✅ Correctas: ${correctCount} (Ver)
                    </div>
                    <div id="incorrect-words-btn" style="
                        font-size: 1.1rem;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(255,87,34,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                        font-weight: 500;
                        animation: alternatePulseIncorrect 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                        ❌ Incorrectas: ${incorrectCount} (Ver)
                    </div>
                    <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #90A4AE; font-weight: 400; text-align: center;">
                        Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                    </div>
                </div>
            </div>
        `;
            }

            // DETENER SOLO las animaciones del fondo y elementos decorativos después de 3 segundos
            // PERO MANTENER la animación pulse del botón verde
            setTimeout(() => {
                const finalTrophy = document.getElementById('final-trophy');
                const celebrationEmoji = document.getElementById('celebration-emoji');
                const containerDiv = container.firstElementChild;

                if (finalTrophy) finalTrophy.style.animation = 'none';
                if (celebrationEmoji) celebrationEmoji.style.animation = 'none';
                if (containerDiv) containerDiv.style.animation = 'none';

                // ⭐ NO detener la animación pulse del botón verde
                // Línea eliminada: if (correctBtn) correctBtn.style.animation = 'none';
            }, 3000);

            // AÑADIR EVENT LISTENERS para los botones clicables
            // y desactivar/quitar (Ver) cuando la lista esté vacía (calco de sel-idiomas)
            setTimeout(() => {
                const correctBtn = document.getElementById('correct-words-btn');
                const incorrectBtn = document.getElementById('incorrect-words-btn');

                if (correctBtn) {
                    if (Array.isArray(correctWords) && correctWords.length > 0) {
                        correctBtn.addEventListener('click', function () {
                            vibrar(50);
                            playButtonSound();
                            showCorrectWords();
                        });
                    } else {
                        // Desactivar y quitar (Ver)
                        correctBtn.style.pointerEvents = 'none';
                        correctBtn.style.cursor = 'default';
                        correctBtn.style.animation = 'none';
                        correctBtn.innerHTML = `✅ Correctas: ${correctCount}`;
                    }
                }

                if (incorrectBtn) {
                    if (Array.isArray(incorrectWords) && incorrectWords.length > 0) {
                        incorrectBtn.addEventListener('click', function () {
                            vibrar(50);
                            playButtonSound();
                            showIncorrectWords();
                        });
                    } else {
                        // Desactivar y quitar (Ver)
                        incorrectBtn.style.pointerEvents = 'none';
                        incorrectBtn.style.cursor = 'default';
                        incorrectBtn.style.animation = 'none';
                        incorrectBtn.innerHTML = `❌ Incorrectas: ${incorrectCount}`;
                    }
                }
            }, 100);

            const triggerInitialOverlay = () => {
                if (Array.isArray(incorrectWords) && incorrectWords.length > 0) {
                    setTimeout(() => showIncorrectWords(), 420);
                } else if (Array.isArray(correctWords) && correctWords.length > 0) {
                    setTimeout(() => showCorrectWords(), 420);
                }
            };
            triggerInitialOverlay();

        }

        const escapeForOnclick = (str) => (str || '').replace(/'/g, "\\'");

        // Función para mostrar palabras correctas
        function showCorrectWords() {
            const overlay = document.createElement('div');
            overlay.id = 'correct-words-overlay';
            overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;

            const detailList = correctWordDetails.length > 0
                ? correctWordDetails
                : correctWords.map(word => ({ front: '', back: word }));
            const wordsHtml = detailList.length > 0
                ? detailList.map(entry => `
                <div class="result-word-card correct-result-card" onclick="vibrar(50); playButtonSound(); showItemImage('${escapeForOnclick(entry.back)}')">
                    <div class="result-word-text">${entry.back}</div>
                    <div class="result-word-action" aria-label="Ver imagen de ${entry.back}">✓</div>
                </div>
            `).join('')
                : '<div class="no-words-message"><span class="no-words-icon">🎯</span><p>No hay tarjetas acertadas</p></div>';

            overlay.innerHTML = `
        <div class="modal-container correct-modal">
            <div class="modal-header">
                <div class="modal-title-row">
                    <h2 class="modal-title">Palabras Acertadas</h2>
                </div>
                <div class="modal-stats">${correctWords.length} ${correctWords.length === 1 ? 'palabra' : 'palabras'}</div>
            </div>
            
            <div class="modal-content">
                <div class="words-container">
                    ${wordsHtml}
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="modal-close-btn correct-btn" onclick="vibrar(50); playButtonSound(); document.getElementById('correct-words-overlay').remove()">
                    <span>Cerrar</span>
                </button>
            </div>
        </div>
    `;

            document.body.appendChild(overlay);

            // Cerrar modal al hacer clic en el fondo
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    vibrar(50);
                    playButtonSound();
                    overlay.remove();
                }
            });
        }

        // Función para mostrar palabras incorrectas
        function showIncorrectWords() {
            const overlay = document.createElement('div');
            overlay.id = 'incorrect-words-overlay';
            overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;

            const detailList = incorrectWordDetails.length > 0
                ? incorrectWordDetails
                : incorrectWords.map(word => ({ front: '', back: word }));
            const wordsHtml = detailList.length > 0
                ? detailList.map(entry => `
                <div class="result-word-card incorrect-result-card" onclick="vibrar(50); playButtonSound(); showItemImage('${escapeForOnclick(entry.back)}')" role="button">
                    <div class="result-word-text">${entry.back}</div>
                    <div class="result-word-action" aria-label="Ver imagen de ${entry.back}">✗</div>
                </div>
            `).join('')
                : '<div class="no-words-message"><span class="no-words-icon">🎯</span><p>No hay tarjetas incorrectas</p></div>';

            overlay.innerHTML = `
        <div class="modal-container incorrect-modal">
            <div class="modal-header">
                <div class="modal-title-row">
                    <h2 class="modal-title">Palabras Incorrectas</h2>
                </div>
                <div class="modal-stats">${incorrectWords.length} ${incorrectWords.length === 1 ? 'palabra' : 'palabras'}</div>
            </div>
            
            <div class="modal-content">
                <div class="words-container">
                    ${wordsHtml}
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="modal-close-btn incorrect-btn" onclick="vibrar(50); playButtonSound(); document.getElementById('incorrect-words-overlay').remove()">
                    <span>Cerrar</span>
                </button>
            </div>
        </div>
    `;

            document.body.appendChild(overlay);

            // Cerrar modal al hacer clic en el fondo
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    vibrar(50);
                    playButtonSound();
                    overlay.remove();
                }
            });
        }

        // Variables para rastrear palabras correctas e incorrectas
        let correctWords = [];
        let incorrectWords = [];
        let correctWordDetails = [];
        let incorrectWordDetails = [];

        // ============ SISTEMA DE PERSISTENCIA DE PROGRESO ============
        // Función para guardar el progreso actual en localStorage
        function saveGameProgress() {
            const gameState = {
                currentCardIndex: currentCardIndex,
                completedCards: Array.from(completedCards),
                correctCount: correctCount,
                incorrectCount: incorrectCount,
                correctWords: [...correctWords],
                incorrectWords: [...incorrectWords],
                correctWordDetails: [...correctWordDetails],
                incorrectWordDetails: [...incorrectWordDetails],
                voiceAttempts: voiceAttempts,
                timestamp: Date.now(),
                cardOrder: flashcards.map(card => {
                    const frontImgEl = getFrontImage(card);
                    return {
                        frontImg: frontImgEl ? frontImgEl.src : '',
                        frontAlt: frontImgEl ? frontImgEl.alt : '',
                        frontText: getFrontTextFromCard(card),
                        backText: getBackTextFromCard(card)
                    };
                })
            };

            try {
                const stateString = JSON.stringify(gameState);
                localStorage.setItem('silabas3_gameProgress', stateString); // ✅ Cambiado de silabas2_gameProgress
                console.log(`✅ Progreso guardado automáticamente. voiceAttempts: ${voiceAttempts}`);
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    console.warn('⚠️ LocalStorage lleno, limpiando datos antiguos del tema actual...');
                    clearOldThemeData();

                    try {
                        localStorage.setItem('silabas3_gameProgress', JSON.stringify(gameState)); // ✅ Cambiado
                        console.log('✅ Progreso guardado después de limpiar datos del tema');
                    } catch (secondError) {
                        console.error('❌ Error persistente al guardar progreso:', secondError);
                        const minimalState = {
                            currentCardIndex: currentCardIndex,
                            completedCards: Array.from(completedCards),
                            correctCount: correctCount,
                            incorrectCount: incorrectCount,
                            voiceAttempts: voiceAttempts,
                            timestamp: Date.now()
                        };
                        try {
                            localStorage.setItem('silabas3_gameProgress', JSON.stringify(minimalState)); // ✅ Cambiado
                            console.log('✅ Progreso mínimo guardado exitosamente');
                        } catch (finalError) {
                            console.error('💥 No se pudo guardar ningún progreso:', finalError);
                        }
                    }
                } else {
                    console.error('❌ Error inesperado al guardar progreso:', error);
                }
            }
        }

        // Nueva función que SOLO limpia datos del tema actual, respeta otros temas
        function clearOldThemeData() {
            console.log('🧹 Limpiando datos antiguos SOLO del tema actual...');

            // ✅ Claves estandarizadas con silabas3
            const currentThemeKeys = [
                'silabas3_gameProgress',       // progreso actual del tema
                'silabas3',                    // último resultado del tema (ya correcto)
                'silabas3Date',                // fecha del último resultado (ya correcto)
            ];

            const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);

            currentThemeKeys.forEach(key => {
                const data = localStorage.getItem(key);
                if (data) {
                    try {
                        if (key.includes('gameProgress')) {
                            const parsed = JSON.parse(data);
                            if (parsed.timestamp && parsed.timestamp < weekAgo) {
                                localStorage.removeItem(key);
                                console.log(`🗓️ Eliminado progreso antiguo: ${key}`);
                            }
                        }
                        else if (key.includes('Date')) {
                            const date = new Date(data);
                            if (date.getTime() < weekAgo) {
                                const associatedKey = key.replace('Date', '');
                                localStorage.removeItem(key);
                                localStorage.removeItem(associatedKey);
                                console.log(`🗓️ Eliminados datos antiguos: ${key}, ${associatedKey}`);
                            }
                        }
                    } catch (e) {
                        if (key === 'silabas3_gameProgress') { // ✅ Cambiado
                            localStorage.removeItem(key);
                            console.log(`🔧 Eliminados datos corruptos: ${key}`);
                        }
                    }
                }
            });

            // Limpiar datos temporales/cache genéricos (seguros de eliminar)
            const safeToClearPatterns = [
                /^temp_/,
                /^cache_/,
                /^session_/,
                /^tmp_/,
            ];

            const allKeys = [];
            for (let i = 0; i < localStorage.length; i++) {
                allKeys.push(localStorage.key(i));
            }

            let clearedGeneric = 0;
            allKeys.forEach(key => {
                if (key && safeToClearPatterns.some(pattern => pattern.test(key))) {
                    localStorage.removeItem(key);
                    clearedGeneric++;
                }
            });

            if (clearedGeneric > 0) {
                console.log(`🗑️ Eliminadas ${clearedGeneric} entradas temporales genéricas`);
            }

            console.log('✅ Limpieza completada - otros temas preservados');
        }

        function clearOldStorageData() {
            console.log('🧹 Limpiando localStorage...');

            // Lista de claves a mantener (datos importantes) - actualizada con silabas3
            const keepKeys = [
                'silabas3_gameProgress',      // ✅ Cambiado
                'lastSuccessPercentage',
                'lastUpdateDate',
                'silabas3',                   // ✅ Ya correcto
                'silabas3Date',               // ✅ Ya correcto
                'microphonePermissionGranted'
            ];

            // Obtener todas las claves y eliminar las que no son esenciales
            const allKeys = [];
            for (let i = 0; i < localStorage.length; i++) {
                allKeys.push(localStorage.key(i));
            }

            let clearedItems = 0;
            allKeys.forEach(key => {
                if (key && !keepKeys.includes(key)) {
                    localStorage.removeItem(key);
                    clearedItems++;
                }
            });

            console.log(`🗑️ Eliminadas ${clearedItems} entradas antiguas de localStorage`);

            // Si todavía hay problemas, optimizar los datos que sí guardamos
            if (clearedItems === 0) {
                console.log('🔧 Optimizando datos existentes...');

                // Eliminar datos de progreso muy antiguos (más de 7 días)
                const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                const savedProgress = localStorage.getItem('silabas3_gameProgress'); // ✅ Cambiado

                if (savedProgress) {
                    try {
                        const data = JSON.parse(savedProgress);
                        if (data.timestamp && data.timestamp < weekAgo) {
                            localStorage.removeItem('silabas3_gameProgress'); // ✅ Cambiado
                            console.log('🗓️ Eliminado progreso muy antiguo');
                        }
                    } catch (e) {
                        // Si hay datos corruptos, eliminarlos
                        localStorage.removeItem('silabas3_gameProgress'); // ✅ Cambiado
                        console.log('🔧 Eliminados datos corruptos');
                    }
                }
            }
        }

        // Función para cargar el progreso desde localStorage
        function loadGameProgress() {
            const savedState = localStorage.getItem('silabas3_gameProgress'); // ✅ Cambiado
            if (!savedState) return null;

            try {
                const parsedState = JSON.parse(savedState);
                const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                if (parsedState.timestamp && parsedState.timestamp < weekAgo) {
                    console.log('🗓️ Progreso guardado muy antiguo, ignorando...');
                    localStorage.removeItem('silabas3_gameProgress'); // ✅ Cambiado
                    return null;
                }
                return parsedState;
            } catch (error) {
                console.error('❌ Error al cargar progreso guardado:', error);
                localStorage.removeItem('silabas3_gameProgress'); // ✅ Cambiado
                return null;
            }
        }

        // Función para restaurar el estado del juego
        function restoreGameState(gameState) {
            if (!gameState) return false;

            try {
                // Restaurar variables de estado
                currentCardIndex = gameState.currentCardIndex || 0;
                completedCards = new Set(gameState.completedCards || []);
                correctCount = gameState.correctCount || 0;
                incorrectCount = gameState.incorrectCount || 0;
                correctWords = [...(gameState.correctWords || [])];
                incorrectWords = [...(gameState.incorrectWords || [])];
                correctWordDetails = Array.isArray(gameState.correctWordDetails) ? [...gameState.correctWordDetails] : correctWords.map(word => ({ front: '', back: word }));
                incorrectWordDetails = Array.isArray(gameState.incorrectWordDetails) ? [...gameState.incorrectWordDetails] : incorrectWords.map(word => ({ front: '', back: word }));
                voiceAttempts = gameState.voiceAttempts || 0;

                // Restaurar orden de tarjetas si existe
                if (gameState.cardOrder && gameState.cardOrder.length === flashcards.length) {
                    flashcards.forEach((card, index) => {
                        const cardData = gameState.cardOrder[index];
                        if (cardData) {
                            const frontImgEl = getFrontImage(card);
                            setFrontText(card, cardData.frontText || '');
                            if (frontImgEl) {
                                if (cardData.frontImg) frontImgEl.src = cardData.frontImg;
                                frontImgEl.alt = cardData.frontAlt || '';
                            }
                            const back = card.querySelector('.back');
                            back.innerHTML = cardData.backText;
                            card.dataset.answer = cardData.backText;
                        }
                    });
                }

                // Reasignar audios a cada tarjeta según su respuesta (por si el orden se cambió)
                reassignAudiosToCards();

                // IMPORTANTE: Resetear el estado de las tarjetas al restaurar
                flashcards.forEach(card => {
                    card.classList.remove('is-visible', 'flipped');
                    const back = card.querySelector('.back');
                    // Limpiar cualquier indicador de escucha previo
                    back.querySelectorAll('.listening-indicator').forEach(el => el.remove());
                    back.classList.remove('hidden-text');
                });

                // Si el índice actual apunta a una tarjeta ya completada, avanzar a la primera pendiente empezando desde la siguiente (circular)
                try {
                    const total = flashcards.length;
                    if (total > 0 && completedCards.has(currentCardIndex)) {
                        for (let step = 1; step <= total; step++) {
                            const i = (currentCardIndex + step) % total;
                            if (!completedCards.has(i)) { currentCardIndex = i; break; }
                        }
                    }
                } catch (e) { }

                // Actualizar interfaz
                updateCounters();
                updateCardCounter();
                updateSuccessPercentage();

                // Mostrar tarjeta actual
                showCard(currentCardIndex);

                console.log('Estado del juego restaurado exitosamente');
                console.log(`Restaurado: voiceAttempts=${voiceAttempts}, currentCardIndex=${currentCardIndex}, correctCount=${correctCount}, incorrectCount=${incorrectCount}`);
                return true;
            } catch (error) {
                console.error('Error al restaurar estado del juego:', error);
                return false;
            }
        }

        // Función para limpiar solo el progreso actual (mantener avance anterior)
        function clearCurrentProgress() {
            localStorage.removeItem('silabas3_gameProgress');
            console.log('Progreso actual limpiado');
        }

        // Función para verificar si hay progreso guardado Y el juego NO está completado
        function hasProgressSaved() {
            const savedState = loadGameProgress();
            if (!savedState) return false;

            // Verificar si el juego está completado
            const totalCards = flashcards.length;
            const completedCount = savedState.completedCards ? savedState.completedCards.length : 0;
            const isGameCompleted = completedCount >= totalCards;

            // Si el juego está completado, NO mostrar modal de continuación
            if (isGameCompleted) {
                console.log('Juego completado detectado, limpiando progreso y reiniciando');
                // Marcar que se permite usar "Reiniciar" solo en este momento/post-carga
                try { sessionStorage.setItem('resetAllowedCompletedSavedGame', 'true'); } catch (e) { }
                clearCurrentProgress();
                return false;
            }

            // Verificar si hay progreso significativo (al menos una tarjeta completada o un intento)
            const hasProgress = (savedState.completedCards && savedState.completedCards.length > 0) ||
                (savedState.correctCount > 0) ||
                (savedState.incorrectCount > 0) ||
                (savedState.voiceAttempts > 0);

            return hasProgress;
        }

        // Función para mostrar el modal de continuación
        function showContinueGameModal() {
            const savedState = loadGameProgress();
            if (!savedState) return;

            const totalCards = flashcards.length;
            const completedCount = savedState.completedCards ? savedState.completedCards.length : 0;
            const remaining = totalCards - completedCount;
            const correctCount = savedState.correctCount || 0;
            const incorrectCount = savedState.incorrectCount || 0;

            const overlay = document.createElement('div');
            overlay.className = 'continue-game-overlay';
            overlay.id = 'continue-game-overlay';

            overlay.innerHTML = `
        <div class="continue-game-modal">
            <div class="continue-modal-header">
                <span class="continue-modal-icon">🎯</span>
                <h2 class="continue-modal-title">¡Progreso Detectado!</h2>
                <p class="continue-modal-subtitle">Tienes un juego en progreso</p>
            </div>
            
            <div class="continue-modal-content">
                <div class="continue-progress-info">
                    <div class="continue-progress-title">Tu progreso actual:</div>
                    <div class="continue-progress-stats">
                        <div class="continue-stat-item">
                            <div class="continue-stat-number correct">${correctCount}</div>
                            <div class="continue-stat-label">Correctas</div>
                        </div>
                        <div class="continue-stat-item">
                            <div class="continue-stat-number incorrect">${incorrectCount}</div>
                            <div class="continue-stat-label">Incorrectas</div>
                        </div>
                        <div class="continue-stat-item">
                            <div class="continue-stat-number remaining">${remaining}</div>
                            <div class="continue-stat-label">Restantes</div>
                        </div>
                    </div>
                </div>
                
                <div class="continue-modal-buttons">
                    <button class="continue-btn continue-btn-primary" id="continue-game-btn">
                        <i class="fas fa-play"></i>
                        Continuar
                    </button>
                    <button class="continue-btn continue-btn-secondary" id="start-fresh-btn">
                        <i class="fas fa-sync-alt"></i>
                        Empezar de Cero
                    </button>
                </div>
            </div>
        </div>
    `;

            document.body.appendChild(overlay);

            // Event listeners para los botones
            const continueBtn = overlay.querySelector('#continue-game-btn');
            const startFreshBtn = overlay.querySelector('#start-fresh-btn');

            continueBtn.addEventListener('click', function () {
                vibrar(60);
                playButtonSound();

                // Restaurar el estado del juego
                if (restoreGameState(savedState)) {
                    overlay.remove();
                    console.log('Juego continuado desde el progreso guardado');
                } else {
                    console.error('Error al restaurar el juego, empezando de cero');
                    clearCurrentProgress();
                    overlay.remove();
                    initializeNewGame();
                }
            });

            startFreshBtn.addEventListener('click', function () {
                vibrar(60);
                playButtonSound();

                // Limpiar progreso actual pero mantener avance anterior
                clearCurrentProgress();
                overlay.remove();
                initializeNewGame();
                console.log('Nuevo juego iniciado');
            });

            // Cerrar modal al hacer clic en el fondo (por defecto continúa)
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    vibrar(40);
                    // Por defecto continuar el juego
                    if (restoreGameState(savedState)) {
                        overlay.remove();
                    }
                }
            });
        }

        // Función para inicializar un nuevo juego
        function initializeNewGame() {
            // Resetear todas las variables
            currentCardIndex = 0;
            voiceAttempts = 0;
            completedCards.clear();
            correctWords.length = 0;
            incorrectWords.length = 0;
            correctWordDetails.length = 0;
            incorrectWordDetails.length = 0;
            correctCount = 0;
            incorrectCount = 0;
            canFlipBack = true;
            canFlip = true;
            shuffleClickCount = 0; // Restablecer usos de Mezclar al iniciar partida
            try { localStorage.removeItem('silabas3_shuffleCount'); } catch (e) { }

            // Mezclar tarjetas
            shuffleCards();

            // Actualizar interfaz
            updateCounters();
            updateCardCounter();

            // Mostrar primera tarjeta
            showCard(0);
        }

        // Mapeo de países a códigos de bandera
        const countryFlags = {
            'España': 'es',
            'Marruecos': 'ma',
            'México': 'mx',
            'Argentina': 'ar',
            'Francia': 'fr',
            'Italia': 'it',
            'Alemania': 'de',
            'Brasil': 'br',
            'Chile': 'cl',
            'Peru': 'pe',
            'Colombia': 'co',
            'Portugal': 'pt',
            'Grecia': 'gr',
            'Turquía': 'tr',
            'Japón': 'jp',
            'China': 'cn',
            'India': 'in',
            'Rusia': 'ru',
            'Canadá': 'ca',
            'Australia': 'au'
        };

        // Helper: normalizar nombre de país (minúsculas, sin tildes, trim)
        function normalizeCountryKey(str) {
            return (str || '')
                .toLowerCase()
                .normalize('NFD')
                .replace(/\p{Diacritic}+/gu, '') // quitar acentos
                .trim();
        }

        // Índice normalizado para lookup robusto (soporta con/sin acentos)
        const countryFlagsByKey = {};
        Object.keys(countryFlags).forEach(name => {
            countryFlagsByKey[normalizeCountryKey(name)] = countryFlags[name];
        });

        // Variable global para el overlay de bandera
        let currentFlagOverlay = null;

        // Base opcional para imágenes genéricas (png/jpg/webp). Puedes cambiar esta URL.
        const baseImagesUrl = 'https://fawzinoo.github.io/Fotos/';

        // Mostrar imagen genérica o bandera si existe
        function showItemImage(name) {
            const candidates = [];
            const key = normalizeAudioKey(name); // minúsculas, sin tildes, con guiones

            // 1) Preferir la imagen actual de la tarjeta (front) si existe
            try {
                const match = flashcards.find(card => {
                    const ans = card.dataset.answer || (card.querySelector('.back')?.textContent?.trim() || '');
                    return normalizeAudioKey(ans) === key;
                });
                const frontSrc = match?.querySelector('.front img')?.src;
                if (frontSrc) candidates.push(frontSrc);
            } catch (e) { }

            // 2) Intentar recursos locales/genéricos por nombre normalizado en varios formatos
            ['png', 'jpg', 'jpeg', 'webp'].forEach(ext => {
                candidates.push(`${baseImagesUrl}${key}.${ext}`);
            });

            // 3) Finalmente, bandera si hay código conocido
            const code = countryFlags[name] || countryFlagsByKey[normalizeCountryKey(name)];
            if (code) {
                candidates.push(`https://flagcdn.com/w640/${code}.png`);
            }

            // Función para probar en cadena hasta cargar una
            const tryNext = (idx) => {
                if (idx >= candidates.length) {
                    // Fallback: imagen inline de no disponible
                    openImageModal('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+');
                    return;
                }
                const url = candidates[idx];
                const testImg = new Image();
                testImg.onload = () => openImageModal(url, name);
                testImg.onerror = () => tryNext(idx + 1);
                testImg.src = url;
            };
            tryNext(0);
        }

        function openImageModal(src, name = '') {
            // Cerrar anterior si existe
            if (currentFlagOverlay) { currentFlagOverlay.remove(); currentFlagOverlay = null; }
            const overlay = document.createElement('div');
            overlay.id = 'flag-modal-overlay';
            overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
        display: flex; justify-content: center; align-items: center;
        z-index: 15000; opacity: 0; animation: fadeInOverlay 0.3s ease-out forwards;`;
            currentFlagOverlay = overlay;
            overlay.innerHTML = `
        <div class="flag-card-container">
            <div class="flag-controls-floating">
                <button class="flag-control-btn fullscreen-btn" title="Pantalla completa"> 
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
                </button>
                <button class="flag-control-btn restore-btn" title="Restituir" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                </button>
                <button class="flag-control-btn close-btn" title="Cerrar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div class="flag-card-body-full">
                <img id="flag-image" src="${src}" alt="${name ? 'Imagen de ' + name : 'Imagen'}" class="flag-display" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+'" />
            </div>
        </div>`;
            document.body.appendChild(overlay);
            const fullscreenBtn = overlay.querySelector('.fullscreen-btn');
            const restoreBtn = overlay.querySelector('.restore-btn');
            const closeBtn = overlay.querySelector('.close-btn');
            if (fullscreenBtn) fullscreenBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); toggleFullscreen(); });
            if (restoreBtn) restoreBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); exitFullscreen(); });
            if (closeBtn) closeBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); closeFlagModal(); });
            overlay.addEventListener('click', (e) => { if (e.target === overlay) { vibrar(50); playButtonSound(); closeFlagModal(); } });
        }

        // Función para mostrar la bandera del país
        function showCountryFlag(countryName) {
            // Cerrar overlay anterior si existe
            if (currentFlagOverlay) {
                currentFlagOverlay.remove();
                currentFlagOverlay = null;
            }

            // Buscar por clave exacta o clave normalizada (para soportar tildes)
            const flagCode = countryFlags[countryName] || countryFlagsByKey[normalizeCountryKey(countryName)];
            if (!flagCode) {
                console.log(`No se encontró código de bandera para: ${countryName}`);
                return;
            }

            const flagUrl = `https://flagcdn.com/w640/${flagCode}.png`;

            const overlay = document.createElement('div');
            overlay.id = 'flag-modal-overlay';
            overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 15000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;

            // Guardar referencia global
            currentFlagOverlay = overlay;

            overlay.innerHTML = `
        <div class="flag-card-container">
            <div class="flag-controls-floating">
                <button class="flag-control-btn fullscreen-btn" title="Pantalla completa">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                    </svg>
                </button>
                <button class="flag-control-btn restore-btn" title="Restituir" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <button class="flag-control-btn close-btn" title="Cerrar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="flag-card-body-full">
                <img id="flag-image" src="${flagUrl}" alt="Bandera de ${countryName}" class="flag-display" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+'" />
            </div>
        </div>
    `;

            document.body.appendChild(overlay);

            // Agregar event listeners después de crear el HTML
            const fullscreenBtn = overlay.querySelector('.fullscreen-btn');
            const restoreBtn = overlay.querySelector('.restore-btn');
            const closeBtn = overlay.querySelector('.close-btn');

            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', function () {
                    vibrar(50);
                    playButtonSound();
                    toggleFullscreen();
                });
            }

            if (restoreBtn) {
                restoreBtn.addEventListener('click', function () {
                    vibrar(50);
                    playButtonSound();
                    exitFullscreen();
                });
            }

            if (closeBtn) {
                closeBtn.addEventListener('click', function () {
                    vibrar(50);
                    playButtonSound();
                    closeFlagModal();
                });
            }

            // Cerrar modal al hacer clic en el fondo
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    vibrar(50);
                    playButtonSound();
                    closeFlagModal();
                }
            });
        }

        // Funciones para pantalla completa
        function toggleFullscreen() {
            if (!currentFlagOverlay) return;

            const flagContainer = currentFlagOverlay.querySelector('.flag-card-container');
            const fullscreenBtn = currentFlagOverlay.querySelector('.fullscreen-btn');
            const restoreBtn = currentFlagOverlay.querySelector('.restore-btn');

            if (!flagContainer || !fullscreenBtn || !restoreBtn) return;

            // Añadir clase para pantalla completa
            flagContainer.classList.add('fullscreen-mode');

            // Cambiar visibilidad de botones
            fullscreenBtn.style.display = 'none';
            restoreBtn.style.display = 'flex';

            // Aplicar estilos de pantalla completa al contenedor
            flagContainer.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        max-width: none !important;
        max-height: none !important;
        z-index: 20000 !important;
        border-radius: 0 !important;
        border: none !important;
        background: linear-gradient(to right, #1f3658, #3558e3) !important;
        display: flex !important;
        flex-direction: column !important;
        overflow: hidden !important;
        animation: expandToFullscreen 0.3s ease-out !important;
    `;

            // Ocultar el overlay de fondo
            currentFlagOverlay.style.background = 'transparent';
        }

        function exitFullscreen() {
            if (!currentFlagOverlay) return;

            const flagContainer = currentFlagOverlay.querySelector('.flag-card-container');
            const fullscreenBtn = currentFlagOverlay.querySelector('.fullscreen-btn');
            const restoreBtn = currentFlagOverlay.querySelector('.restore-btn');

            if (!flagContainer || !fullscreenBtn || !restoreBtn) return;

            // Remover clase de pantalla completa
            flagContainer.classList.remove('fullscreen-mode');

            // Cambiar visibilidad de botones
            fullscreenBtn.style.display = 'flex';
            restoreBtn.style.display = 'none';

            // Restaurar estilos originales del contenedor
            flagContainer.style.cssText = `
        width: 100%;
        height: 500px;
        max-height: 500px;
        max-width: 400px;
        background: linear-gradient(to right, #1f3658, #3558e3);
        border-radius: 25px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        border: 3px solid #aab0b4;
        overflow: hidden;
        position: relative;
        animation: slideInModal 0.4s ease-out;
        display: flex;
        flex-direction: column;
    `;

            // Restaurar el overlay de fondo
            currentFlagOverlay.style.background = 'rgba(0, 0, 0, 0.9)';
        }

        // Función para cerrar el modal de bandera
        function closeFlagModal() {
            if (currentFlagOverlay) {
                currentFlagOverlay.remove();
                currentFlagOverlay = null;
            }
        }




        const baseUrl = 'https://fawzinoo.github.io/audios/';
        const audioFiles = [
            'R-01.mp3',
            'R-02.mp3',
            'R-03.mp3',
            'R-04.mp3',
            'R-05.mp3',
            'R---06.mp3',
            'R-07.mp3',
            'R-08.mp3',
            'R---09.mp3',
            'R-10.mp3',
            'R-11.mp3',
            'R-12.mp3',
            'R-13.mp3',
            'R-14.mp3',
            'R-15.mp3',
            'R-16.mp3',
            'R-17.mp3',
            'R-18.mp3',
            'R-19.mp3',
            'R-20.mp3',
            'R-21.mp3',
            'R-22.mp3',
            'R-23.mp3',
            'R-24.mp3',
            'R-25.mp3',
            'R-26.mp3',
            'R-27.mp3',
            'R---28.mp3',
            'R-29.mp3',
            'R-30.mp3',
            'R---31.mp3',
            'R---32.mp3',
            'R-33.mp3',
            'R-34.mp3',
            'R-35.mp3',
            'R-36.mp3',
            'R-37.mp3',
            'R-38.mp3',
            'R-39.mp3',
            'R-40.mp3',
            'R-41.mp3',
            'R-42.mp3',
            'R-43.mp3',
            'R-44.mp3',
            'R---45.mp3',
            'R-46.mp3',
            'R-47.mp3',
            'R-48.mp3',
            'R-49.mp3',
            'R-50.mp3',
            'R-51.mp3',
            'R-52.mp3',
            'R---53.mp3',
            'R-54.mp3',
            'R-55.mp3',
            'R-56.mp3',
            'R-57.mp3',
            'R-58.mp3',
            'R-59.mp3',
            'R-60.mp3',
            'R-61.mp3',
            'R-62.mp3',
            'R-63.mp3',
            'R-64.mp3',
            'R-65.mp3',
            'R-66.mp3',
            'R-67.mp3',
            'R-68.mp3',
            'R-69.mp3',
            'R-70.mp3',
            'R-71.mp3',
            'R-72.mp3',
            'R-73.mp3',
            'R-74.mp3',
            'R-75.mp3',
            'R-76.mp3',
            'R-77.mp3',
            'R-78.mp3',
            'R-79.mp3',
            'R-80.mp3',
            'R-81.mp3',
            'R---82.mp3',
            'R-83.mp3',
            'R---84.mp3',
            'R---85.mp3',
            'R-86.mp3',
            'R-87.mp3',
            'R-88.mp3',
            'R-89.mp3',
            'R---90.mp3',
            'R-91.mp3',
            'R-92.mp3',
            'R-93.mp3',
            'R-94.mp3',
            'R-95.mp3',
            'R-96.mp3',
            'R-97.mp3',
            'R-98.mp3',
            'R-99.mp3',
            'R-100.mp3',
            'R-101.mp3',
            'R-102.mp3',
            'R-103.mp3'
        ];

        const audios = audioFiles.map(file => {
            const audio = new Audio();
            audio.preload = 'none';
            audio.src = baseUrl + file;
            return audio;
        });

        // Normalizador y mapa para resolver el audio correcto según el nombre del país
        function normalizeAudioKey(str) {
            if (!str) return '';
            // Toma solo la primera parte antes de coma, punto y coma, barra o paréntesis
            let clean = str.split(/[,;/()]/)[0];
            // Quita artículos iniciales
            clean = clean.replace(/^\s*(el|la|los|las|un|una|unos|unas)\s+/i, '');
            // Quita palabras decorativas comunes (opcional, puedes ampliar la lista)
            clean = clean.replace(/^(idioma|profesion|gentilicio|frase|palabra)\s+/i, '');
            // Normaliza: minúsculas, sin acentos, solo letras/números/espacios
            clean = clean
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')  // quitar acentos
                .replace(/\s+/g, ' ')             // espacios múltiples a uno solo
                .replace(/[^a-z0-9ñ ]/g, '')      // solo letras, números y espacios
                .trim();
            return clean;
        }


        // Mapeo explícito de palabras a archivos de audio (basado en el orden del objeto data)
        const audioFilenameByKey = {
            // b: banco, botas, burro, bebé, bicicleta
            'banco': 'R-01.mp3',
            'botas': 'R-02.mp3',
            'burro': 'R-03.mp3',
            'bebe': 'R-04.mp3',
            'bicicleta': 'R-05.mp3',
            // c: casa, cocina, cuchara, cerilla, cinturón
            'casa': 'R---06.mp3',
            'cocina': 'R-07.mp3',
            'cuchara': 'R-08.mp3',
            'cerilla': 'R---09.mp3',
            'cinturon': 'R-10.mp3',
            // ch: chaqueta, chocolate, churro, cheque, chicle
            'chaqueta': 'R-11.mp3',
            'chocolate': 'R-12.mp3',
            'churro': 'R-13.mp3',
            'cheque': 'R-14.mp3',
            'chicle': 'R-15.mp3',
            // d: dátiles, dos, dulces, dedo, dinero
            'datiles': 'R-16.mp3',
            'dos': 'R-17.mp3',
            'dulces': 'R-18.mp3',
            'dedo': 'R-19.mp3',
            'dinero': 'R-20.mp3',
            // f: farola, foto, fútbol, fecha, fichas
            'farola': 'R-21.mp3',
            'foto': 'R-22.mp3',
            'futbol': 'R-23.mp3',
            'fecha': 'R-24.mp3',
            'fichas': 'R-25.mp3',
            // g: gato, gota, gusano, gel, gimnasio, guerra, guitarra, queso, quince
            'gato': 'R-26.mp3',
            'gota': 'R-27.mp3',
            'gusano': 'R---28.mp3',
            'gel': 'R-29.mp3',
            'gimnasio': 'R-30.mp3',
            'guerra': 'R---31.mp3',
            'guitarra': 'R---32.mp3',
            'queso': 'R-33.mp3',
            'quince': 'R-34.mp3',
            // h: hacha, hoja, humo, helado, higo
            'hacha': 'R-35.mp3',
            'hoja': 'R-36.mp3',
            'humo': 'R-37.mp3',
            'helado': 'R-38.mp3',
            'higo': 'R-39.mp3',
            // j: jarra, joyas, juguete, jefe, jirafa
            'jarra': 'R-40.mp3',
            'joyas': 'R-41.mp3',
            'juguete': 'R-42.mp3',
            'jefe': 'R-43.mp3',
            'jirafa': 'R-44.mp3',
            // k: kayak, koala, kufiya, ketchup, kiwi
            'kayak': 'R---45.mp3',
            'koala': 'R-46.mp3',
            'kufiya': 'R-47.mp3',
            'ketchup': 'R-48.mp3',
            'kiwi': 'R-49.mp3',
            // l: lápiz, loro, luz, lechuga, libro
            'lapiz': 'R-50.mp3',
            'loro': 'R-51.mp3',
            'luz': 'R-52.mp3',
            'lechuga': 'R---53.mp3',
            'libro': 'R-54.mp3',
            // m: manzana, monedas, muñeca, mesa, misil
            'manzana': 'R-55.mp3',
            'monedas': 'R-56.mp3',
            'muneca': 'R-57.mp3',
            'mesa': 'R-58.mp3',
            'misil': 'R-59.mp3',
            // n: naranja, nota, nudo, nevera, nido
            'naranja': 'R-60.mp3',
            'nota': 'R-61.mp3',
            'nudo': 'R-62.mp3',
            'nevera': 'R-63.mp3',
            'nido': 'R-64.mp3',
            // ñ: españa, moño, ceñuda, bañera, bañistas
            'espana': 'R-65.mp3',
            'mono': 'R-66.mp3',
            'cenuda': 'R-67.mp3',
            'banera': 'R-68.mp3',
            'banistas': 'R-69.mp3',
            // p: pan, pozo, pulsera, pez, piña
            'pan': 'R-70.mp3',
            'pozo': 'R-71.mp3',
            'pulsera': 'R-72.mp3',
            'pez': 'R-73.mp3',
            'pina': 'R-74.mp3',
            // r: radio, ropa, ruleta, reloj, rinoceronte, pera, perro
            'radio': 'R-75.mp3',
            'ropa': 'R-76.mp3',
            'ruleta': 'R-77.mp3',
            'reloj': 'R-78.mp3',
            'rinoceronte': 'R-79.mp3',
            'pera': 'R-80.mp3',
            'perro': 'R-81.mp3',
            // s: salero, sofá, sudadera, sello, silla
            'salero': 'R---82.mp3',
            'sofa': 'R-83.mp3',
            'sudadera': 'R---84.mp3',
            'sello': 'R---85.mp3',
            'silla': 'R-86.mp3',
            // t: taza, torre, túnel, teléfono, tigre
            'taza': 'R-87.mp3',
            'torre': 'R-88.mp3',
            'tunel': 'R-89.mp3',
            'telefono': 'R---90.mp3',
            'tigre': 'R-91.mp3',
            // v: vaso, volante, vestido, vinilo
            'vaso': 'R-92.mp3',
            'volante': 'R-93.mp3',
            'vestido': 'R-94.mp3',
            'vinilo': 'R-95.mp3',
            // y: yate, yogur, yunque, yema
            'yate': 'R-96.mp3',
            'yogur': 'R-97.mp3',
            'yunque': 'R-98.mp3',
            'yema': 'R-99.mp3',
            // z: zapatos, zorro, zumo, zinc
            'zapatos': 'R-100.mp3',
            'zorro': 'R-101.mp3',
            'zumo': 'R-102.mp3',
            'zinc': 'R-103.mp3'
        };
        function getAudioSrcForCountryName(textoBack) {
            const key = normalizeAudioKey(textoBack);
            if (!key) return null;
            const directFile = audioFilenameByKey[key];
            if (directFile) return baseUrl + directFile;
            const numericAliasKey = resolveSpanishNumberKey(key);
            if (numericAliasKey) {
                const numericFile = audioFilenameByKey[numericAliasKey];
                if (numericFile) return baseUrl + numericFile;
            }
            return null;
        }

        // Mapas auxiliares para resolver palabras de números en español
        const SPANISH_UNITS = {
            cero: 0, uno: 1, una: 1, dos: 2, tres: 3, cuatro: 4, cinco: 5,
            seis: 6, siete: 7, ocho: 8, nueve: 9
        };
        const SPANISH_TEENS = {
            diez: 10, once: 11, doce: 12, trece: 13, catorce: 14, quince: 15,
            dieciseis: 16, dieciséis: 16, diecisiete: 17, dieciocho: 18, diecinueve: 19
        };
        const SPANISH_TENS = {
            veinte: 20, treinta: 30, cuarenta: 40, cincuenta: 50,
            sesenta: 60, setenta: 70, ochenta: 80, noventa: 90, cien: 100, ciento: 100
        };

        function resolveSpanishNumberKey(normalizedKey) {
            if (!normalizedKey) return null;
            // Primero coincidencias directas
            if (SPANISH_UNITS[normalizedKey] !== undefined) return String(SPANISH_UNITS[normalizedKey]);
            if (SPANISH_TEENS[normalizedKey] !== undefined) return String(SPANISH_TEENS[normalizedKey]);
            if (SPANISH_TENS[normalizedKey] !== undefined) return String(SPANISH_TENS[normalizedKey]);

            if (normalizedKey.startsWith('veinti')) {
                const unitPart = normalizedKey.slice('veinti'.length);
                if (SPANISH_UNITS[unitPart] !== undefined) {
                    return String(20 + SPANISH_UNITS[unitPart]);
                }
            }

            if (normalizedKey.includes(' y ')) {
                const [tensPart, unitPart] = normalizedKey.split(' y ').map(part => part.trim());
                const tensValue = SPANISH_TENS[tensPart];
                const unitValue = SPANISH_UNITS[unitPart];
                if (tensValue !== undefined && unitValue !== undefined) {
                    return String(tensValue + unitValue);
                }
            }

            return null;
        }

        function deriveFrontLabelFromText(backText) {
            if (!backText) return '—';
            const normalized = normalizeAudioKey(backText);
            const fromMap = resolveSpanishNumberKey(normalized);
            if (fromMap) return fromMap;
            const digitMatch = backText.match(/\\d+/);
            if (digitMatch) return digitMatch[0];
            return backText.split(' ')[0] || backText;
        }

        // Alias para discrepancias de nombres entre el texto mostrado y el archivo de audio
        // Evita que tarjetas como "Brasil" (archivo brazil.mp3) queden sin src y bloqueen el flujo
        if (audioFilenameByKey['brazil'] && !audioFilenameByKey['brasil']) {
            audioFilenameByKey['brasil'] = audioFilenameByKey['brazil'];
        }

        // Reproducción segura por tarjeta: el audio se resuelve por contenido actual
        function playCardAudio(card, onEnded) {
            try {
                if (!card) { if (onEnded) onEnded(); return; }
                const answer = (card.dataset?.answer || card.querySelector('.back')?.textContent || '').trim();
                const src = getAudioSrcForCountryName(answer);
                if (!src) { if (onEnded) onEnded(); return; }
                if (!card._audioEl) {
                    card._audioEl = new Audio();
                    card._audioEl.preload = 'auto';
                }
                const a = card._audioEl;
                try { a.pause(); } catch { }
                a.src = src;
                a.currentTime = 0;
                a.onended = null;
                if (typeof onEnded === 'function') a.onended = onEnded;
                a.play().catch(() => { if (onEnded) onEnded(); });
            } catch (e) { if (onEnded) onEnded(); }
        }

        // Detener audios por tarjeta
        function stopAllAudios() {
            document.querySelectorAll('.flashcard').forEach(c => {
                if (c._audioEl) {
                    try { c._audioEl.pause(); c._audioEl.currentTime = 0; } catch { }
                }
            });
        }

        // Copia del HTML original del contenedor de tarjetas para poder restaurar tras pantallas finales
        let originalFlashcardsHTML = null;
        const flashcards = Array.from(document.querySelectorAll('.flashcard'));

        function getFrontImage(card) {
            return card.querySelector('.front img');
        }

        function getFrontTextFromCard(card) {
            return card.dataset.frontText || '';
        }

        function setFrontText(card, text) {
            try { card.dataset.frontText = text; } catch { }
        }

        function getBackTextFromCard(card) {
            return card.dataset.answer || card.querySelector('.back')?.textContent?.trim() || '';
        }

        function shuffleCards() {
            stopAllAudios();
            document.querySelectorAll('.countdown-overlay, .mensaje-error, .listening-indicator').forEach(el => el.remove());


            // 1. Obtener los datos de todas las tarjetas.
            const allCardData = flashcards.map((card) => {
                const frontImgEl = getFrontImage(card);
                return {
                    frontImg: frontImgEl ? frontImgEl.src : '',
                    frontAlt: frontImgEl ? frontImgEl.alt : '',
                    frontText: getFrontTextFromCard(card),
                    // CORRECTO: usar el texto del reverso real
                    backText: getBackTextFromCard(card)
                };
            });

            // 2. Separar los datos de las tarjetas en pendientes y completadas.
            const remainingCardData = [];
            const completedCardData = [];
            allCardData.forEach((data, index) => {
                if (completedCards.has(index)) {
                    completedCardData.push(data);
                } else {
                    remainingCardData.push(data);
                }
            });

            // 3. Barajar solo las tarjetas pendientes.
            for (let i = remainingCardData.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingCardData[i], remainingCardData[j]] = [remainingCardData[j], remainingCardData[i]];
            }

            // 4. Crear el nuevo mazo: pendientes barajadas primero, luego las completadas.
            const newCardOrder = [...remainingCardData, ...completedCardData];

            // 5. Actualizar el DOM según el nuevo orden (sin usar array global de audios por índice)
            flashcards.forEach((card, index) => {
                const data = newCardOrder[index];
                card.classList.remove('is-visible', 'flipped');
                setFrontText(card, data.frontText || '');
                const frontImgEl = getFrontImage(card);
                if (frontImgEl) {
                    if (data.frontImg) frontImgEl.src = data.frontImg;
                    frontImgEl.alt = data.frontAlt || '';
                }
                // Restaurar el texto original del reverso por si había cambiado a "Incorrecto"
                const back = card.querySelector('.back');
                back.querySelectorAll('.intentos-back').forEach(el => el.remove());
                back.innerHTML = data.backText;
                card.dataset.answer = data.backText;
                // --- AQUÍ VA EL AUDIO ---
                // Precalcular y guardar src como atributo si quieres usarlo luego
                const src = getAudioSrcForCountryName(data.backText);
                if (src) card.dataset.audioSrc = src; else delete card.dataset.audioSrc;
            });

            // 6. Actualizar el estado para reflejar el nuevo orden.
            setTimeout(() => {
                // Las tarjetas completadas ahora están al final del mazo.
                // Sus nuevos índices van desde `remainingCardData.length` hasta el final.
                const newCompletedCards = new Set();
                for (let i = 0; i < completedCardData.length; i++) {
                    newCompletedCards.add(remainingCardData.length + i);
                }

                completedCards = newCompletedCards; // Reemplazar el set antiguo por el nuevo.
                // Empezar desde la primera PENDIENTE real
                currentCardIndex = 0;
                for (let i = 0; i < flashcards.length; i++) {
                    if (!completedCards.has(i)) { currentCardIndex = i; break; }
                }

                showCard(currentCardIndex);
                updateCounters(); // Actualizar los contadores en la UI sin reiniciarlos.
            }, 10);
            voiceAttempts = 0;
            canFlipBack = true;
        }

        function getCountryText(backElement) {
            // Clonamos el nodo para no modificar el original
            const clone = backElement.cloneNode(true);
            // Buscamos y eliminamos el contador de intentos si existe
            const attemptsDiv = clone.querySelector('.intentos-back');
            if (attemptsDiv) {
                attemptsDiv.remove();
            }
            // Devolvemos el texto limpio
            return clone.textContent.trim();
        }

        function attachFlashcardHandlers() {
            flashcards.forEach((card) => {
                // Guardar la respuesta correcta original en un atributo data-answer SOLO una vez
                const currentFront = card.querySelector('.front')?.textContent?.trim() || '';
                setFrontText(card, currentFront);
                if (!card.dataset.answer) {
                    const back = card.querySelector('.back');
                    card.dataset.answer = back.textContent.trim();
                }

                card.addEventListener('click', (event) => {
                    // No voltear si el clic ocurre dentro del cuadro de escritura
                    try {
                        if (event && event.target && event.target.closest('.type-dialog-container')) {
                            return;
                        }
                    } catch (e) { }
                    console.log(`Click en tarjeta. canFlip: ${canFlip}, voiceAttempts: ${voiceAttempts}, flipped: ${card.classList.contains('flipped')}`);
                    if (!canFlip) {
                        console.log('Volteo bloqueado por canFlip');
                        card.style.transform = 'scale(0.98)';
                        setTimeout(() => { card.style.transform = ''; }, 150);
                        return;
                    }

                    vibrar(80);
                    const backElement = card.querySelector('.back');
                    if (card.classList.contains('flipped')) {
                        // Ocultar teclado virtual y limpiar estado al volver al frente
                        try {
                            const vkOverlay = document.getElementById('vk-overlay');
                            const vk = document.getElementById('vk');
                            if (vk && vkOverlay) {
                                vk.classList.remove('show');
                                vkOverlay.style.display = 'none';
                            }
                            document.body.classList.remove('keyboard-visible');
                            document.documentElement.classList.remove('keyboard-visible');
                            document.body.classList.add('keyboard-hidden');
                            document.documentElement.classList.add('keyboard-hidden');

                        } catch (e) { }

                        card.classList.remove('flipped');
                        stopAllAudios();
                        backElement.querySelectorAll('.intentos-back').forEach(el => el.remove());
                        // removeListeningIndicator(backElement); // Eliminado para corregir error de referencia
                        setBackAttempts(backElement, 2 - voiceAttempts);
                        betweenAttempts = false;
                        updateSkipButtonState();
                    } else {
                        card.classList.add('flipped');



                        // Preparar back...
                        if (card.dataset.answer) {
                            backElement.innerHTML = card.dataset.answer;
                        }
                        backElement.querySelectorAll('.listening-indicator, .mensaje-error').forEach(el => el.remove());
                        backElement.classList.remove('hidden-text');
                        setBackAttempts(backElement, 2 - voiceAttempts);

                        // Sustituir sistema de voz por entrada escrita (mantener solo "No sé" por voz)
                        // Plantilla UI del diálogo
                        backElement.innerHTML = `
                    <div class="type-word-title" id="type-word-title" style="display:none;"></div>
                    <div class="type-dialog-container">
                        <div class="type-message" id="type-message" style="display:none;"></div>
                        <div class="type-input-row">
                            <div class="type-input-container">
                                <input id="type-input" class="type-input" type="text" autocomplete="off" placeholder="Escribe aquí..." inputmode="none" />
                                <button id="clear-button" class="clear-button-inside" title="Limpiar texto"><i class="fas fa-backspace"></i></button>
                            </div>
                        </div>
                        <!-- Botones sin contenedor, directamente debajo del input (solo PC por CSS) -->
                        <button class="char-btn" data-char="á">á</button>
                        <button class="char-btn" data-char="é">é</button>
                        <button class="char-btn" data-char="í">í</button>
                        <button class="char-btn" data-char="ó">ó</button>
                        <button class="char-btn" data-char="ú">ú</button>
                        <button class="char-btn" data-char="ñ">ñ</button>
                        <div class="check-button-row">
                            <button id="check-button" class="check-button">comprobar</button>
                            <button id="no-duplicate-button" class="no-duplicate-button"><i class="fas fa-forward"></i> No sé</button>
                        </div>
                    </div>
                `;
                        // Mostrar contador de intentos/extra si aplica (reutilizamos API existente, sin mostrar contador real)
                        setBackAttempts(backElement, 2 - voiceAttempts);

                        // En este modo no ocultamos el texto del back (se reemplaza por el diálogo)
                        backElement.classList.remove('hidden-text');

                        // Preparar comprobación escrita
                        const answerRaw = (card.dataset.answer || '').trim();
                        // Normaliza ignorando solo mayúsculas y comas
                        const normalize = (s) => (s || '')
                            .toLowerCase()
                            .replace(/,/g, '')
                            .trim();
                        const answerNorm = normalize(answerRaw);
                        const splitWords = (text) => (text || '').split(/\s+/).filter(Boolean);
                        const matchesAnswerWords = (userText, targetText) => {
                            if (!targetText) return false;
                            const userWords = splitWords(userText);
                            const targetWords = splitWords(targetText);
                            if (targetWords.length === 0) return false;
                            return targetWords.every(word => userWords.includes(word));
                        };

                        const inputEl = backElement.querySelector('#type-input');
                        const checkBtn = backElement.querySelector('#check-button');
                        const clearBtn = backElement.querySelector('#clear-button');

                        // Función para evitar teclado del sistema en móviles
                        const preventSystemKeyboard = () => {
                            if (window.innerWidth <= 768) { // Solo en móviles
                                // No usar readonly para no bloquear el caret; bloquear solo el teclado nativo
                                inputEl.removeAttribute('readonly');
                                inputEl.setAttribute('inputmode', 'none');
                            } else {
                                // En PC, permitir input normal
                                inputEl.removeAttribute('readonly');
                                inputEl.setAttribute('inputmode', 'text');
                            }
                        };

                        // Aplicar prevención de teclado al inicio
                        preventSystemKeyboard();

                        const msgEl = backElement.querySelector('#type-message');
                        const dialogContainer = backElement.querySelector('.type-dialog-container');
                        const inputContainer = backElement.querySelector('.type-input-container');
                        const titleEl = backElement.querySelector('#type-word-title');
                        // Helper para obtener los elementos del teclado virtual en el momento de uso
                        const getVK = () => ({
                            vk: document.getElementById('vk'),
                            vkOverlay: document.getElementById('vk-overlay')
                        });
                        const isVKShown = () => {
                            const { vk } = getVK();
                            return !!(vk && vk.classList.contains('show'));
                        };
                        // Restaurar el texto previamente escrito para esta tarjeta (si existe)
                        try {
                            const savedValue = card.dataset.userInput || '';
                            if (savedValue) {
                                inputEl.value = savedValue;
                                // Colocar el cursor al final del texto restaurado
                                const end = inputEl.value.length;
                                try { inputEl.setSelectionRange(end, end); } catch { }
                            }
                        } catch { }
                        // Helper para sincronizar lo escrito con el dataset de la tarjeta
                        const syncUserInput = () => {
                            try { card.dataset.userInput = inputEl.value; } catch { }
                        };
                        // Flag para evitar ocultar el teclado al interactuar con sus teclas
                        let vkInteracting = false;
                        let vkInteractTimer = null;

                        // Detectar navegador Samsung para ajustes específicos
                        const isSamsungBrowser = navigator.userAgent.includes('SamsungBrowser');

                        // Función mejorada para detectar dispositivos de escritorio/PC
                        const isDesktopDevice = () => {
                            // Detectar por ancho de pantalla (más conservador - solo pantallas muy grandes)
                            if (window.innerWidth >= 1200) return true;

                            // Detectar por user agent (complementario) - solo si es claramente un PC
                            const userAgent = navigator.userAgent.toLowerCase();
                            const isDesktop = /windows|macintosh|linux/.test(userAgent) &&
                                !/android|iphone|ipad|ipod|mobile|tablet/.test(userAgent) &&
                                window.innerWidth >= 1024;

                            return isDesktop;
                        };



                        // Función para mostrar el teclado virtual de forma segura
                        const showVirtualKeyboard = () => {
                            console.log('showVirtualKeyboard: invoked');
                            // No mostrar el teclado virtual en dispositivos de escritorio/PC
                            if (isDesktopDevice()) {
                                console.log('showVirtualKeyboard: dispositivo de escritorio detectado, usando teclado físico');
                                // En PC, simplemente enfocar el input para usar el teclado físico
                                try { inputEl.focus(); } catch (e) { }
                                return;
                            }
                            const { vk, vkOverlay } = getVK();
                            if (!(vkOverlay && vk)) { console.log('showVirtualKeyboard: vk/vkOverlay not found'); return; }
                            vkOverlay.style.display = 'flex';
                            // Usar rAF para asegurar layout antes de la transición
                            requestAnimationFrame(() => vk.classList.add('show'));
                            // Bloquear teclado nativo manteniendo foco solo con inputmode y focus (sin readOnly)
                            inputEl.setAttribute('inputmode', 'none');
                            requestAnimationFrame(() => {
                                try { inputEl.focus({ preventScroll: true }); } catch (e) { }
                            });
                        };
                        const ensureVirtualKeyboardOpen = () => {
                            // No intentar abrir el teclado virtual en dispositivos de escritorio
                            if (isDesktopDevice()) {
                                console.log('ensureVirtualKeyboardOpen: dispositivo de escritorio, omitiendo teclado virtual');
                                return;
                            }
                            // Intenta abrir varias veces por si el DOM no está listo o hay animaciones en curso
                            [0, 60, 180].forEach(delay => {
                                setTimeout(() => { if (!isVKShown()) { showVirtualKeyboard(); } }, delay);
                            });
                        };

                        // Mostrar/ocultar con focus/blur
                        const originalPlaceholder = (inputEl.getAttribute('placeholder') || '');
                        const hidePlaceholder = () => { try { inputEl.setAttribute('placeholder', ''); } catch { } };
                        const restorePlaceholder = () => { try { inputEl.setAttribute('placeholder', originalPlaceholder); } catch { } };

                        const focusHandler = () => {
                            console.log('FOCUS - Detectando tipo de dispositivo');
                            if (isDesktopDevice()) {
                                console.log('FOCUS - Dispositivo de escritorio: usando teclado físico');
                                // En PC, comportamiento normal sin teclado virtual
                                hidePlaceholder();
                                document.body.classList.add('keyboard-visible');
                                document.documentElement.classList.add('keyboard-visible');
                                document.body.classList.remove('keyboard-hidden');
                                document.documentElement.classList.remove('keyboard-hidden');
                            } else if (window.innerWidth <= 768) {
                                console.log('FOCUS - Dispositivo móvil');
                                hidePlaceholder();
                                document.body.classList.add('keyboard-visible');
                                document.documentElement.classList.add('keyboard-visible');
                                document.body.classList.remove('keyboard-hidden');
                                document.documentElement.classList.remove('keyboard-hidden');
                            } else {
                                console.log('FOCUS - Tablet: comportamiento estándar');
                                hidePlaceholder();
                                document.body.classList.add('keyboard-visible');
                                document.documentElement.classList.add('keyboard-visible');
                                document.body.classList.remove('keyboard-hidden');
                                document.documentElement.classList.remove('keyboard-hidden');
                            }

                            // Mostrar botón "No sé" duplicado solo en móviles cuando el input tiene focus
                            if (window.innerWidth <= 768) {
                                noDuplicateBtn.classList.add('show-on-focus');
                            }
                        };

                        // En blur: ocultar el botón si se oculta el teclado
                        const blurHandler = (e) => {
                            console.log('BLUR - Ocultar botón móvil "No sé" y teclado virtual');
                            restorePlaceholder();
                            // Volver a estado oculto del caret cuando se pierde el foco
                            document.body.classList.remove('keyboard-visible');
                            document.documentElement.classList.remove('keyboard-visible');
                            document.body.classList.add('keyboard-hidden');
                            document.documentElement.classList.add('keyboard-hidden');

                            // MODIFICADO: No ocultar automáticamente el botón "No sé" en blur
                            // Solo ocultarlo si realmente debe estar oculto según el estado del juego
                            // setTimeout(() => {
                            //     noDuplicateBtn.classList.remove('show-on-focus');
                            // }, 150);
                            if (window.innerWidth <= 768) {
                                const { vk, vkOverlay } = getVK();
                                // Si el foco se mueve a algún elemento dentro del teclado, no cerrar
                                try {
                                    const rt = e && (e.relatedTarget || document.activeElement);
                                    if (vk && rt && vk.contains(rt)) {
                                        return;
                                    }
                                    // Si el foco se mueve a controles del diálogo (incluido el botón móvil), no cerrar
                                    if (rt && (dialogContainer && dialogContainer.contains(rt))) {
                                        return;
                                    }

                                    if (rt && (checkBtn && (rt === checkBtn))) {
                                        return;
                                    }
                                    if (rt && (clearBtn && (rt === clearBtn))) {
                                        return;
                                    }
                                    if (rt && (noDuplicateBtn && (rt === noDuplicateBtn))) {
                                        console.log('🔥 Click en botón No sé, no ocultar');
                                        return;
                                    }
                                } catch { }
                                // Si el blur viene de interactuar con el teclado virtual, NO ocultar
                                if (vkInteracting) {
                                    if (vk && vkOverlay && !vk.classList.contains('show')) {
                                        vkOverlay.style.display = 'flex';
                                        requestAnimationFrame(() => vk.classList.add('show'));
                                    }
                                    // Restaurar foco al input inmediatamente
                                    setTimeout(() => inputEl.focus({ preventScroll: true }), 0);
                                    return;
                                }

                                if (vk && vkOverlay) {
                                    vk.classList.remove('show');
                                    setTimeout(() => { vkOverlay.style.display = 'none'; }, 220);
                                }
                            }
                        };

                        // Método alternativo: detectar cambios de altura del viewport
                        let lastViewportHeight = window.innerHeight;
                        const handleResize = () => {
                            if (window.innerWidth > 768) return;

                            const currentHeight = window.innerHeight;
                            const heightDiff = lastViewportHeight - currentHeight;

                            console.log(`Altura anterior: ${lastViewportHeight}, actual: ${currentHeight}, diferencia: ${heightDiff}`);

                            // En Samsung Internet nunca ocultamos por cambios de viewport para evitar parpadeos
                            if (isSamsungBrowser) {
                                showMobileSkipButton();
                                lastViewportHeight = currentHeight;
                                return;
                            }

                            if (heightDiff > 100) {
                                // Altura se redujo significativamente = teclado apareció
                                showMobileSkipButton();
                            } else if (heightDiff < -30) {
                                // Altura aumentó = teclado desapareció (más sensible)
                                console.log('Detectado aumento de altura - ocultando botón');
                                hideMobileSkipButton(true);
                                // Múltiples intentos para asegurar que se oculte
                                setTimeout(() => hideMobileSkipButton(true), 100);
                                setTimeout(() => hideMobileSkipButton(true), 300);
                            }

                            lastViewportHeight = currentHeight;
                        };

                        // No necesitamos event listeners adicionales - solo focus/blur

                        // Solo los event listeners esenciales
                        inputEl.addEventListener('focus', focusHandler);
                        inputEl.addEventListener('blur', blurHandler);
                        window.addEventListener('resize', handleResize);

                        // Si el input ya tiene foco y el usuario toca para escribir, reabrir el teclado
                        const ensureVKVisibleOnTap = () => {
                            // Solo asegurar foco; NO mover el caret (respeta click/selección del usuario)
                            try {
                                inputEl.focus({ preventScroll: true });
                                hidePlaceholder();
                            } catch { }
                            // Mostrar cursor parpadeante (clases keyboard-visible)
                            try { if (typeof setCursorState === 'function') setCursorState(true, 'Tap en input'); } catch { }
                            // Refuerzo de clases para caret visible
                            document.body.classList.add('keyboard-visible');
                            document.documentElement.classList.add('keyboard-visible');
                            document.body.classList.remove('keyboard-hidden');
                            document.documentElement.classList.remove('keyboard-hidden');

                            // Solo activar teclado virtual y botones móviles en dispositivos NO-PC
                            if (isDesktopDevice()) {
                                console.log('ensureVKVisibleOnTap: dispositivo de escritorio, usando teclado físico');
                                return; // En PC, solo enfocar el input es suficiente
                            }


                            if (!isVKShown()) { ensureVirtualKeyboardOpen(); }
                        };
                        inputEl.addEventListener('pointerdown', ensureVKVisibleOnTap, { passive: true });
                        inputEl.addEventListener('click', ensureVKVisibleOnTap, { passive: true });
                        // Permitir click en el área del contenedor para enfocar el input y mostrar el cursor
                        const focusFromContainer = (e) => {
                            if (e && e.target === inputEl) return; // ya lo maneja el input
                            try {
                                e && e.preventDefault && e.preventDefault();
                                inputEl.focus({ preventScroll: true });
                                // NO mover el caret al final; respetar click posterior del usuario
                                if (typeof setCursorState === 'function') setCursorState(true, 'Tap en contenedor de input');
                                hidePlaceholder();
                                // Refuerzo de clases para caret visible
                                document.body.classList.add('keyboard-visible');
                                document.documentElement.classList.add('keyboard-visible');
                                document.body.classList.remove('keyboard-hidden');
                                document.documentElement.classList.remove('keyboard-hidden');
                            } catch { }
                        };
                        if (inputContainer) {
                            inputContainer.addEventListener('pointerdown', focusFromContainer);
                            inputContainer.addEventListener('click', focusFromContainer);
                        }



                        // No forzar apertura del teclado tras montar el UI en móvil: el usuario debe hacer clic en el input

                        // ====== LÓGICA DEL TECLADO VIRTUAL ======
                        // Soporte de idiomas (ES/FR) y layouts (QWERTY/AZERTY)
                        const LAYOUTS = {
                            es: {
                                qwerty: [
                                    ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                                    ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'ñ'],
                                    ['shift', 'z', 'x', 'c', 'v', 'b', 'n', 'm']
                                ],
                                azerty: [
                                    ['a', 'z', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                                    ['q', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'ñ'],
                                    ['shift', 'w', 'x', 'c', 'v', 'b', 'n', 'm']
                                ]
                            },
                            fr: {
                                qwerty: [
                                    ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                                    ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'ç'],
                                    ['shift', 'z', 'x', 'c', 'v', 'b', 'n', 'm']
                                ],
                                azerty: [
                                    ['a', 'z', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                                    ['q', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'ç'],
                                    ['shift', 'w', 'x', 'c', 'v', 'b', 'n', 'm']
                                ]
                            }
                        };
                        const ACCENTS = {
                            es: ['á', 'é', 'í', 'ó', 'ú'],
                            fr: ['é', 'è', 'ê', 'à', 'ç']
                        };
                        // Cargar preferencias guardadas (fallback: AZERTY + ES)
                        let VK_LANG = (localStorage.getItem('vk_lang') || 'es');
                        let VK_LAYOUT = (localStorage.getItem('vk_layout') || 'azerty');
                        let VK_SHIFT = false;

                        function renderVirtualKeyboard() {
                            const vk = document.getElementById('vk');
                            if (!vk) return;
                            const rows = vk.querySelectorAll('.vk-row');
                            if (rows.length < 3) return;
                            rows.forEach((row, idx) => {
                                row.innerHTML = '';
                                const keys = LAYOUTS[VK_LANG][VK_LAYOUT][idx];
                                keys.forEach(k => {
                                    const div = document.createElement('div');
                                    div.className = 'vk-key';
                                    let label = k;
                                    if (k === 'shift') { label = '⇧'; div.classList.add('primary'); }
                                    else { label = VK_SHIFT ? k.toUpperCase() : k; }
                                    div.textContent = label;
                                    div.dataset.key = k;
                                    row.appendChild(div);
                                });
                            });
                        }

                        function insertAtCursor(text) {
                            // Asegurar foco antes de leer selección
                            if (document.activeElement !== inputEl) {
                                inputEl.focus({ preventScroll: true });
                            }
                            const start = typeof inputEl.selectionStart === 'number' ? inputEl.selectionStart : inputEl.value.length;
                            const end = typeof inputEl.selectionEnd === 'number' ? inputEl.selectionEnd : inputEl.value.length;
                            const current = inputEl.value;
                            const newVal = current.slice(0, start) + text + current.slice(end);
                            inputEl.value = newVal;
                            const caret = start + text.length;
                            try { inputEl.setSelectionRange(caret, caret); } catch { }
                            inputEl.focus({ preventScroll: true });
                            // Guardar valor tras inserción programática
                            syncUserInput();
                        }

                        function handleVirtualKey(key) {
                            if (key === 'shift') {
                                VK_SHIFT = !VK_SHIFT;
                                renderVirtualKeyboard();
                                return;
                            }
                            if (key === 'hide') {
                                // Ocultar teclado virtual sin perder el foco del input
                                const vk = document.getElementById('vk');
                                const vkOverlay = document.getElementById('vk-overlay');
                                if (vk && vkOverlay) {
                                    vk.classList.remove('show');
                                    // pequeño retardo para transición y evitar rebotes al tocar el input
                                    setTimeout(() => { vkOverlay.style.display = 'none'; }, 220);
                                }

                                return;
                            }
                            if (key === 'backspace') {
                                const start = inputEl.selectionStart ?? inputEl.value.length;
                                const end = inputEl.selectionEnd ?? inputEl.value.length;
                                if (start === end && start > 0) {
                                    // borrar carácter previo
                                    inputEl.value = inputEl.value.slice(0, start - 1) + inputEl.value.slice(end);
                                    const pos = start - 1;
                                    inputEl.setSelectionRange(pos, pos);
                                } else {
                                    // borrar selección
                                    inputEl.value = inputEl.value.slice(0, start) + inputEl.value.slice(end);
                                    inputEl.setSelectionRange(start, start);
                                }
                                inputEl.focus({ preventScroll: true });
                                // Guardar valor tras borrar programáticamente
                                syncUserInput();
                                return;
                            }
                            // sin tecla enter: el enter físico del teclado real sigue funcionando (keydown)
                            // letra, espacio o acentos (respetar mayúsculas con Shift)
                            let text = key;
                            if (key.length === 1) {
                                text = VK_SHIFT ? key.toUpperCase() : key;
                            }
                            insertAtCursor(text);
                            // sonido de tecla
                            try { playKeyboardSound(); } catch { }
                        }

                        function renderAccents() {
                            const vk = document.getElementById('vk');
                            const row = vk ? vk.querySelector('.vk-accents .row-accents') : null;
                            if (!row) return;
                            row.innerHTML = '';
                            const keys = ACCENTS[VK_LANG] || [];
                            keys.forEach(k => {
                                const div = document.createElement('div');
                                div.className = 'vk-key';
                                div.textContent = k;
                                div.dataset.key = k;
                                row.appendChild(div);
                            });
                            // Tecla borrar al final
                            const del = document.createElement('div');
                            del.className = 'vk-key danger';
                            del.dataset.key = 'backspace';
                            del.setAttribute('title', 'Borrar');
                            del.innerHTML = '<i class="fas fa-backspace"></i>';
                            row.appendChild(del);
                        }

                        // Construir el teclado la primera vez según preferencias
                        // Ajustar radios al estado actual
                        const syncRadiosToState = () => {
                            const vk = document.getElementById('vk');
                            if (!vk) return;
                            vk.querySelectorAll('input[name="vk-layout"]').forEach(el => { el.checked = (el.value === VK_LAYOUT); });
                            vk.querySelectorAll('input[name="vk-lang"]').forEach(el => { el.checked = (el.value === VK_LANG); });
                        };
                        renderVirtualKeyboard();
                        renderAccents();
                        syncRadiosToState();
                        // Escuchar cambios de layout (radios)
                        const layoutRadios = (document.getElementById('vk') || document).querySelectorAll('input[name="vk-layout"]');
                        layoutRadios.forEach(r => {
                            r.addEventListener('change', () => {
                                if (r.checked) {
                                    VK_LAYOUT = r.value === 'azerty' ? 'azerty' : 'qwerty';
                                    localStorage.setItem('vk_layout', VK_LAYOUT);
                                    renderVirtualKeyboard();
                                }
                            });
                        });
                        const langRadios = (document.getElementById('vk') || document).querySelectorAll('input[name="vk-lang"]');
                        langRadios.forEach(r => {
                            r.addEventListener('change', () => {
                                if (r.checked) {
                                    VK_LANG = r.value === 'fr' ? 'fr' : 'es';
                                    localStorage.setItem('vk_lang', VK_LANG);
                                    renderVirtualKeyboard();
                                    renderAccents();
                                }
                            });
                        });
                        // Evitar que los radios provoquen blur del input; manejar el cambio manualmente
                        const vkControls = (document.getElementById('vk') || document).querySelector('.vk-controls');
                        if (vkControls) {
                            const applyLayout = (newLayout) => {
                                VK_LAYOUT = newLayout === 'azerty' ? 'azerty' : 'qwerty';
                                localStorage.setItem('vk_layout', VK_LAYOUT);
                                // actualizar estado visual de radios
                                try {
                                    const vkEl = document.getElementById('vk');
                                    if (vkEl) {
                                        vkEl.querySelectorAll('input[name="vk-layout"]').forEach(el => {
                                            el.checked = (el.value === VK_LAYOUT);
                                        });
                                    }
                                } catch { }
                                renderVirtualKeyboard();
                                // asegurar foco y mantener teclado visible
                                inputEl.focus({ preventScroll: true });
                            };
                            const applyLang = (newLang) => {
                                VK_LANG = newLang === 'fr' ? 'fr' : 'es';
                                localStorage.setItem('vk_lang', VK_LANG);
                                try {
                                    const vkEl = document.getElementById('vk');
                                    if (vkEl) {
                                        vkEl.querySelectorAll('input[name="vk-lang"]').forEach(el => {
                                            el.checked = (el.value === VK_LANG);
                                        });
                                    }
                                } catch { }
                                renderVirtualKeyboard();
                                renderAccents();
                                inputEl.focus({ preventScroll: true });
                            };
                            const startInteract = () => {
                                vkInteracting = true;
                                if (vkInteractTimer) { clearTimeout(vkInteractTimer); vkInteractTimer = null; }
                            };
                            const endInteractSoon = () => {
                                if (vkInteractTimer) clearTimeout(vkInteractTimer);
                                vkInteractTimer = setTimeout(() => { vkInteracting = false; }, 140);
                            };
                            vkControls.addEventListener('pointerdown', (e) => {
                                const label = e.target.closest('.vk-radio');
                                if (!label) return;
                                e.preventDefault();
                                e.stopPropagation();
                                startInteract();
                                const inputLayout = label.querySelector('input[name="vk-layout"]');
                                const inputLang = label.querySelector('input[name="vk-lang"]');
                                if (inputLayout) applyLayout(inputLayout.value);
                                if (inputLang) applyLang(inputLang.value);
                            }, { passive: false });
                            vkControls.addEventListener('pointerup', endInteractSoon);
                            vkControls.addEventListener('pointercancel', endInteractSoon);
                            // También manejar click por si algún navegador no dispara pointer events
                            vkControls.addEventListener('click', (e) => {
                                const label = e.target.closest('.vk-radio');
                                if (!label) return;
                                e.preventDefault();
                                e.stopPropagation();
                                startInteract();
                                const inputLayout = label.querySelector('input[name="vk-layout"]');
                                const inputLang = label.querySelector('input[name="vk-lang"]');
                                if (inputLayout) applyLayout(inputLayout.value);
                                if (inputLang) applyLang(inputLang.value);
                                endInteractSoon();
                            }, { passive: false });
                        }
                        // Wire de clicks del teclado (usar referencias dinámicas)
                        {
                            const vkEl = document.getElementById('vk');
                            const vkOverlayEl = document.getElementById('vk-overlay');
                            if (vkEl) {
                                // Usar pointerdown para soportar móvil y desktop sin bloquear eventos subsiguientes
                                vkEl.addEventListener('pointerdown', (e) => {
                                    const target = e.target.closest('.vk-key');
                                    if (!target) return;
                                    // Marcar interacción con el teclado para suprimir blur momentáneo
                                    vkInteracting = true;
                                    if (vkInteractTimer) { clearTimeout(vkInteractTimer); vkInteractTimer = null; }
                                    const key = target.dataset.key;
                                    if (!key) return;
                                    e.preventDefault();
                                    e.stopPropagation();
                                    try { vibrar(80); } catch { }
                                    // Efecto visual de hover temporal
                                    try {
                                        target.classList.add('press-glow');
                                        setTimeout(() => target.classList.remove('press-glow'), 1000);
                                    } catch { }
                                    handleVirtualKey(key);
                                }, { passive: false });
                                // Limpiar la marca de interacción al soltar/cancelar
                                const clearVKInteract = () => {
                                    if (vkInteractTimer) clearTimeout(vkInteractTimer);
                                    vkInteractTimer = setTimeout(() => { vkInteracting = false; }, 120);
                                };
                                vkEl.addEventListener('pointerup', clearVKInteract);
                                vkEl.addEventListener('pointercancel', clearVKInteract);
                            }
                            // Evitar que los clics del overlay cierren la tarjeta o hagan flip
                            if (vkOverlayEl) {
                                let vkHideTimer = null;
                                vkOverlayEl.addEventListener('click', (e) => {
                                    // Solo cerrar si se toca fuera del teclado y sin rebotes
                                    if (e.target === vkOverlayEl) {
                                        if (vkHideTimer) clearTimeout(vkHideTimer);
                                        vkHideTimer = setTimeout(() => blurHandler(), 60);
                                    }
                                });
                            }
                        }
                        // ====== FIN TECLADO VIRTUAL ======

                        // Función de limpieza para remover event listeners
                        const cleanupKeyboardDetection = () => {
                            inputEl.removeEventListener('focus', focusHandler);
                            inputEl.removeEventListener('blur', blurHandler);
                            window.removeEventListener('resize', handleResize);
                            try {
                                if (inputContainer) {
                                    inputContainer.removeEventListener('pointerdown', focusFromContainer);
                                    inputContainer.removeEventListener('click', focusFromContainer);
                                }
                                inputEl.removeEventListener('pointerdown', ensureVKVisibleOnTap);
                                inputEl.removeEventListener('click', ensureVKVisibleOnTap);
                                restorePlaceholder();
                            } catch { }
                            // MODIFICADO: En lugar de ocultar siempre el botón móvil "No sé", 
                            // solo ocultarlo si realmente debe estar oculto según el estado del juego
                            // if (typeof hideMobileSkipButton === 'function') hideMobileSkipButton(true);

                            // Forzar ocultado del overlay del teclado virtual si está visible
                            try {
                                const vkEl = document.getElementById('vk');
                                const vkOverlayEl = document.getElementById('vk-overlay');
                                if (vkEl && vkOverlayEl) {
                                    vkEl.classList.remove('show');
                                    vkOverlayEl.style.display = 'none';
                                }
                            } catch { }
                            // También marcar estado global como teclado oculto
                            document.body.classList.add('keyboard-hidden');
                            document.documentElement.classList.add('keyboard-hidden');
                            document.body.classList.remove('keyboard-visible');
                            document.documentElement.classList.remove('keyboard-visible');
                            // MODIFICADO: No limpiar automáticamente los botones móviles "No sé"
                            // try { document.querySelectorAll('.mobile-skip-button').forEach(btn => btn.classList.remove('keyboard-visible')); } catch {}
                        };

                        // Guardar función de limpieza para uso posterior
                        backElement._cleanupKeyboardDetection = cleanupKeyboardDetection;

                        const showMsg = (text, type) => {
                            msgEl.textContent = text;
                            msgEl.className = 'type-message ' + type;
                            msgEl.style.display = 'block';
                        };

                        // Proceder tras acierto: éxito (inmediato) -> (al 80% del win) audio tarjeta -> (al terminar audio) countdown
                        const proceedAfterCorrect = () => {
                            stopAllAudios();
                            // 1) Win inmediato
                            const winEl = playSuccessSound();
                            // 2) Disparar audio tarjeta cuando el win haya consumido el 80%
                            let triggered = false;
                            const triggerCardAudio = () => {
                                if (triggered) return; triggered = true;
                                // Limpiar listeners del win para evitar fugas/doble ejecución
                                try {
                                    if (winEl) {
                                        winEl.removeEventListener('timeupdate', onTimeUpdate);
                                        winEl.removeEventListener('loadedmetadata', onMeta);
                                        winEl.removeEventListener('ended', onEndedFallback);
                                    }
                                } catch { }
                                // 3) Reproducir audio de la tarjeta y, al terminar, iniciar countdown
                                playCardAudio(card, () => showCountdown(card));
                            };

                            const onEndedFallback = () => triggerCardAudio();
                            let thresholdTime = null;

                            const computeThreshold = () => {
                                if (!winEl) return;
                                const d = Number.isFinite(winEl.duration) ? winEl.duration : NaN;
                                if (!isNaN(d) && d > 0) {
                                    thresholdTime = d * 0.6;
                                }
                            };
                            const onMeta = () => {
                                computeThreshold();
                                // Si por cualquier razón ya estamos más allá del 80%, dispara ya
                                if (thresholdTime !== null && winEl.currentTime >= thresholdTime) triggerCardAudio();
                            };
                            const onTimeUpdate = () => {
                                if (thresholdTime === null) computeThreshold();
                                if (thresholdTime !== null && winEl.currentTime >= thresholdTime) triggerCardAudio();
                            };

                            if (winEl) {
                                // Si ya conocemos la duración, intentamos calcular inmediatamente
                                computeThreshold();
                                // Registramos listeners
                                winEl.addEventListener('loadedmetadata', onMeta);
                                winEl.addEventListener('timeupdate', onTimeUpdate);
                                winEl.addEventListener('ended', onEndedFallback);
                                // Fallback por si no llegan eventos (máximo 5s)
                                setTimeout(() => triggerCardAudio(), 5000);
                            } else {
                                // Si falló la reproducción del win, avanzamos directamente
                                triggerCardAudio();
                            }
                        };

                        const handleCheck = () => {
                            // Desactivar "comprobar" al iniciar para evitar reentradas y dobles clicks
                            if (checkBtn) {
                                if (checkBtn.disabled) return; // ya en curso
                                checkBtn.disabled = true;
                                checkBtn.style.pointerEvents = 'none';
                            }
                            const userRaw = inputEl.value.trim();
                            const userNorm = normalize(userRaw);

                            // Si el input está vacío, mostrar animación roja y no procesar
                            if (!userNorm) {
                                inputEl.classList.add('input-error-empty');
                                vibrar(100); // Vibración más fuerte para indicar error
                                // Rehabilitar inmediatamente si estaba vacío
                                if (checkBtn) {
                                    checkBtn.disabled = false;
                                    checkBtn.style.pointerEvents = 'auto';
                                }
                                return;
                            }

                    const isAnswerMatch = userNorm === answerNorm || matchesAnswerWords(userNorm, answerNorm);
                            // Si el usuario escribió exactamente la respuesta o la incluye dentro de su frase
                            if (isAnswerMatch) {
                                // Bloquear skip durante el flujo de acierto
                                lockedAfterCorrect = true;
                                betweenAttempts = false;
                                showingErrorMessage = false;
                                lockedAfterSecondIncorrect = false;
                                try { updateSkipButtonState(); } catch { }
                                // Mantener desactivado "comprobar" hasta pasar a la siguiente tarjeta
                                if (checkBtn) {
                                    checkBtn.disabled = true;
                                    checkBtn.style.pointerEvents = 'none';
                                }

                                correctCount++;
                                correctWords.push(answerRaw);
                                correctWordDetails.push({ front: getFrontTextFromCard(card), back: answerRaw });
                                updateCounters();
                                // Mostrar y animar la respuesta correcta encima del cuadro de texto
                                if (titleEl) {
                                    titleEl.textContent = answerRaw;
                                    titleEl.style.display = 'inline-block';
                                    titleEl.style.top = '20%';
                                    titleEl.classList.remove('success');
                                    void titleEl.offsetWidth; // reinicia animación
                                    titleEl.classList.add('success');
                                }
                                // Precalentar audio de la tarjeta para minimizar latencia tras el win
                                try {
                                    if (card) {
                                        if (!card._audioEl) card._audioEl = new Audio();
                                        card._audioEl.preload = 'auto';
                                        const nextSrc = getAudioSrcForCountryName(answerRaw);
                                        if (nextSrc) {
                                            if (card._audioEl.src !== nextSrc) card._audioEl.src = nextSrc;
                                            try { card._audioEl.load(); } catch { }
                                        }
                                    }
                                } catch { }
                                // El sonido de éxito ya lo dispara proceedAfterCorrect con encadenamiento
                                // Ocultar mensaje de texto para no duplicar
                                if (msgEl) msgEl.style.display = 'none';
                                // Efecto eufórico ya definido en CSS
                                // Sumar y pasar a la siguiente en 3s
                                scheduleStatsBoxUpdate();
                                // Marcar tarjeta como completada y bloquear volteo hasta avance
                                if (!completedCards.has(currentCardIndex)) {
                                    completedCards.add(currentCardIndex);
                                    updateCardCounter();
                                    saveGameProgress();
                                }
                                proceedAfterCorrect();
                            } else {
                                // Incorrecto
                                voiceAttempts++; // Incrementar intentos
                                playErrorSound();
                                // Mostrar mensaje de error y controlar estado de skip
                                showingErrorMessage = true;
                                betweenAttempts = false;
                                lockedAfterCorrect = false;
                                // Aún no bloquear definitivamente por segundo fallo hasta confirmarlo
                                lockedAfterSecondIncorrect = false;
                                try { updateSkipButtonState(); } catch { }

                                // Mostrar "Incorrecto" en la misma posición que la respuesta correcta
                                if (titleEl) {
                                    titleEl.textContent = 'Incorrecto';
                                    titleEl.style.display = 'inline-block';
                                    titleEl.style.top = '20%';
                                    titleEl.classList.remove('success');
                                    titleEl.classList.add('error-response');
                                    void titleEl.offsetWidth; // reinicia cualquier animación
                                }
                                // Ocultar mensaje de texto para no duplicar
                                if (msgEl) msgEl.style.display = 'none';

                                if (voiceAttempts >= 2) {
                                    // Segundo intento fallido - mostrar respuesta correcta y proceder
                                    incorrectCount++;
                                    incorrectWords.push(answerRaw);
                                    incorrectWordDetails.push({ front: getFrontTextFromCard(card), back: answerRaw });
                                    updateCounters();
                                    // Bloquear skip hasta pasar de tarjeta
                                    lockedAfterSecondIncorrect = true;
                                    try { updateSkipButtonState(); } catch { }
                                    // Mantener desactivado "comprobar" hasta pasar de tarjeta
                                    if (checkBtn) {
                                        checkBtn.disabled = true;
                                        checkBtn.style.pointerEvents = 'none';
                                    }

                                    // 1500ms: Ocultar "Incorrecto"
                                    setTimeout(() => {
                                        if (titleEl) {
                                            titleEl.style.display = 'none';
                                            titleEl.classList.remove('error-response');
                                        }
                                        // Ya no se está mostrando mensaje de error
                                        showingErrorMessage = false;
                                        try { updateSkipButtonState(); } catch { }
                                    }, 1500);

                                    // 1600ms: Mostrar respuesta correcta con animación triste E iniciar audio
                                    setTimeout(() => {
                                        if (titleEl) {
                                            titleEl.textContent = answerRaw;
                                            titleEl.style.display = 'inline-block';
                                            titleEl.style.top = '20%';
                                            titleEl.classList.remove('success', 'error-response');
                                            titleEl.classList.add('sad-correct'); // Animación triste
                                        }

                                        // Marcar como completada
                                        if (!completedCards.has(currentCardIndex)) {
                                            completedCards.add(currentCardIndex);
                                            updateCardCounter();
                                            saveGameProgress();
                                        }

                                        // Iniciar audio inmediatamente y luego countdown
                                        stopAllAudios();
                                        playCardAudio(card, () => showCountdown(card));
                                    }, 1600);
                                } else {
                                    // Primer intento fallido - solo mostrar error temporalmente
                                    // Deshabilitar botón mezclar después del primer intento fallido
                                    const shuffleBtn = document.getElementById('shuffle-button');
                                    if (shuffleBtn) {
                                        shuffleBtn.disabled = true;
                                    }

                                    setTimeout(() => {
                                        if (titleEl) {
                                            titleEl.style.display = 'none';
                                            titleEl.classList.remove('error-response');
                                        }
                                        // Termina el mensaje de error; habilitar ventana entre intentos
                                        showingErrorMessage = false;
                                        betweenAttempts = true;
                                        try { updateSkipButtonState(); } catch { }
                                        // Rehabilitar "comprobar" para el segundo intento y restaurar su estado visual (hover->normal)
                                        if (checkBtn) {
                                            checkBtn.disabled = false;
                                            checkBtn.style.pointerEvents = 'auto';
                                            // Restablecer a estado normal
                                            checkBtn.classList.remove('button-pressed', 'button-disabled', 'hover');
                                            checkBtn.blur();
                                            checkBtn.style.opacity = '';
                                            checkBtn.style.filter = '';
                                        }
                                    }, 2000); // Desaparece después de 2s para permitir segundo intento
                                }
                            }
                        };

                        // Evitar que el click dentro del diálogo voltee la tarjeta por burbujeo
                        const stopFlip = (e) => { e.stopPropagation(); };
                        ['click', 'mousedown', 'touchstart'].forEach(evt => {
                            dialogContainer.addEventListener(evt, stopFlip);
                            inputEl.addEventListener(evt, stopFlip);
                            checkBtn.addEventListener(evt, stopFlip);
                            clearBtn.addEventListener(evt, stopFlip);
                            const noDuplicateBtn = backElement.querySelector('#no-duplicate-button');
                            if (noDuplicateBtn) noDuplicateBtn.addEventListener(evt, stopFlip);
                        });

                        // Click en comprobar (evitar flip y acción por defecto)
                        checkBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            vibrar(100);
                            // Efecto visual de presionado (mantener hasta que el usuario escriba)
                            checkBtn.classList.add('button-pressed');
                            handleCheck();
                        });

                        // Click en "No sé" (hace la misma función que el botón principal "No sé")
                        const noDuplicateBtn = backElement.querySelector('#no-duplicate-button');
                        if (noDuplicateBtn) {
                            noDuplicateBtn.addEventListener('click', (e) => {
                                console.log('🔥 Botón No sé duplicado clickeado');
                                e.preventDefault();
                                e.stopPropagation();
                                vibrar(60);
                                playButtonSound();
                                console.log('🔥 Ejecutando skipCurrentCardAsUnknown...');
                                skipCurrentCardAsUnknown();
                                console.log('🔥 skipCurrentCardAsUnknown ejecutado');
                            });
                        } else {
                            console.error('❌ No se encontró el botón no-duplicate-button');
                        }

                        // Click en limpiar (evitar flip y vaciar contenido)
                        clearBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            // Si el input ya está vacío, mostrar animación roja
                            if (!inputEl.value.trim()) {
                                inputEl.classList.add('input-error-empty');
                                vibrar(80); // Vibración consistente para indicar que no hay nada que borrar
                                return;
                            }

                            // Si hay contenido, proceder normalmente
                            vibrar(80);
                            playTrashSound();
                            inputEl.value = '';
                            inputEl.focus();
                            // Limpiar el valor persistido solo si el usuario limpia
                            syncUserInput();
                            // Restablecer color del botón comprobar y quitar animación de error al limpiar el texto
                            checkBtn.classList.remove('button-pressed');
                            inputEl.classList.remove('input-error-empty');
                        });

                        // Usar la variable isSamsungBrowser ya declarada arriba
                        const touchDelay = isSamsungBrowser ? 500 : 200;
                        // Enter para comprobar
                        inputEl.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') { e.preventDefault(); handleCheck(); }
                        });

                        // Restablecer color del botón comprobar y quitar animación de error cuando el usuario empiece a escribir
                        inputEl.addEventListener('input', () => {
                            checkBtn.classList.remove('button-pressed');
                            inputEl.classList.remove('input-error-empty');
                            playKeyboardSound(); // Sonido de tecla al escribir
                            // Guardar valor al teclear normalmente
                            syncUserInput();
                        });

                        // Importante: no iniciar SpeechRecognition aquí a menos que haya permisos concedidos.

                        // Listeners de caracteres especiales (para PC)
                        const charBtns = backElement.querySelectorAll('.char-btn');
                        charBtns.forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                vibrar(30);
                                playKeyboardSound();
                                const char = btn.getAttribute('data-char');
                                const currentPos = inputEl.selectionStart ?? inputEl.value.length;
                                const currentValue = inputEl.value;
                                const newValue = currentValue.slice(0, currentPos) + char + currentValue.slice(currentPos);
                                inputEl.value = newValue;
                                checkBtn.classList.remove('button-pressed');
                                inputEl.classList.remove('input-error-empty');
                                inputEl.focus();
                                inputEl.setSelectionRange(currentPos + 1, currentPos + 1);
                                // Guardar valor al insertar carácter especial
                                syncUserInput();
                            });
                        });

                        // Fin del modo escrito

                        // Si no quedaran intentos (lógica antigua), mostramos respuesta; ya no aplicará, pero preservo comportamiento
                        if (voiceAttempts >= 2) {
                            // No quedan intentos - mostrar respuesta directamente
                            console.log(`Sin intentos restantes (${voiceAttempts}), mostrando respuesta directamente`);
                            // Eliminar indicador cuando aparece la respuesta directa (no-op)
                            try { backElement.querySelectorAll('.listening-indicator').forEach(el => el.remove()); } catch (e) { }

                            // ANTI-TRUCO (refuerzo): marcar como completada al mostrar respuesta directa
                            if (!completedCards.has(currentCardIndex)) {
                                completedCards.add(currentCardIndex);
                                updateCardCounter();
                                saveGameProgress();
                            }

                            // Mostrar la respuesta correcta con efecto de brillo
                            const respuestaCorrecta = document.createElement('div');
                            respuestaCorrecta.textContent = card.dataset.answer;
                            respuestaCorrecta.style.animation = 'respuestaGlow 1.5s infinite';
                            respuestaCorrecta.style.marginTop = '40px';
                            backElement.appendChild(respuestaCorrecta);

                            // Reproducir audio si existe y después mostrar countdown
                            stopAllAudios();
                            playCardAudio(card, () => showCountdown(card));
                        }
                        // En back, por defecto el botón No sé queda deshabilitado (salvo ventana entre intentos)
                        updateSkipButtonState();
                    }
                });
            });
        }

        // Anclar manejadores de tarjetas al cargar
        attachFlashcardHandlers();
        window.addEventListener('DOMContentLoaded', () => {
            // Guardar HTML original del tablero de tarjetas por si luego se reemplaza
            const container = document.getElementById('flashcard-container');
            if (container && !originalFlashcardsHTML) {
                originalFlashcardsHTML = container.innerHTML;
            }



            // VERIFICAR SI HAY PROGRESO GUARDADO ANTES DE INICIALIZAR
            if (hasProgressSaved()) {
                // Asegurar que el "avance anterior" se pinte desde localStorage aunque mostremos el modal
                updateLastGamePillFromStorage();
                // Mostrar modal de continuación si hay progreso
                setTimeout(() => {
                    showContinueGameModal();
                }, 500); // Pequeño delay para que la página termine de cargar
                return; // No ejecutar el resto de la inicialización
            }

            // Si no hay progreso guardado, continuar con la inicialización normal
            initializePage();
        });

        // Función para inicializar la página cuando no hay progreso guardado
        function initializePage() {
            // Cargar último porcentaje de aciertos desde localStorage
            const savedPercentage = localStorage.getItem('lastSuccessPercentage');
            const porcentajeDiv = document.getElementById('porcentaje-guardado');
            const porcentajeSpan = document.getElementById('current-percentage');

            if (porcentajeDiv && porcentajeSpan) {
                const percentage = savedPercentage !== null ? parseInt(savedPercentage) : NaN;
                porcentajeSpan.textContent = `${!isNaN(percentage) ? percentage : 0}%`;
                // Fondo transparente como el cuadro; estilo neutro si 0 o no hay datos
                porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
                if (!isNaN(percentage) && percentage > 0) {
                    if (percentage >= 80) {
                        porcentajeDiv.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                        porcentajeDiv.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
                    } else if (percentage >= 60) {
                        porcentajeDiv.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                        porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
                    } else {
                        porcentajeDiv.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                        porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
                    }
                } else {
                    porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    porcentajeDiv.style.boxShadow = 'none';
                }
            }

            // Pintar el porcentaje del último partido (avance anterior)
            updateLastGamePillFromStorage();

            // Mezclar tarjetas automáticamente al cargar la página
            shuffleCards();

            // No es necesario re-mapear audios por índice; la reproducción es por tarjeta

            showCard(currentCardIndex);
            updateCounters();
            // Precargar audio correcto para la tarjeta visible tras primera mezcla
            const firstBack = document.querySelector('.flashcard.is-visible .back');
            const visibleAnswer = firstBack ? firstBack.textContent.trim() : null;
            const visibleSrc = visibleAnswer ? getAudioSrcForCountryName(visibleAnswer) : null;
            if (visibleSrc) {
                const card = flashcards[currentCardIndex];
                if (card) {
                    if (!card._audioEl) card._audioEl = new Audio();
                    card._audioEl.preload = 'auto';
                    card._audioEl.src = visibleSrc;
                    try { card._audioEl.load(); } catch { }
                }
            }
            // Mostrar hints secuenciales al cargar
            showPillHints();
        }

        // Helper: pintar el "avance anterior" desde localStorage en su pill
        function updateLastGamePillFromStorage() {
            const lastGamePercentage = localStorage.getItem('silabas3');
            const lastGameDiv = document.getElementById('last-game-percentage');
            const lastGamePill = document.getElementById('last-game-pill');
            if (lastGamePercentage !== null && lastGameDiv && lastGamePill) {
                const gamePercentage = parseInt(lastGamePercentage);
                lastGameDiv.textContent = `${isNaN(gamePercentage) ? 0 : gamePercentage}%`;
                // Estilo visual del pill según nivel
                lastGamePill.style.background = 'rgba(255,255,255,0.08)';
                if (!isNaN(gamePercentage)) {
                    if (gamePercentage >= 80) {
                        lastGamePill.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                        lastGamePill.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
                    } else if (gamePercentage >= 60) {
                        lastGamePill.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                        lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
                    } else {
                        lastGamePill.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                        lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
                    }
                } else {
                    lastGamePill.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    lastGamePill.style.boxShadow = 'none';
                }
            }
        }

        // Reasignar audios a tarjetas según el texto del reverso (data-answer)
        function reassignAudiosToCards() { /* no-op: audio se resuelve por tarjeta */ }

        function updateCardCounter() {
            const pillFaltan = document.querySelector('.pill-faltan');
            const totalCardsElem = document.getElementById('total-cards');
            const prevValue = Number(pillFaltan.getAttribute('data-prev') || 0);

            const remaining = flashcards.length - completedCards.size;
            totalCardsElem.textContent = remaining;

            if (remaining !== prevValue) {
                pillFaltan.classList.remove('glow-faltan');
                void pillFaltan.offsetWidth; // Reinicia animación
                pillFaltan.classList.add('glow-faltan');
            }
            pillFaltan.setAttribute('data-prev', remaining);

            // Calcular y mostrar porcentaje de aciertos
            updateSuccessPercentage();
        }

        function updateSuccessPercentage() {
            const totalCards = flashcards.length;
            const percentage = totalCards > 0 ? Math.round((correctCount / totalCards) * 100) : 0;

            // Actualizar elemento visual inmediato (la visibilidad la controla el scheduler)
            const porcentajeDiv = document.getElementById('porcentaje-guardado');
            const porcentajeSpan = document.getElementById('current-percentage');
            if (porcentajeDiv && porcentajeSpan) {
                porcentajeSpan.textContent = `${percentage}%`;
                porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
                if (totalCards > 0) {
                    if (percentage >= 80) {
                        porcentajeDiv.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                        porcentajeDiv.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
                    } else if (percentage >= 60) {
                        porcentajeDiv.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                        porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
                    } else {
                        porcentajeDiv.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                        porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
                    }
                } else {
                    porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    porcentajeDiv.style.boxShadow = 'none';
                }
            }

            // Guardar en localStorage
            localStorage.setItem('lastSuccessPercentage', percentage.toString());
            localStorage.setItem('lastUpdateDate', new Date().toISOString());
        }

        function saveLastGamePercentage() {
            const totalCards = flashcards.length;
            const gamePercentage = totalCards > 0 ? Math.round((correctCount / totalCards) * 100) : 0;

            // Guardar porcentaje del último partido jugado
            localStorage.setItem('silabas3', gamePercentage.toString());
            localStorage.setItem('silabas3Date', new Date().toISOString());

            // Actualizar display inmediatamente
            const lastGameDiv = document.getElementById('last-game-percentage');
            const lastGamePill = document.getElementById('last-game-pill');

            if (lastGameDiv && lastGamePill) {
                lastGameDiv.textContent = `${gamePercentage}%`;

                // Cambiar color según el porcentaje del último partido
                // Fondo transparente como el cuadro; solo resaltar borde según nivel
                lastGamePill.style.background = 'rgba(255,255,255,0.08)';
                if (gamePercentage >= 80) {
                    lastGamePill.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                    lastGamePill.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
                } else if (gamePercentage >= 60) {
                    lastGamePill.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                    lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
                } else {
                    lastGamePill.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                    lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
                }
            }

            console.log(`Partido terminado con ${gamePercentage}% de aciertos`);
        }

        window.addEventListener('load', () => {
            document.getElementById('soundResetButton').play().catch(e => console.log(e));
        });

        // (Eliminado) stopAllAudios anterior basado en array global de audios

        // Muestra frases (hints) cerca de los pills al cargar la página
        function showPillHints() {
            const lastGamePill = document.getElementById('last-game-pill');
            const currentPill = document.getElementById('porcentaje-guardado');
            const statsBox = document.getElementById('stats-box');
            if (!lastGamePill || !currentPill) return;

            // Helper para crear y mostrar un hint sobre un objetivo
            function createHint(target, text, delayMs = 0, onRemoved = null) {
                const hint = document.createElement('div');
                hint.className = 'pill-hint';
                hint.textContent = text;
                // Configurar animación de tipeo según longitud
                const chars = Math.max(8, text.length);
                hint.style.setProperty('--chars', chars);
                const typeDur = Math.min(1800, 60 * chars);
                hint.style.setProperty('--type-dur', `${typeDur}ms`);
                hint.style.setProperty('--delay', `${delayMs}ms`);
                // Mantener visible SOLO 4s en total (tipeo + lectura)
                // Si el tipeo tarda X ms, mantenemos (4000 - X) ms extra antes de iniciar el fade
                const holdAfterTyping = Math.max(0, 4000 - typeDur);
                const fadeDelay = delayMs + typeDur + holdAfterTyping;
                hint.style.setProperty('--fade-delay', `${fadeDelay}ms`);
                target.appendChild(hint);
                // Remover al terminar el fade
                setTimeout(() => {
                    hint.remove();
                    if (typeof onRemoved === 'function') onRemoved();
                }, fadeDelay + 600);
            }

            // Secuencia: primero el inferior; cuando se elimina, mostramos el superior
            const bottomText = 'Avance anterior';
            const topText = 'Avance actual';
            const bottomDelay = 200; // inicio del inferior

            createHint(lastGamePill, bottomText, bottomDelay, () => {
                // pequeño gap tras eliminar el inferior
                setTimeout(() => {
                    // Crear el superior y, al eliminarse, programar esconder el cuadro 3s después
                    createHint(currentPill, topText, 0, () => {
                        if (statsBox) {
                            setTimeout(() => {
                                statsBox.classList.add('hidden');
                            }, 3000); // 3 segundos después de desaparecer el hint superior
                        }
                    });
                }, 150);
            });
        }

        function resetGame() {
            // Asegurar que cualquier UI/teclado/back quede limpio antes de reiniciar
            try { resetBackUI(); } catch (e) { console.warn('resetBackUI fallo:', e); }
            // Si el tablero fue reemplazado por una pantalla final, restaurarlo
            reinitFlashcardsDOMIfMissing();

            // Solo guardar el avance si hay un juego completado (no al reiniciar desde 0)
            const totalAttempts = correctCount + incorrectCount;
            if (totalAttempts > 0) {
                saveLastGamePercentage();
            }

            // LIMPIAR PROGRESO GUARDADO al reiniciar
            clearCurrentProgress();

            // Limpiar timeouts de stats box si estuvieran activos
            if (statsShowTimeoutId) { clearTimeout(statsShowTimeoutId); statsShowTimeoutId = null; }
            if (statsHideTimeoutId) { clearTimeout(statsHideTimeoutId); statsHideTimeoutId = null; }
            if (percentageUpdateTimeoutId) { clearTimeout(percentageUpdateTimeoutId); percentageUpdateTimeoutId = null; }

            // Resetear todas las variables del juego
            currentCardIndex = 0;
            voiceAttempts = 0;
            completedCards.clear();
            correctWords.length = 0;
            incorrectWords.length = 0;
            correctWordDetails.length = 0;
            incorrectWordDetails.length = 0;
            correctCount = 0;
            incorrectCount = 0;
            shuffleClickCount = 0; // Restablecer usos de Mezclar
            try { localStorage.removeItem('silabas3_shuffleCount'); } catch (e) { }

            // Limpiar timeouts activos
            if (typeof autoFlipTimer !== 'undefined') {
                clearTimeout(autoFlipTimer);
            }

            // Resetear todas las tarjetas al estado inicial
            const allCards = document.querySelectorAll('.flashcard');
            allCards.forEach(card => {
                card.classList.remove('flipped');

                // Limpiar indicadores de respuesta
                const backElement = card.querySelector('.back');
                if (backElement) {
                    backElement.classList.remove('correct-answer', 'incorrect-answer', 'hidden-text');

                    // Resetear intentos mostrados
                    const attemptsDiv = backElement.querySelector('.attempts');
                    if (attemptsDiv) {
                        attemptsDiv.remove();
                    }
                }
            });

            // Habilitar botón de mezclar
            document.getElementById('shuffle-button').disabled = false;

            // Limpiar cualquier modal o overlay existente, excepto el teclado virtual global
            const overlays = document.querySelectorAll('[id$="-overlay"]:not(#vk-overlay)');
            overlays.forEach(overlay => overlay.remove());

            // Resetear botones de palabras correctas/incorrectas (si existen)
            const correctBtn = document.getElementById('correct-words-btn');
            const incorrectBtn = document.getElementById('incorrect-words-btn');
            if (correctBtn) correctBtn.style.display = 'none';
            if (incorrectBtn) incorrectBtn.style.display = 'none';

            // Resetear atributos data-prev de las píldoras
            const correctasPill = document.querySelector('.pill-correctas');
            const incorrectasPill = document.querySelector('.pill-incorrectas');
            if (correctasPill) correctasPill.setAttribute('data-prev', '0');
            if (incorrectasPill) incorrectasPill.setAttribute('data-prev', '0');

            // Actualizar porcentaje actual (pero NO el "avance anterior" que ya se guardó)
            const totalCards = flashcards.length;
            const percentage = 0; // Siempre 0 al reiniciar
            const porcentajeDiv = document.getElementById('porcentaje-guardado');
            const porcentajeSpan = document.getElementById('current-percentage');
            if (porcentajeDiv && porcentajeSpan) {
                porcentajeSpan.textContent = `${percentage}%`;
                porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
                porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                porcentajeDiv.style.boxShadow = 'none';
            }

            // Mezclar tarjetas sin sonido (el sonido es solo para el botón mezclar)
            shuffleCards();

            // Actualizar contadores
            updateCounters();
            updateCardCounter();

            // Mostrar la primera tarjeta
            showCard(0);
        }

        // Limpia la UI de la parte trasera: teclado virtual, inputs, botones y listeners
        function resetBackUI() {
            // 1) Ejecutar limpieza específica de cada tarjeta si fue registrada
            document.querySelectorAll('.flashcard .back').forEach(back => {
                try {
                    if (back._cleanupKeyboardDetection) {
                        back._cleanupKeyboardDetection();
                        delete back._cleanupKeyboardDetection;
                    }
                } catch (e) { console.warn('cleanupKeyboardDetection error:', e); }

                // Limpiar input y mensajes visibles del modo escritura
                const input = back.querySelector('.type-input');
                if (input) { input.value = ''; input.blur && input.blur(); }
                const msg = back.querySelector('.type-message');
                if (msg) { msg.textContent = ''; msg.style.display = 'none'; }
            });

            // 2) Ocultar y resetear estado del teclado virtual global
            try {
                const vk = document.getElementById('vk');
                const vkOverlay = document.getElementById('vk-overlay');
                if (vk && vkOverlay) {
                    vk.classList.remove('show');
                    vkOverlay.style.display = 'none';
                }
            } catch { }

            // 3) Resetear flags/clases globales de teclado
            try {
                document.body.classList.add('keyboard-hidden');
                document.documentElement.classList.add('keyboard-hidden');
                document.body.classList.remove('keyboard-visible');
                document.documentElement.classList.remove('keyboard-visible');
            } catch { }

            // 4) Ocultar estado visual del botón móvil "No sé"
            try { document.querySelectorAll('.mobile-skip-button').forEach(btn => btn.classList.remove('keyboard-visible')); } catch { }

            // 5) Limpiar ventana de protección de clic fantasma del botón móvil
            try { if (window.ignoreClickAfterButton) window.ignoreClickAfterButton = null; } catch { }
        }

        // Restaura el DOM de tarjetas si fue reemplazado por pantallas de fin de juego
        function reinitFlashcardsDOMIfMissing() {
            const container = document.getElementById('flashcard-container');
            if (!container) return;
            const hasCards = container.querySelectorAll('.flashcard').length > 0;
            if (!hasCards && originalFlashcardsHTML) {
                container.innerHTML = originalFlashcardsHTML;
                // Volver a poblar el arreglo global (const) sin reasignar
                const newCards = Array.from(container.querySelectorAll('.flashcard'));
                flashcards.length = 0;
                newCards.forEach(c => flashcards.push(c));
                // Reanclar manejadores de clic
                attachFlashcardHandlers();
            }
        }

        document.getElementById('reset-button').addEventListener('click', () => {
            vibrar(80);
            const soundResetButton = document.getElementById('soundResetButton');
            soundResetButton.play().catch(e => console.log(e));

            // Si el juego YA está finalizado (overlay de fin o pantalla final), reiniciar sin mostrar el toast
            try {
                const overlaysPresent = (
                    document.getElementById('euforia-maxima-overlay') ||
                    document.getElementById('euforia-overlay') ||
                    document.getElementById('perdida-overlay') ||
                    document.getElementById('empate-overlay')
                );
                const container = document.getElementById('flashcard-container');
                const hasCompletionScreen = container && !container.querySelector('.flashcard');
                const totalCardsNow = document.querySelectorAll('.flashcard').length;
                const finishedNow = overlaysPresent || hasCompletionScreen || (totalCardsNow > 0 && completedCards.size >= totalCardsNow);
                if (finishedNow) {
                    const existing = document.getElementById('reset-guard-toast');
                    if (existing) existing.remove();
                    resetGame();
                    return;
                }
            } catch (e) { /* si algo falla, continuar con la lógica normal */ }

            // Permitir reiniciar SOLO si, al cargar, se detectó progreso guardado COMPLETADO
            try {
                const allowResetNow = sessionStorage.getItem('resetAllowedCompletedSavedGame') === 'true';
                if (!allowResetNow) {
                    const existing = document.getElementById('reset-guard-toast');
                    if (existing) existing.remove();
                    const toast = document.createElement('div');
                    toast.id = 'reset-guard-toast';
                    toast.innerHTML = `
                <div style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 12px;
                    font-size: 16px;
                    font-weight: 600;
                ">
                    <div style="
                        font-size: 24px;
                        filter: drop-shadow(0 0 8px rgba(255,152,0,0.6));
                    ">⏳</div>
                    <span>Finaliza el juego primero</span>
                </div>
            `;
                    toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30,30,30,0.95) 0%, rgba(50,50,50,0.95) 100%);
                color: #fff;
                padding: 20px 28px;
                border-radius: 16px;
                font-weight: 600;
                font-size: 16px;
                letter-spacing: 0.3px;
                z-index: 10000;
                backdrop-filter: blur(12px);
                border: 1px solid rgba(255,152,0,0.3);
                box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 20px rgba(255,152,0,0.1);
                animation: modernFadeInOut 2.2s ease;
                min-width: 280px;
                text-align: center;
            `;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 2200);
                    return;
                }
                // Consumir la bandera y reiniciar
                sessionStorage.removeItem('resetAllowedCompletedSavedGame');
                resetGame();
                return;
            } catch (e) { /* si falla sessionStorage, continuar con lógica anterior */ }

            // Calcular estado de juego para mensaje en juego no finalizado
            const started = ((correctCount + incorrectCount) > 0) || (voiceAttempts > 0);

            if (true) { // bloque anterior reordenado; aquí solo protegemos el caso de juego NO finalizado
                if (started) {
                    const existing = document.getElementById('reset-guard-toast');
                    if (existing) existing.remove();
                    const toast = document.createElement('div');
                    toast.id = 'reset-guard-toast';
                    toast.innerHTML = `
                <div style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 12px;
                    font-size: 16px;
                    font-weight: 600;
                ">
                    <div style="
                        font-size: 24px;
                        filter: drop-shadow(0 0 8px rgba(255,152,0,0.6));
                    ">⏳</div>
                    <span>Finaliza el juego primero</span>
                </div>
            `;
                    toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30,30,30,0.95) 0%, rgba(50,50,50,0.95) 100%);
                color: #fff;
                padding: 20px 28px;
                border-radius: 16px;
                font-weight: 600;
                font-size: 16px;
                letter-spacing: 0.3px;
                z-index: 10000;
                backdrop-filter: blur(12px);
                border: 1px solid rgba(255,152,0,0.3);
                box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 20px rgba(255,152,0,0.1);
                animation: modernFadeInOut 2.2s ease;
                min-width: 280px;
                text-align: center;
            `;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 2200);
                    return; // bloquear si empezó
                }
                return;
            }

            // Resetear el juego sin recargar la página (solo al finalizar)
            resetGame();
        });


        function setBackAttempts(backElement, attemptsLeft, mensajeExtra = "") {
            // Elimina TODOS los contadores de intentos antes de crear uno nuevo
            backElement.querySelectorAll('.intentos-back').forEach(el => el.remove());

            // Ya no mostramos ningún contador visual de intentos.
            // Si quieres mostrar un mensaje extra, puedes hacerlo aquí:
            if (mensajeExtra) {
                const extraDiv = document.createElement('div');
                extraDiv.className = 'mensaje-extra';
                extraDiv.style.marginTop = '10px';
                extraDiv.innerHTML = mensajeExtra;
                backElement.prepend(extraDiv);
            }
        }

        // Agregar sonido a todos los elementos clickeables excepto reiniciar y mezclar
        document.addEventListener('DOMContentLoaded', function () {
            // Función para agregar sonido a elementos clickeables
            function addClickSound(element) {
                if (element && !element.hasAttribute('data-sound-added')) {
                    element.addEventListener('click', function (e) {
                        // Excluir botones de reiniciar y mezclar (ya tienen su propia vibración)
                        if (this.id !== 'reset-button' && this.id !== 'shuffle-button') {
                            vibrar(50); // Vibración leve para elementos clickeables
                            playButtonSound();
                        }
                    });
                    element.setAttribute('data-sound-added', 'true');
                }
            }

            // Agregar sonido a elementos específicos
            const clickableElements = [
                // Botones de control de bandera
                '.flag-control-btn',
                '.flag-close-btn',
                // Botones de modal
                '.modal-close-btn',
                // Tarjetas de palabras
                '.word-card',
                // Pills de estadísticas clickeables
                '.pill-correctas',
                '.pill-incorrectas',
                '.pill-progreso'
            ];

            clickableElements.forEach(selector => {
                document.querySelectorAll(selector).forEach(addClickSound);
            });

            // Observer para elementos que se crean dinámicamente
            const observer = new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    mutation.addedNodes.forEach(function (node) {
                        if (node.nodeType === 1) { // Element node
                            // Buscar elementos clickeables en el nodo agregado
                            clickableElements.forEach(selector => {
                                if (node.matches && node.matches(selector)) {
                                    addClickSound(node);
                                }
                                node.querySelectorAll && node.querySelectorAll(selector).forEach(addClickSound);
                            });

                            // Manejar elementos con onclick dinámicos
                            if (node.onclick || node.getAttribute('onclick')) {
                                addClickSound(node);
                            }
                            node.querySelectorAll && node.querySelectorAll('[onclick]').forEach(addClickSound);
                        }
                    });
                });
            });

            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        });

        // Prevenir menú contextual (clic derecho y presión larga)
        document.addEventListener('contextmenu', function (e) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }, true);

        // Prevenir arrastrar imágenes
        document.addEventListener('dragstart', function (e) {
            if (e.target.tagName === 'IMG') {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }, true);

        // Prevenir presión larga en dispositivos móviles
        document.addEventListener('touchstart', function (e) {
            if (e.target.tagName === 'IMG') {
                // Solo permitir un toque, prevenir presión larga
                setTimeout(() => {
                    e.target.style.pointerEvents = 'none';
                    setTimeout(() => {
                        e.target.style.pointerEvents = '';
                    }, 50);
                }, 10);
            }
        }, { passive: false });

        // Prevenir selección con teclado
        document.addEventListener('keydown', function (e) {
            // Prevenir Ctrl+A, Ctrl+C, Ctrl+S, F12, etc.
            if ((e.ctrlKey || e.metaKey) && (e.key === 'a' || e.key === 'A' ||
                e.key === 'c' || e.key === 'C' || e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            // Prevenir F12 (DevTools)
            if (e.key === 'F12') {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }, true);

        // ============ GUARDADO AUTOMÁTICO EN EVENTOS DE PÁGINA ============
        // Guardar progreso cuando el usuario cambie de pestaña, minimice la ventana o cierre la página
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'hidden') {
                // Solo guardar si hay progreso actual
                const totalAttempts = correctCount + incorrectCount;
                const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;

                if (hasCurrentProgress) {
                    saveGameProgress();
                    console.log('Progreso guardado al cambiar de pestaña');
                }
            }
        });

        // Guardar progreso antes de que se cierre la página
        window.addEventListener('beforeunload', function () {
            // Solo guardar si hay progreso actual
            const totalAttempts = correctCount + incorrectCount;
            const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;

            if (hasCurrentProgress) {
                saveGameProgress();
                console.log('Progreso guardado antes de cerrar página');
            }
        });

        // Guardar progreso periódicamente cada 30 segundos si hay actividad
        let autoSaveInterval = null;

        function startAutoSave() {
            if (autoSaveInterval) return; // Ya está corriendo

            autoSaveInterval = setInterval(() => {
                const totalAttempts = correctCount + incorrectCount;
                const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;

                if (hasCurrentProgress) {
                    saveGameProgress();
                    console.log('Guardado automático periódico');
                }
            }, 30000); // Cada 30 segundos
        }

        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
        }

        // Iniciar guardado automático cuando el usuario comience a jugar
        document.addEventListener('DOMContentLoaded', function () {
            // Esperar un poco antes de iniciar el auto-guardado
            setTimeout(() => {
                startAutoSave();
            }, 5000); // Empezar después de 5 segundos

            // Inicializar sistema de conectividad
            initConnectivityMonitor();
        });

        // === SISTEMA DE MONITOREO DE CONECTIVIDAD ===
        let connectivityCheckInterval = null;
        let isConnectivityOverlayVisible = false;
        let connectivityCheckInProgress = false;
        let lastConnectionStatus = true;

        // Inicializar el monitor de conectividad
        function initConnectivityMonitor() {
            console.log('🌐 Iniciando monitor de conectividad...');

            // Verificar conexión inicial
            setTimeout(() => {
                checkInternetConnection();
            }, 2000);

            // Escuchar eventos de online/offline del navegador
            window.addEventListener('online', handleOnlineEvent);
            window.addEventListener('offline', handleOfflineEvent);

            // Configurar el botón de reintentar
            const retryBtn = document.getElementById('connectivity-retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', handleRetryConnection);
            }

            // Iniciar verificación periódica cada 10 segundos
            startPeriodicConnectivityCheck();
        }

        // ======= Controles de teclado para PC =======
        function isDesktopLike() {
            // Considera desktop si la pantalla es amplia y no hay interacción táctil primaria
            return window.innerWidth >= 768 && !('ontouchstart' in window);
        }

        document.addEventListener('keydown', function (e) {
            if (!isDesktopLike()) return;

            const target = e.target;
            if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) {
                return;
            }

            if (e.repeat) return;

            const key = e.key;
            const code = e.code;

            // Espacio: voltear tarjeta
            if (key === ' ' || code === 'Space') {
                const card = document.querySelector('.flashcard.is-visible');
                if (card && typeof canFlip !== 'undefined' && canFlip) {
                    e.preventDefault();
                    e.stopPropagation();
                    card.click();
                }
                return;
            }

            // 5: Reiniciar juego
            if (key === '5' || code === 'Numpad5') {
                const resetBtn = document.getElementById('reset-button');
                if (resetBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    resetBtn.click();
                }
                return;
            }

            // 6: Botón No sé
            if (key === '6' || code === 'Numpad6') {
                const skipBtn = document.getElementById('skip-button');
                if (skipBtn && !skipBtn.disabled) {
                    e.preventDefault();
                    e.stopPropagation();
                    skipBtn.click();
                }
                return;
            }

            // 7: Mezclar tarjetas
            if (key === '7' || code === 'Numpad7') {
                const shuffleBtn = document.getElementById('shuffle-button');
                if (shuffleBtn && !shuffleBtn.disabled) {
                    e.preventDefault();
                    e.stopPropagation();
                    shuffleBtn.click();
                }
                return;
            }

            // 8: Alternar mute
            if (key === '8' || code === 'Numpad8') {
                const soundBtn = document.getElementById('sound-toggle-btn');
                if (soundBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    soundBtn.click();
                }
            }
        }, false);

        // Manejar evento de conexión online
        function handleOnlineEvent() {
            console.log('🟢 Evento online detectado');
            setTimeout(() => {
                checkInternetConnection();
            }, 1000); // Dar tiempo para que la conexión se estabilice
        }

        // Manejar evento de desconexión offline
        function handleOfflineEvent() {
            console.log('🔴 Evento offline detectado');
            updateConnectivityStatus(false, 'Sin conexión a Internet');
        }

        // Verificar conectividad real haciendo fetch a recursos externos
        async function checkInternetConnection() {
            if (connectivityCheckInProgress) return;

            connectivityCheckInProgress = true;
            updateConnectivityStatusText('Verificando conexión...');

            console.log('🔍 Verificando conectividad real...');

            const testUrls = [
                'https://www.google.com/favicon.ico',
                'https://httpbin.org/status/200',
                'https://jsonplaceholder.typicode.com/posts/1',
                'https://api.github.com'
            ];

            let connectionSuccessful = false;

            for (const url of testUrls) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 segundos timeout

                    const response = await fetch(url, {
                        method: 'HEAD',
                        mode: 'no-cors',
                        cache: 'no-cache',
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    console.log(`✅ Conexión exitosa a: ${url}`);
                    connectionSuccessful = true;
                    break;

                } catch (error) {
                    console.log(`❌ Fallo al conectar a: ${url}`, error.message);
                    continue;
                }
            }

            // Si todas las pruebas fallan, intentar con navigator.onLine como respaldo
            if (!connectionSuccessful && navigator.onLine) {
                try {
                    // Prueba simple con fetch a la misma página
                    const response = await fetch(window.location.href, {
                        method: 'HEAD',
                        cache: 'no-cache'
                    });

                    if (response.ok) {
                        connectionSuccessful = true;
                        console.log('✅ Conectividad confirmada con fetch local');
                    }
                } catch (error) {
                    console.log('❌ Fallo en fetch local:', error.message);
                }
            }

            const statusMessage = connectionSuccessful ?
                'Conexión estable' :
                'Sin conexión o muy lenta';

            updateConnectivityStatus(connectionSuccessful, statusMessage);
            connectivityCheckInProgress = false;
        }

        // Actualizar el estado de conectividad
        function updateConnectivityStatus(isConnected, message = '') {
            lastConnectionStatus = isConnected;

            console.log(`📊 Estado de conectividad: ${isConnected ? 'CONECTADO' : 'DESCONECTADO'} - ${message}`);

            if (isConnected) {
                hideConnectivityOverlay();
            } else {
                showConnectivityOverlay(message);
            }
        }

        // Mostrar overlay de conectividad
        function showConnectivityOverlay(message = 'Sin conexión a Internet') {
            if (isConnectivityOverlayVisible) return;

            console.log('🚫 Mostrando overlay de conectividad');

            const overlay = document.getElementById('connectivity-overlay');
            const statusText = document.getElementById('connectivity-status-text');
            const retryBtn = document.getElementById('connectivity-retry-btn');

            if (overlay) {
                // Actualizar mensaje
                updateConnectivityStatusText(message);

                // Mostrar overlay
                overlay.classList.remove('reconnected');
                overlay.classList.add('show');
                isConnectivityOverlayVisible = true;

                // Desabilitar interacciones con el juego
                disableGameInteractions();

                // Reset del botón de retry
                if (retryBtn) {
                    retryBtn.classList.remove('checking');
                }
            }
        }

        // Ocultar overlay de conectividad
        function hideConnectivityOverlay() {
            if (!isConnectivityOverlayVisible) return;

            console.log('✅ Ocultando overlay de conectividad');

            const overlay = document.getElementById('connectivity-overlay');
            const retryBtn = document.getElementById('connectivity-retry-btn');

            if (overlay) {
                // Mostrar efecto de reconexión exitosa
                overlay.classList.add('reconnected');

                // Actualizar contenido para reconexión
                updateConnectivityContent(true);

                // Ocultar después de mostrar el éxito
                setTimeout(() => {
                    overlay.classList.remove('show', 'reconnected');
                    isConnectivityOverlayVisible = false;

                    // Reabilitar interacciones con el juego
                    enableGameInteractions();

                    // Reset del contenido del overlay
                    setTimeout(() => {
                        updateConnectivityContent(false);
                    }, 500);

                }, 2500); // Mostrar éxito por 2.5 segundos

                // Reset del botón
                if (retryBtn) {
                    retryBtn.classList.remove('checking');
                }
            }
        }

        // Actualizar contenido del overlay
        function updateConnectivityContent(isReconnected) {
            const icon = document.querySelector('.connectivity-icon');
            const title = document.querySelector('.connectivity-title');
            const message = document.querySelector('.connectivity-message');

            if (isReconnected) {
                if (icon) icon.textContent = '✅';
                if (title) title.textContent = '¡Reconectado!';
                if (message) message.innerHTML = 'Tu conexión ha sido restablecida.<br>Ya puedes continuar jugando.';
                updateConnectivityStatusText('Conexión restablecida');
            } else {
                if (icon) icon.textContent = '📡';
                if (title) title.textContent = 'Sin Conexión';
                if (message) message.innerHTML = 'Parece que tu conexión a Internet es débil o se ha perdido.<br>Esta aplicación necesita conexión para funcionar correctamente.';
            }
        }

        // Actualizar texto de estado
        function updateConnectivityStatusText(text) {
            const statusText = document.getElementById('connectivity-status-text');
            if (statusText) {
                statusText.textContent = text;
            }
        }

        // Manejar clic en botón de reintentar
        async function handleRetryConnection() {
            const retryBtn = document.getElementById('connectivity-retry-btn');

            if (retryBtn) {
                retryBtn.classList.add('checking');
                retryBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Verificando...</span>';
            }

            updateConnectivityStatusText('Reintentando conexión...');

            // Esperar un poco antes de verificar
            setTimeout(async () => {
                await checkInternetConnection();

                // Restaurar botón después de un tiempo
                setTimeout(() => {
                    if (retryBtn && !lastConnectionStatus) {
                        retryBtn.classList.remove('checking');
                        retryBtn.innerHTML = '<i class="fas fa-redo"></i><span>Intentar de nuevo</span>';
                    }
                }, 2000);
            }, 1500);
        }

        // Desabilitar interacciones del juego
        function disableGameInteractions() {
            console.log('🚫 Deshabilitando interacciones del juego');

            // Pausar el juego si está en progreso
            if (typeof stopAutoSave === 'function') {
                stopAutoSave();
            }

            // Desabilitar botones principales
            const gameButtons = document.querySelectorAll('.button, .pill, .back-arrow');
            gameButtons.forEach(button => {
                button.style.pointerEvents = 'none';
                button.style.opacity = '0.5';
            });

            // Desabilitar flashcards
            const flashcards = document.querySelectorAll('.flashcard');
            flashcards.forEach(card => {
                card.style.pointerEvents = 'none';
                card.style.opacity = '0.7';
            });

            // Pausar reconocimiento de voz si está activo
            if (typeof stopListening === 'function') {
                stopListening();
            }
        }

        // Reabilitar interacciones del juego
        function enableGameInteractions() {
            console.log('✅ Rehabilitando interacciones del juego');

            // Reanudar auto-guardado
            if (typeof startAutoSave === 'function') {
                startAutoSave();
            }

            // Rehabilitar botones
            const gameButtons = document.querySelectorAll('.button, .pill, .back-arrow');
            gameButtons.forEach(button => {
                button.style.pointerEvents = 'auto';
                button.style.opacity = '1';
            });

            // Rehabilitar flashcards
            const flashcards = document.querySelectorAll('.flashcard');
            flashcards.forEach(card => {
                card.style.pointerEvents = 'auto';
                card.style.opacity = '1';
            });
        }

        // Iniciar verificación periódica
        function startPeriodicConnectivityCheck() {
            // Limpiar intervalo previo si existe
            if (connectivityCheckInterval) {
                clearInterval(connectivityCheckInterval);
            }

            // Verificar cada 15 segundos
            connectivityCheckInterval = setInterval(() => {
                // Solo verificar si no hay una verificación en progreso
                if (!connectivityCheckInProgress) {
                    checkInternetConnection();
                }
            }, 15000);

            console.log('⏰ Verificación periódica de conectividad iniciada (cada 15 segundos)');
        }

        // Detener verificación periódica
        function stopPeriodicConnectivityCheck() {
            if (connectivityCheckInterval) {
                clearInterval(connectivityCheckInterval);
                connectivityCheckInterval = null;
                console.log('⏹️ Verificación periódica de conectividad detenida');
            }
        }

        // Limpiar al salir de la página
        window.addEventListener('beforeunload', () => {
            stopPeriodicConnectivityCheck();
        });

        // === SISTEMA MEJORADO DE OCULTACIÓN DE CURSOR EN MÓVILES ===
        let keyboardState = {
            isVisible: false,
            lastHeight: window.innerHeight,
            detectionTimer: null,
            blurTimer: null
        };

        function isMobileDevice() {
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                (window.innerWidth <= 768 && 'ontouchstart' in window);
            return isMobile;
        }

        function setCursorState(visible, reason = '') {
            if (!isMobileDevice()) return;

            const body = document.body;
            const html = document.documentElement;

            // Limpiar todas las clases previas
            body.classList.remove('keyboard-visible', 'keyboard-hidden');
            html.classList.remove('keyboard-visible', 'keyboard-hidden');

            if (visible) {
                body.classList.add('keyboard-visible');
                html.classList.add('keyboard-visible');
                console.log('👁️ Cursor MOSTRADO:', reason);
            } else {
                body.classList.add('keyboard-hidden');
                html.classList.add('keyboard-hidden');
                console.log('🚫 Cursor OCULTO:', reason);

                // Forzar blur en todos los inputs para eliminar el cursor parpadeante
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                    activeElement.blur();
                }

                // Ocultar también el botón móvil "No sé" si está presente
                document.querySelectorAll('.mobile-skip-button').forEach(btn => {
                    btn.classList.remove('keyboard-visible');
                });
            }

            keyboardState.isVisible = visible;
        }

        function detectKeyboardByViewport() {
            if (!isMobileDevice()) return;

            const currentHeight = window.innerHeight;
            const heightDiff = keyboardState.lastHeight - currentHeight;

            console.log(`📏 Viewport: ${keyboardState.lastHeight} → ${currentHeight} (diff: ${heightDiff})`);

            // Teclado apareció (viewport se redujo significativamente)
            if (heightDiff > 120 && !keyboardState.isVisible) {
                setCursorState(true, `Viewport reducido ${heightDiff}px`);
            }
            // Teclado desapareció (viewport aumentó)
            else if (heightDiff < -50 && keyboardState.isVisible) {
                setCursorState(false, `Viewport aumentado ${Math.abs(heightDiff)}px`);
            }

            keyboardState.lastHeight = currentHeight;
        }

        function handleInputFocus(event) {
            if (!isMobileDevice()) return;

            console.log('🎯 INPUT FOCUS - Mostrando cursor inmediatamente');

            // Limpiar timer de blur previo
            if (keyboardState.blurTimer) {
                clearTimeout(keyboardState.blurTimer);
                keyboardState.blurTimer = null;
            }

            // Mostrar cursor inmediatamente
            setCursorState(true, 'Input enfocado');

            // Detectar teclado después de un delay
            if (keyboardState.detectionTimer) {
                clearTimeout(keyboardState.detectionTimer);
            }

            keyboardState.detectionTimer = setTimeout(() => {
                detectKeyboardByViewport();
            }, 300);
        }

        function handleInputBlur(event) {
            if (!isMobileDevice()) return;

            console.log('� INPUT BLUR - Preparando ocultar cursor');

            // Limpiar timer previo
            if (keyboardState.blurTimer) {
                clearTimeout(keyboardState.blurTimer);
            }

            // Esperar antes de ocultar por si hay otro input que toma el foco
            keyboardState.blurTimer = setTimeout(() => {
                const activeEl = document.activeElement;
                const hasActiveFocus = activeEl && (
                    activeEl.tagName === 'INPUT' ||
                    activeEl.tagName === 'TEXTAREA' ||
                    activeEl.contentEditable === 'true'
                );

                if (!hasActiveFocus) {
                    console.log('⏰ Timer blur - Ocultando cursor');
                    setCursorState(false, 'Sin inputs activos');
                } else {
                    console.log('⏰ Timer blur - Manteniendo cursor (otro input activo)');
                }
            }, 150);
        }

        function forceHideCursor() {
            if (!isMobileDevice()) return;

            console.log('🔨 FORZAR OCULTAR CURSOR');
            setCursorState(false, 'Forzado');

            // Forzar blur en todos los elementos
            document.querySelectorAll('input, textarea, [contenteditable]').forEach(el => {
                if (el === document.activeElement) {
                    el.blur();
                }
            });
        }

        function initCursorHiding() {
            if (!isMobileDevice()) {
                console.log('💻 Desktop - Cursor siempre visible');
                return;
            }

            console.log('📱 Móvil detectado - Inicializando ocultación de cursor');

            // Estado inicial: cursor oculto
            setCursorState(false, 'Estado inicial');

            // Eventos de focus/blur
            document.addEventListener('focusin', handleInputFocus, true);
            document.addEventListener('focusout', handleInputBlur, true);

            // Detectar cambios de viewport
            window.addEventListener('resize', () => {
                if (keyboardState.detectionTimer) {
                    clearTimeout(keyboardState.detectionTimer);
                }
                keyboardState.detectionTimer = setTimeout(() => {
                    detectKeyboardByViewport();
                    if (!keyboardState.isVisible) {
                        // Ocultar cualquier botón móvil "No sé"
                        document.querySelectorAll('.mobile-skip-button').forEach(btn => btn.classList.remove('keyboard-visible'));
                    }
                }, 100);
            });

            // Detectar cambios de orientación
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    keyboardState.lastHeight = window.innerHeight;
                    detectKeyboardByViewport();
                }, 600);
            });

            // Forzar ocultar cursor al hacer clic fuera de inputs
            document.addEventListener('touchstart', (e) => {
                const target = e.target;
                if (target && target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA' &&
                    target.contentEditable !== 'true') {
                    setTimeout(() => {
                        if (document.activeElement.tagName === 'BODY') {
                            forceHideCursor();
                        }
                    }, 100);
                }
            });

            // Observer para nuevos elementos de entrada
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) {
                            const inputs = node.querySelectorAll ? node.querySelectorAll('input, textarea, [contenteditable]') : [];
                            if (inputs.length > 0) {
                                console.log(`🆕 ${inputs.length} nuevos inputs detectados`);
                            }
                        }
                    });
                });
            });

            observer.observe(document.body, { childList: true, subtree: true });

            console.log('✅ Sistema de ocultación de cursor inicializado');
        }

        // Inicializar cuando esté listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initCursorHiding, 200);
            });
        } else {
            setTimeout(initCursorHiding, 200);
        }

        // También en load como respaldo
        window.addEventListener('load', () => {
            setTimeout(initCursorHiding, 100);
        });

        function debugGameState() {
            console.log('=== DEBUG GAME STATE ===');
            console.log('currentCardIndex:', currentCardIndex);
            console.log('Total flashcards:', flashcards.length);
            console.log('completedCards:', Array.from(completedCards));
            console.log('correctCount:', correctCount);
            console.log('incorrectCount:', incorrectCount);
            console.log('voiceAttempts:', voiceAttempts);
            console.log('========================');
        }

        // Modificar la función goToNextCard para añadir debug
        function goToNextCardWithDebug() {
            console.log('🔄 goToNextCard called');
            debugGameState();

            // Reactivar el botón de mezclar al pasar a la siguiente tarjeta
            document.getElementById('shuffle-button').disabled = false;

            // REPRODUCIR SONIDO DE NAIPE al cambiar de tarjeta
            document.getElementById('shuffleSound').play().catch(() => { });

            const flashcards = Array.from(document.querySelectorAll('.flashcard'));
            console.log('📊 Flashcards encontradas:', flashcards.length);

            completedCards.add(currentCardIndex);
            console.log('✅ Tarjeta marcada como completada:', currentCardIndex);
            console.log('📈 Total completadas:', completedCards.size);

            updateCardCounter();

            // GUARDAR PROGRESO AUTOMÁTICAMENTE al completar una tarjeta
            saveGameProgress();

            canFlipBack = true;
            canFlip = true;
            updateCounters();
            voiceAttempts = 0;

            // Limpiar timeouts
            if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
            if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }
            showingErrorMessage = false;
            lockedAfterSecondIncorrect = false;
            lockedAfterCorrect = false;

            // Buscar la siguiente tarjeta pendiente
            const total = flashcards.length;
            let nextIndex = -1;
            console.log('🔍 Buscando siguiente tarjeta...');

            for (let step = 1; step <= total; step++) {
                const i = (currentCardIndex + step) % total;
                console.log(`   Checking index ${i}, completed: ${completedCards.has(i)}`);
                if (!completedCards.has(i)) {
                    nextIndex = i;
                    console.log(`✨ Found next card at index: ${nextIndex}`);
                    break;
                }
            }

            if (nextIndex !== -1) {
                console.log('➡️ Moving to next card:', nextIndex);
                currentCardIndex = nextIndex;
                showCard(currentCardIndex);
            } else {
                console.log('🏁 No more cards - showing completion');
                // Resto del código de finalización...
                saveLastGamePercentage();

                if (correctCount > incorrectCount) {
                    if (incorrectCount === 0) {
                        showCompletionEuforiaMaxima();
                    } else {
                        showCompletioneuforia();
                    }
                } else if (incorrectCount > correctCount) {
                    showCompletionPerdida();
                } else {
                    showCompletionEmpate();
                }
            }

            console.log('🔄 goToNextCard finished');
        }
    </script>

    <!-- Teclado virtual global -->
    <div id="vk-overlay" class="virtual-keyboard-overlay">
        <div id="vk" class="virtual-keyboard">
            <div class="vk-row" data-row="1"></div>
            <div class="vk-row" data-row="2"></div>
            <div class="vk-row shifted" data-row="3"></div>
            <div class="vk-accents">
                <div class="row-accents">
                    <div class="vk-key warn" data-key="á">á</div>
                    <div class="vk-key warn" data-key="é">é</div>
                    <div class="vk-key warn" data-key="í">í</div>
                    <div class="vk-key warn" data-key="ó">ó</div>
                    <div class="vk-key warn" data-key="ú">ú</div>
                </div>
            </div>
            <div class="vk-footer">
                <div class="vk-controls">
                    <div class="vk-group" role="radiogroup" aria-label="Distribución del teclado">
                        <label class="vk-radio"><input type="radio" name="vk-layout"
                                value="qwerty"><span>QW</span></label>
                        <label class="vk-radio"><input type="radio" name="vk-layout"
                                value="azerty"><span>AZ</span></label>
                    </div>
                    <div class="vk-group" role="radiogroup" aria-label="Idioma del teclado">
                        <label class="vk-radio"><input type="radio" name="vk-lang" value="es"><span>Es</span></label>
                        <label class="vk-radio"><input type="radio" name="vk-lang" value="fr"><span>Fr</span></label>
                    </div>
                </div>
                <div class="vk-key space" data-key=" ">ESPACIO</div>
                <div class="vk-key hide small" data-key="hide" title="Ocultar teclado"><i
                        class="fas fa-chevron-down"></i></div>
            </div>
        </div>
    </div>
    </div>

</body>

</html>
