<!DOCTYPE html>
<html lang="es">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <title>Profesiones</title>
    <style>
        /* Estilos de la barra superior */
        .top-status-bar {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 6px auto 5px auto;
            gap: 2px;
            position: relative;
            z-index: 10;
        }

        .pill {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 1.0em;
            font-weight: 600;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            background: #fff;
            min-width: 60px;
            justify-content: center;
            letter-spacing: 0.3px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .back-arrow {
            background: #fff;
            color: #333;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            gap: 8px;
            border: 1px solid rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .back-arrow:hover {
            background-color: #f5f5f5;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .back-arrow i {
            color: #333;
        }        .pill-faltan {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(255,107,53,0.15);
            gap: 8px;
            border: none;
        }

        .pill-correctas {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(40, 167, 69, 0.15);
            gap: 8px;
            border: none;
        }

        .pill-incorrectas {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(220, 53, 69, 0.15);
            gap: 8px;
            border: none;
        }

        .pill-progreso {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(78,205,196,0.15);
            font-weight: 600;
            font-size: 1.0em;
            min-width: 60px;
            text-align: center;
            transition: all 0.3s ease;
            border: none;
        }

        .pill-progreso:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(78,205,196,0.2);
        }

        /* Estilos básicos */
        body, html {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #505255, #00020a);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            
            /* Eliminar cualquier selección en toda la página */
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-tap-highlight-color: transparent !important;
            -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
            -moz-tap-highlight-color: transparent !important;
        }
        
        /* Eliminar cualquier selección en todos los elementos */
        *, *::before, *::after {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-tap-highlight-color: transparent !important;
            -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
            -moz-tap-highlight-color: transparent !important;
            outline: none !important;
            -webkit-touch-callout: none !important;
            
            /* Prevenir menú contextual en todos los elementos */
            -webkit-context-menu: none !important;
            -moz-context-menu: none !important;
        }
        
        /* Reglas específicas para imágenes */
        img {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-drag: none !important;
            -moz-user-drag: none !important;
            pointer-events: none !important;
            
            /* Prevenir menú contextual específicamente en imágenes */
            -webkit-context-menu: none !important;
            -moz-context-menu: none !important;
        }
        
        /* Reglas específicas para elementos de texto */
        div, span, p, h1, h2, h3, h4, h5, h6 {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-highlight: none !important;
            -moz-highlight: none !important;
        }
        
        /* Eliminar el cursor de texto en elementos clickeables */
        .flashcard, .back, .front {
            cursor: pointer !important;
        }
        
        /* Sistema de ocultación de cursor para dispositivos móviles */
        @media (max-width: 768px) and (pointer: coarse) {
            /* Ocultar cursor por defecto en dispositivos táctiles */
            *, *::before, *::after {
                cursor: none !important;
                caret-color: transparent !important;
            }
            
            /* EXCEPCIÓN: permitir caret y cursor de texto en el campo de entrada */
            .type-input,
            .type-input:focus,
            .keyboard-visible .type-input {
                cursor: text !important;
                caret-color: auto !important;
                -webkit-user-select: text !important;
                -moz-user-select: text !important;
                -ms-user-select: text !important;
                user-select: text !important;
            }
            
            /* Ocultar cursor en otros elementos interactivos */
            button, .button, .pill, .flashcard, a, [onclick] {
                cursor: none !important;
            }
        }
        
        /* Clase para mostrar cursor cuando el teclado virtual está activo */
        .keyboard-visible *, 
        .keyboard-visible *::before, 
        .keyboard-visible *::after {
            cursor: default !important;
        }
        
        .keyboard-visible input, 
        .keyboard-visible textarea, 
        .keyboard-visible [contenteditable] {
            cursor: text !important;
            caret-color: auto !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }
        
        .keyboard-visible button, 
        .keyboard-visible .button, 
        .keyboard-visible .pill,
        .keyboard-visible .flashcard, 
        .keyboard-visible a, 
        .keyboard-visible [onclick] {
            cursor: pointer !important;
        }
        
        /* Forzar ocultación de cursor cuando no hay teclado */
        .keyboard-hidden *, 
        .keyboard-hidden *::before, 
        .keyboard-hidden *::after {
            cursor: none !important;
            caret-color: transparent !important;
        }
        
        .keyboard-hidden input, 
        .keyboard-hidden textarea, 
        .keyboard-hidden [contenteditable] {
            cursor: none !important;
            caret-color: transparent !important;
        }

        
        /* Prevenir selección con pseudo-elementos (excepto dentro del input de texto) */
        .back::selection, .back *::selection {
            background: transparent !important;
        }
        .back .type-input::selection { background: rgba(16,185,129,0.35) !important; }
        
        .back::-moz-selection, .back *::-moz-selection {
            background: transparent !important;
        }
        .back .type-input::-moz-selection { background: rgba(16,185,129,0.35) !important; }
        #flashcard-container-wrapper {
            position: relative;
            width: calc(100% - 20px);
            max-width: 600px;
        }
        #flashcard-container {
            width: 100%;
            height: 500px;
            max-height: 500px;
            perspective: 1000px; /* Para el efecto 3D */
            border-radius: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            position: relative;
            background: linear-gradient(to right, #1f3658, #3558e3);
            border: 3px solid #aab0b4;
            margin: 0;
        }
        .flashcard, .results-card {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.4, 0.2, 0.2, 1);
            border-radius: 15px;
            cursor: pointer;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            
            /* Prevenir selección de texto en toda la tarjeta */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .flashcard.is-visible { display: flex; }
        
        /* Parte frontal y trasera de la tarjeta */
        .front, .back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Oculta la cara trasera al girar */
            border-radius: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            
            /* Mantener eventos de clic en las caras de la tarjeta */
            pointer-events: auto !important;
        }
    
        .card-back {
            transform: rotateY(180deg); /* Gira la parte trasera */
        }
    
        /* Estilo de la parte frontal */
        .front img, .back img { 
            width: 100%; 
            height: 100%;
            
            /* Prevenir menú contextual y arrastrar en imágenes */
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-drag: none !important;
            -moz-user-drag: none !important;
            pointer-events: none !important;
        }
    
        /* Estilo de la parte trasera */
        .back {
    width: 100%;
    /* Fondo moderno con capas: gradientes radiales sutiles + base oscura para máxima legibilidad */
    background:
        radial-gradient(900px 700px at 10% 10%, rgba(99, 102, 241, 0.35), rgba(99, 102, 241, 0) 60%),
        radial-gradient(800px 600px at 90% 90%, rgba(16, 185, 129, 0.28), rgba(16, 185, 129, 0) 55%),
        linear-gradient(135deg, #0f172a 0%, #1e293b 55%, #0b1320 100%);
    color: #ffffff; /* Color del texto */
    transform: rotateY(180deg); /* Rotación para el efecto */
    padding: 20px; /* Margen interno */
    text-align: center; /* Centrado horizontal */
    font-size: 3rem; /* Tamaño del texto */
    font-family: 'Playfair Display', serif; /* Fuente elegante */
    border-radius: 10px; /* Bordes redondeados */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Sombra más pronunciada */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); /* Sombra del texto más fuerte */
    display: flex; /* Flexbox para el centrado */
    justify-content: center; /* Centrar horizontalmente */
    align-items: center; /* Centrar verticalmente */
    flex-direction: column; /* Asegura que el texto fluya en columnas */
    height: 100%; /* Usa toda la altura disponible */
    max-width: 100%; /* Limita el ancho máximo */
    margin: 0 auto; /* Centra dentro del contenedor */
    line-height: 1.4; /* Espaciado entre líneas */
    
    /* Prevenir selección de texto - Completo */
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
    -webkit-touch-callout: none !important;
    -webkit-tap-highlight-color: transparent !important;
    -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
    -moz-tap-highlight-color: transparent !important;
    outline: none !important;
    
    /* Prevenir arrastrar */
    -webkit-user-drag: none !important;
    -moz-user-drag: none !important;
    
    /* Eliminar cualquier outline o focus */
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    appearance: none !important;
}

        /* Ocultar texto cuando está en modo escucha */
        .back.hidden-text {
            color: transparent;
            text-shadow: none;
        }
        
        /* Asegurar que el indicador NUNCA se oculte ni herede color transparente */
        .back.hidden-text .super-pulse-indicator {
            color: #fff !important; /* Forzar color visible */
            -webkit-text-fill-color: #fff !important; /* Safari/iOS */
            opacity: 1 !important;
            display: block !important;
            visibility: visible !important;
        }
        /* Permitir que las letras usen su propio color aunque el contenedor fuerce el fill a blanco */
        .back.hidden-text .super-pulse-indicator .floating-emoji {
            -webkit-text-fill-color: currentColor !important; /* usa el color de .e1..e7 */
        }
        /* Asegurar que el emoji del micrófono no herede color transparente */
        .back.hidden-text .mic-emoji {
            color: #fff !important;
            -webkit-text-fill-color: #fff !important;
        }

        /* Indicador de escucha de voz */
        .listening-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 1.5rem;
            text-align: center;
            animation: pulse 1s infinite;
            z-index: 10;
        }

        @keyframes pulse {
            0% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
        }

        /* Contador moderno y elegante */
        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 25px;
        }

        .countdown-number {
            font-size: 8rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            animation: countdownPulse 1s ease-in-out;
            z-index: 1001;
        }

        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .countdown-circle {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: countdownRotate 1s linear;
        }

        @keyframes countdownRotate {
            0% { transform: rotate(0deg) scale(0.8); border-color: rgba(255, 255, 255, 0.3); }
            50% { transform: rotate(180deg) scale(1.1); border-color: rgba(255, 255, 255, 0.8); }
            100% { transform: rotate(360deg) scale(1); border-color: rgba(255, 255, 255, 0.5); }
        }

.back::before, .back::after {
    content: '';
    position: absolute;
    border-radius: 50%;
    filter: blur(20px);
    opacity: 0.35;
    z-index: 0; /* Colocar detrás del contenido */
}

/* Glow superior-izquierdo en tonos índigo */
.back::before {
    width: 65%;
    height: 65%;
    top: -18%;
    left: -18%;
    background: radial-gradient(circle at 40% 40%, rgba(99, 102, 241, 0.55) 0%, rgba(99, 102, 241, 0.15) 45%, rgba(99, 102, 241, 0) 70%);
}

/* Glow inferior-derecho en tonos esmeralda */
.back::after {
    width: 60%;
    height: 60%;
    bottom: -15%;
    right: -15%;
    background: radial-gradient(circle at 60% 60%, rgba(16, 185, 129, 0.5) 0%, rgba(16, 185, 129, 0.18) 40%, rgba(16, 185, 129, 0) 70%);
}

    
        /* El efecto de voltear */
        .flashcard.flipped {
            transform: rotateY(180deg); /* Al hacer clic, se voltea la tarjeta */
        }
    
/* Contenedor de botones */
.button-container {
    width: 100%;
    max-width: 370px;
    display: flex;
    justify-content: space-evenly; /* Espacio uniforme entre todos los botones */
    align-items: center;
    padding: 10px 0px;
    background-color: #ffffff;
    border-radius: 15px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    margin-top: 10px;
}



/* Botones individuales */
.button {
    padding: 10px 15px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 50px;
    background-color: #3498db;
    color: #fff;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}
     
        .button:hover { transform: translateY(-3px); }





.overlay-text {
    position: absolute;
    z-index: 1; /* Colocar por encima del contenido */
    color: white; /* Color del texto */
    font-size: 2rem; /* Tamaño del texto */
    font-weight: bold; /* Texto en negrita */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Sombra del texto */
    text-align: left; /* Alineación a la izquierda */
    pointer-events: none; /* No interferir con los clics */
    margin: 5%; /* Margen relativo */
    line-height: 1.5; /* Espaciado entre líneas */
    top: 40%; /* Posición específica desde arriba */
    left: 0%; /* Posición específica desde la izquierda */
}

/* Estilos para .overlay-text1 */
.overlay-text1 {
    position: absolute;
    top: 5px;
    z-index: 1;
    color: rgb(185, 232, 203); /* Color específico */
    font-size: 2rem; /* Tamaño del texto */
    font-weight: bold; /* Texto en negrita */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Sombra del texto */
    text-align: center; /* Centrado */
    pointer-events: none; /* No interferir con clics */
    display: inline-block; /* Comportamiento inline */
    animation: pulse 1.5s infinite; /* Animación pulsante */
}

/* Estilos para .overlay-text2 */
.overlay-text2 {
    position: absolute;
    z-index: 1;
    color: white; /* Color del texto */
    font-size: 2rem; /* Tamaño del texto */
    font-weight: bold; /* Negrita */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Sombra del texto */
    text-align: left; /* Alineación a la izquierda */
    pointer-events: none; /* No interferir con clics */
    margin: 30px; /* Márgenes específicos */
    top: 40%; /* Posición específica desde arriba */
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.1);
    opacity: 0.8;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes moveLeftToRight {
  0% {
    transform: translateX(0); /* Posición inicial */
  }
  50% {
    transform: translateX(10px); /* Mueve hacia la derecha */
  }
  100% {
    transform: translateX(0); /* Vuelve a la posición original */
  }
}



.back-arrow {
    background: #fff;
    color: #333;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    gap: 8px;
    border: 1px solid rgba(0,0,0,0.05);
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
}

.back-arrow:hover {
    background-color: #f5f5f5;
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.back-arrow i {
    color: #333;
}

.intentos-back {
    position: absolute;
    top: 18px;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 0.9rem;
    font-weight: bold;
    color: #f0e49c;
    z-index: 2;
    pointer-events: none;
}

.pill-intentos {
    background: linear-gradient(135deg, #ebac6d 0%, #a88f07 100%);
    color: #fff;
    box-shadow: 0 2px 6px rgba(255, 78, 80, 0.15);
    border-radius: 20px;
    padding: 2px 2px;
    font-size: 0.9em;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    border: none;
    margin-bottom: 4px;
}
.pill-intentos i {
    font-size: 0.9em;
}


@keyframes intentosFlash {
  0% { box-shadow: 0 0 0 0 #fff700, 0 2px 6px rgba(255, 78, 80, 0.15); }
  50% { box-shadow: 0 0 16px 8px #fff700, 0 2px 6px rgba(255, 78, 80, 0.15); }
  100% { box-shadow: 0 0 0 0 #fff700, 0 2px 6px rgba(255, 78, 80, 0.15); }
}
.pill-intentos.flash {
  animation: intentosFlash 0.7s;
}

/* --- NUEVO EFECTO DE ADVERTENCIA --- */
@keyframes intentosWarningFlash {
  0% { box-shadow: 0 0 0 0 #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15); }
  50% { box-shadow: 0 0 16px 8px #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15); }
  100% { box-shadow: 0 0 0 0 #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15); }
}
.pill-intentos.flash-warning {
  animation: intentosWarningFlash 0.7s;
}
.super-pulse-indicator {
    position: absolute !important; /* Dentro del lado back */
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    text-align: center;
    z-index: 9999 !important; /* Z-index muy alto para estar por encima de todo */
    width: auto;
    pointer-events: none; /* Para que no interfiera con los clics */
    display: block !important; /* Forzar visibilidad */
    opacity: 1 !important; /* Forzar opacidad */
    visibility: visible !important; /* Forzar visibilidad */
    /* Asegurar que el tamaño de las letras orbitantes herede desde aquí */
    --letter-size: 1.6rem;
}

.super-pulse-container {
    position: relative;
    width: 140px;   /* más espacio para una órbita segura */
    height: 140px;  /* más espacio para una órbita segura */
    margin: 0 auto 30px; /* separar de mensajes inferiores */
    /* Variables para controlar una órbita estable (tipo luna-tierra) */
    --center-size: 70px;           /* Tamaño del círculo blanco (pulse-center) */
    --center-scale-max: 1.1;       /* Escala máxima por animación centerBounce */
    --letter-size: 1.5rem;         /* Igual que .floating-emoji font-size para cálculo preciso */
    --safety-gap: 16px;            /* Más separación para asegurar que no invada el círculo */
    /* Radio real de la órbita: mitad del centro (con su escala máxima) + semi ancho de letra + gap */
    --orbit-radius: calc((var(--center-size) * var(--center-scale-max) / 2) + (var(--letter-size) / 2) + var(--safety-gap));
}

.pulse-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    border: 3px solid rgba(255, 255, 255, 0.8);
}

.pulse-ring-1 {
    width: 60px;
    height: 60px;
    animation: superPulseRing 2s infinite ease-out;
    border-color: rgba(255, 215, 0, 0.9);
}

.pulse-ring-2 {
    width: 80px;
    height: 80px;
    animation: superPulseRing 2s infinite ease-out;
    animation-delay: 0.5s;
    border-color: rgba(0, 255, 127, 0.7);
}

.pulse-ring-3 {
    width: 100px;
    height: 100px;
    animation: superPulseRing 2s infinite ease-out;
    animation-delay: 1s;
    border-color: rgba(255, 69, 0, 0.6);
}

.pulse-ring-4 {
    width: 120px;
    height: 120px;
    animation: superPulseRing 2s infinite ease-out;
    animation-delay: 1.5s;
    border-color: rgba(138, 43, 226, 0.5);
}

@keyframes superPulseRing {
    0% {
        transform: translate(-50%, -50%) scale(0.3);
        opacity: 1;
        border-width: 4px;
    }
    50% {
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0.8;
        border-width: 2px;
    }
    100% {
        transform: translate(-50%, -50%) scale(1.5);
        opacity: 0;
        border-width: 1px;
    }
}

.pulse-center {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #f8fafc 0%, #e0e7ef 100%);
    background-size: 400% 400%;
    animation: centerGradient 3s ease infinite, centerBounce 1.5s ease-in-out infinite;
    border-radius: 50%;
    width: 70px;
    height: 70px;
    z-index: 10; /* Asegura que el mic y el centro estén por encima de la órbita */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 20px rgba(120, 180, 255, 0.25);
}

@keyframes centerGradient {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

@keyframes centerBounce {
    0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    50% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
}

.mic-emoji {
    font-size: 2rem;
    margin-bottom: 0.5px;
    margin-top: 0;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
    animation: micWiggle 2s ease-in-out infinite;
    display: flex;
    align-items: center;
    justify-content: center;
}

@keyframes micWiggle {
    0%, 100% { transform: rotate(-3deg); }
    50% { transform: rotate(3deg); }
}

.sound-waves {
    display: flex;
    gap: 6px;
    margin-top: 0;
    margin-bottom: 0;
    justify-content: center;
    align-items: center;
}

.wave-dot {
    width: 4px;
    height: 4px;
    background: #e0c605;
    border-radius: 50%;
    animation: waveUp 1s ease-in-out infinite;
    box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
}

.wave-dot:nth-child(1) { animation-delay: 0s; }
.wave-dot:nth-child(2) { animation-delay: 0.2s; }
.wave-dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes waveUp {
    0%, 100% { transform: translateY(0px) scale(1); opacity: 0.7; }
    50% { transform: translateY(-8px) scale(1.3); opacity: 1; }
}

.floating-emojis {
    position: absolute;
    inset: 0;
    pointer-events: none;
    /* El radio de la órbita se calcula para NO entrar en el círculo central en ningún momento */
    --radius: var(--orbit-radius);
    transform-origin: 50% 50%;
    /* NO hay animación aquí - cada letra orbita individualmente */
    z-index: 4; /* por debajo del centro para no tapar el micrófono */
}

.floating-emoji {
    position: absolute;
    top: 50%;
    left: 50%;
    font-size: var(--letter-size, 1.5rem) !important; /* vinculado a variable + prioridad para evitar sobrescrituras */
    opacity: 0.9;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    transform-origin: 50% 50%; /* rota desde el centro del contenedor */
    -webkit-text-fill-color: currentColor !important; /* asegurar que el color de texto real sea el propio */
    /* Cada letra orbita individualmente para mantener el centro fijo */
    animation: letterOrbit 24s linear infinite;
    pointer-events: none;
}

/* Refuerzo de especificidad para asegurar que el tamaño cambie en contexto del indicador */
.super-pulse-indicator .floating-emoji {
    font-size: var(--letter-size, 1.5rem) !important;
}
 
/* Distribución equidistante de E-S-P-A-Ñ-O-L (360/7 ≈ 51.4286°) */
/* Colores elegantes desde el primer intento */
.e1 { color: #8B5CF6 !important; font-weight: 700; animation-delay: -6s; text-shadow: 0 0 8px rgba(139, 92, 246, 0.4); }     /* E - Púrpura elegante */
.e2 { color: #06B6D4 !important; font-weight: 700; animation-delay: -9.43s; text-shadow: 0 0 8px rgba(6, 182, 212, 0.4); }  /* S - Cian vibrante */
.e3 { color: #F59E0B !important; font-weight: 700; animation-delay: -12.86s; text-shadow: 0 0 8px rgba(245, 158, 11, 0.4); } /* P - Ámbar dorado */
.e4 { color: #EF4444 !important; font-weight: 700; animation-delay: -16.29s; text-shadow: 0 0 8px rgba(239, 68, 68, 0.4); } /* A - Rojo coral */
.e5 { color: #10B981 !important; font-weight: 700; animation-delay: -19.71s; text-shadow: 0 0 8px rgba(16, 185, 129, 0.4); } /* Ñ - Esmeralda */
.e6 { color: #3B82F6 !important; font-weight: 700; animation-delay: -23.14s; text-shadow: 0 0 8px rgba(59, 130, 246, 0.4); } /* O - Azul real */
.e7 { color: #EC4899 !important; font-weight: 700; animation-delay: -2.57s; text-shadow: 0 0 8px rgba(236, 72, 153, 0.4); }  /* L - Rosa magenta */

/* Se eliminan bailes individuales para que todos giren en la misma órbita */

/* Órbita individual de cada letra manteniendo el centro fijo */
@keyframes letterOrbit {
    0%   { transform: translate(-50%, -50%) rotate(0deg) translateX(var(--radius)) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg) translateX(var(--radius)) rotate(-360deg); }
}

/* Animación anterior mantenida por compatibilidad */
@keyframes slowOrbit {
    0%   { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes floatAround {
    0%, 100% { 
        transform: translateY(0px) translateX(0px) rotate(0deg) scale(1); 
        opacity: 0.6;
    }
    25% { 
        transform: translateY(-15px) translateX(10px) rotate(90deg) scale(1.2); 
        opacity: 1;
    }
    50% { 
        transform: translateY(-10px) translateX(-5px) rotate(180deg) scale(0.9); 
        opacity: 0.8;
    }
    75% { 
        transform: translateY(-20px) translateX(15px) rotate(270deg) scale(1.1); 
        opacity: 1;
    }
}

@keyframes floatAroundE3 {
    0%, 100% {
        transform: translateY(0px) translateX(0px) rotate(0deg) scale(1);
        opacity: 0.7;
    }
    25% {
        transform: translateY(-1px) translateX(20px) rotate(20deg) scale(1.1);
        opacity: 1;
    }
    50% {
        transform: translateY(1px) translateX(15px) rotate(40deg) scale(1.05);
        opacity: 0.9;
    }
    75% {
        transform: translateY(0px) translateX(-10px) rotate(10deg) scale(1.1);
        opacity: 1;
    }
}

.super-pulse-text {
    color: #fff;
    font-size: 1.4rem;
    font-weight: bold;
    margin-bottom: 8px;
    text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 2px 4px rgba(0,0,0,0.5);
    animation: textGlow 2s ease-in-out infinite;
}

@keyframes textGlow {
    0%, 100% { 
        text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 2px 4px rgba(0,0,0,0.5);
        transform: scale(1);
    }
    50% { 
        text-shadow: 0 0 20px rgba(255,215,0,1), 0 0 30px rgba(255,215,0,0.8), 0 2px 4px rgba(0,0,0,0.5);
        transform: scale(1.02);
    }
}

.super-pulse-subtitle {
    color: #ffeb3b;
    font-size: 1.1rem;
    font-weight: 600;
    animation: subtitleSlide 4s ease-in-out infinite;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

.super-pulse-subtitle {
    color: #ffeb3b;
    font-size: 1.05rem;
    font-weight: 600; /* mismo peso visual que el segundo intento */
    animation: subtitleSlide 4s ease-in-out infinite;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    margin-top: 6px;
}

/* Forzar que el subtítulo mantenga su color amarillo en cualquier intento */
.super-pulse-indicator .super-pulse-subtitle {
    color: #ffeb3b !important;
    -webkit-text-fill-color: #ffeb3b !important; /* Safari/iOS */
}

/* Si el back está en hidden-text, mantener el color del subtítulo */
.back.hidden-text .super-pulse-indicator .super-pulse-subtitle {
    color: #ffeb3b !important;
    -webkit-text-fill-color: #ffeb3b !important;
}

@keyframes subtitleSlide {
    0%, 100% { 
        transform: translateX(0px); 
        opacity: 0.8; 
    }
    25% { 
        transform: translateX(5px); 
        opacity: 1; 
    }
    50% { 
        transform: translateX(-5px); 
        opacity: 0.9; 
    }
    75% { 
        transform: translateX(3px); 
        opacity: 1; 
    }
}

.back .super-pulse-indicator {
    position: absolute !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    z-index: 999 !important;
    width: auto !important;
    height: auto !important;
}

.super-pulse-container {
    position: relative;
    width: 120px;
    height: 120px;
    margin: 0 auto 25px;
    z-index: 1000;
}

/* Añade esto en tu sección de estilos */
@keyframes fadeInOut {
    0% { 
        opacity: 0;
        transform: scale(0.8) translateY(20px);
    }
    20% { 
        opacity: 1;
        transform: scale(1.1) translateY(0);
    }
    80% { 
        opacity: 1;
        transform: scale(1) translateY(0);
    }
    100% { 
        opacity: 0;
        transform: scale(0.8) translateY(-20px);
    }
}

@keyframes modernFadeInOut {
    0% { 
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
        filter: blur(2px);
    }
    15% { 
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.05);
        filter: blur(0px);
    }
    85% { 
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        filter: blur(0px);
    }
    100% { 
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
        filter: blur(1px);
    }
}

.mensaje-error {
    position: absolute;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    font-size: 2rem;
    font-weight: bold;
    color: #ff6b6b;
    text-align: center;
    text-shadow: 0 0 10px rgba(255, 107, 107, 0.5),
                 0 0 20px rgba(255, 107, 107, 0.3),
                 0 0 30px rgba(255, 107, 107, 0.2);
    z-index: 1000;
    background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 107, 107, 0.05) 100%);
    padding: 20px 40px;
    border-radius: 15px;
    backdrop-filter: blur(5px);
    border: 2px solid rgba(255, 107, 107, 0.2);
    animation: errorAppearNew 0.5s ease-out, errorDisappearNew 0.5s ease-in 1.5s forwards;
}

@keyframes errorAppearNew {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) perspective(500px) rotateX(-45deg);
        filter: brightness(2);
    }
    50% {
        transform: translate(-50%, -50%) perspective(500px) rotateX(5deg);
        filter: brightness(1.5);
    }
    100% {
        opacity: 1;
        transform: translate(-50%, -50%) perspective(500px) rotateX(0);
        filter: brightness(1);
    }
}

@keyframes errorDisappearNew {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        filter: brightness(1);
    }
    50% {
        transform: translate(-50%, -50%) scale(1.1);
        filter: brightness(1.2);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
        filter: brightness(0);
    }
}

@keyframes respuestaGlow {
    0%, 100% { 
        text-shadow: 0 0 10px rgba(255,255,255,0.5),
                     0 0 20px rgba(255,255,255,0.3);
        transform: scale(1);
    }
    50% { 
        text-shadow: 0 0 15px rgba(255,255,255,0.8),
                     0 0 25px rgba(255,255,255,0.5),
                     0 0 35px rgba(255,255,255,0.3);
        transform: scale(1.05);
    }
}

        .button:hover { transform: translateY(-3px); }

        .button:disabled {
            background-color: #bdc3c7;
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

.overlay-text {
    position: absolute;
    }

    @keyframes errorGlow {
  0% {
    box-shadow: 0 0 0 0 #ff3b3b, 0 2px 6px rgba(220,53,69,0.15);
    background: linear-gradient(135deg, #ff3b3b 0%, #c82333 100%);
    transform: scale(1);
  }
  50% {
    box-shadow: 0 0 24px 12px #ff3b3b, 0 2px 16px rgba(220,53,69,0.25);
    background: linear-gradient(135deg, #ff3b3b 40%, #ffb3b3 100%);
    transform: scale(1.08);
  }
  100% {
    box-shadow: 0 0 0 0 #ff3b3b, 0 2px 6px rgba(220,53,69,0.15);
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    transform: scale(1);
  }
}
.pill-incorrectas.glow-error {
  animation: errorGlow 0.7s;
}

@keyframes correctGlow {
  0% {
    box-shadow: 0 0 0 0 #00e676, 0 2px 6px rgba(40,167,69,0.15);
    background: linear-gradient(135deg, #00e676 0%, #218838 100%);
    transform: scale(1);
  }
  50% {
    box-shadow: 0 0 24px 12px #00e676, 0 2px 16px rgba(40,167,69,0.25);
    background: linear-gradient(135deg, #00e676 40%, #b9f6ca 100%);
    transform: scale(1.08);
  }
  100% {
    box-shadow: 0 0 0 0 #00e676, 0 2px 6px rgba(40,167,69,0.15);
    background: linear-gradient(135deg, #28a745 0%, #218838 100%);
    transform: scale(1);
  }
}
.pill-correctas.glow-correct {
  animation: correctGlow 0.7s;
}

@keyframes faltanGlow {
  0% {
    box-shadow: 0 0 0 0 #ffb347, 0 2px 6px rgba(255,107,53,0.15);
    background: linear-gradient(135deg, #ffb347 0%, #f7931e 100%);
    transform: scale(1);
  }
  50% {
    box-shadow: 0 0 24px 12px #ffb347, 0 2px 16px rgba(255,107,53,0.25);
    background: linear-gradient(135deg, #ffb347 40%, #fff3cd 100%);
    transform: scale(1.08);
  }
  100% {
    box-shadow: 0 0 0 0 #ffb347, 0 2px 6px rgba(255,107,53,0.15);
    background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
    transform: scale(1);
  }
}
.pill-faltan.glow-faltan {
  animation: faltanGlow 0.7s;
}

.flashcard.transition-out {
    animation: cardSlideUp 0.5s forwards;
    z-index: 2;
}
.flashcard.transition-in {
    animation: cardSlideIn 0.5s forwards;
    z-index: 3;
}
@keyframes cardSlideUp {
    0% { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(-120%) scale(0.95); opacity: 0; }
}
@keyframes cardSlideIn {
    0% { transform: translateY(120%) scale(0.95); opacity: 0; }
    100% { transform: translateY(0) scale(1); opacity: 1; }
}

.countdown-inline {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 300px;
    animation: fadeInOut 4s;
    z-index: 1;
    position: relative;
}

.countdown-inline-circle {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    background: linear-gradient(135deg, #4ecdc4 0%, #3558e3 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 8px;
    box-shadow: 0 4px 16px rgba(78,205,196,0.18);
    border: 3px solid #fff;
}

.countdown-inline-number {
    font-size: 2.5rem;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 2px 8px rgba(0,0,0,0.18);
    letter-spacing: 1px;
}

.countdown-inline-text {
    font-size: 1.1rem;
    color: #e0e7ef;
    margin-top: 2px;
    font-weight: 500;
    text-shadow: 0 1px 3px rgba(0,0,0,0.12);
}

.pulse-timer {
    animation: pulse 1s;
}

.flashcard.transition-out {
    animation: cardSlideLeft 0.5s forwards;
    z-index: 2;
}
.flashcard.transition-in {
    animation: cardSlideFromRight 0.5s forwards;
    z-index: 3;
}
@keyframes cardSlideLeft {
    0% { transform: translateX(0) scale(1); opacity: 1; }
    100% { transform: translateX(-120%) scale(0.95); opacity: 0; }
}
@keyframes cardSlideFromRight {
    0% { transform: translateX(120%) scale(0.95); opacity: 0; }
    100% { transform: translateX(0) scale(1); opacity: 1; }
}

@keyframes bounce {
    0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
    }
    40% {
        transform: translateY(-20px);
    }
    60% {
        transform: translateY(-10px);
    }
}

/* === ANIMACIONES DE EUFORIA (Alegres y eufóricas) === */
/* Nueva animación eufórica simplificada */
@keyframes euforicaPop {
    0% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(20px) scale(0.3); 
        background: linear-gradient(135deg, #ff9ff3, #f368e0);
    }
    20% { 
        opacity: 1;
        transform: translateX(-50%) translateY(-10px) scale(1.15); 
        background: linear-gradient(135deg, #54a0ff, #5f27cd);
    }
    40% {
        transform: translateX(-50%) translateY(0px) scale(1.05);
        background: linear-gradient(135deg, #00d2d3, #01a3a4);
    }
    60% {
        transform: translateX(-50%) translateY(-5px) scale(1.02);
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
    }
    100% { 
        opacity: 1; 
        transform: translateX(-50%) translateY(0px) scale(1); 
        background: linear-gradient(135deg, #05c46b, #0be881);
    }
}

/* Animación para respuesta incorrecta */
@keyframes errorShake {
    0% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(10px) scale(0.5); 
    }
    20% { 
        opacity: 1;
        transform: translateX(-60%) translateY(0px) scale(1.1); 
    }
    40% {
        transform: translateX(-40%) translateY(0px) scale(1.05);
    }
    60% {
        transform: translateX(-55%) translateY(0px) scale(1.02);
    }
    80% {
        transform: translateX(-45%) translateY(0px) scale(1.01);
    }
    100% { 
        opacity: 1; 
        transform: translateX(-50%) translateY(0px) scale(1); 
    }
}

/* Animación triste para respuesta correcta después de dos intentos fallidos */
@keyframes tristeSlowFade {
    0% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(30px) scale(0.7); 
        background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
    }
    40% { 
        opacity: 0.5;
        transform: translateX(-50%) translateY(15px) scale(0.85); 
        background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
    }
    70% {
        opacity: 0.8;
        transform: translateX(-50%) translateY(5px) scale(0.95);
        background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
    }
    100% { 
        opacity: 1; 
        transform: translateX(-50%) translateY(0px) scale(1); 
        background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
    }
}

@keyframes celebrationBounce {
    0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0) scale(1); }
    10% { transform: translateX(-50%) translateY(-20px) scale(1.1); }
    30% { transform: translateX(-50%) translateY(-10px) scale(1.05); }
    60% { transform: translateX(-50%) translateY(-15px) scale(1.08); }
    90% { transform: translateX(-50%) translateY(-5px) scale(1.02); }
}

@keyframes euforiaWiggle {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(5deg) scale(1.05); }
    50% { transform: rotate(0deg) scale(1.1); }
    75% { transform: rotate(-5deg) scale(1.05); }
}

@keyframes happyFloat {
    0%, 100% { transform: translateY(0px) scale(1); opacity: 0.9; }
    50% { transform: translateY(-15px) scale(1.02); opacity: 1; }
}

@keyframes sparkle {
    0%, 100% { opacity: 0.8; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.05); }
}

/* === ANIMACIONES DE PÉRDIDA (Tristes y desanimadas) === */
@keyframes sadFadeIn {
    0% { 
        opacity: 0; 
        transform: scale(1.2); 
        filter: brightness(0.3);
    }
    100% { 
        opacity: 1; 
        transform: scale(1); 
        filter: brightness(1);
    }
}

@keyframes sadDrop {
    0% { transform: translateY(0px) rotate(0deg); }
    20% { transform: translateY(10px) rotate(-2deg); }
    40% { transform: translateY(5px) rotate(1deg); }
    60% { transform: translateY(8px) rotate(-1deg); }
    80% { transform: translateY(3px) rotate(0.5deg); }
    100% { transform: translateY(0px) rotate(0deg); }
}

@keyframes disappointedSway {
    0%, 100% { transform: rotate(0deg) translateX(0px); }
    33% { transform: rotate(-2deg) translateX(-5px); }
    66% { transform: rotate(2deg) translateX(5px); }
}

@keyframes gentleFloat {
    0%, 100% { transform: translateY(0px); opacity: 0.9; }
    50% { transform: translateY(-8px); opacity: 0.7; }
}

@keyframes fadingHope {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 0.5; }
}

/* === ANIMACIONES DE EMPATE (Neutrales y equilibradas) === */
@keyframes neutralZoom {
    0% { 
        opacity: 0; 
        transform: scale(0.8); 
    }
    50% { 
        transform: scale(1.05); 
    }
    100% { 
        opacity: 1; 
        transform: scale(1); 
    }
}

@keyframes balanceSway {
    0%, 100% { transform: rotate(-8deg); }
    50% { transform: rotate(8deg); }
}

@keyframes steadyPulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.03); opacity: 0.95; }
}

@keyframes calmWave {
    0%, 100% { transform: translateY(0px) translateX(0px); }
    33% { transform: translateY(-5px) translateX(3px); }
    66% { transform: translateY(0px) translateX(-3px); }
}

@keyframes steadyGlow {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
}

/* === ANIMACIONES DE EUFORIA MÁXIMA (Perfecto) === */
@keyframes rainbowBackground {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

@keyframes perfectEntrance {
    0% { 
        opacity: 0; 
        transform: scale(0.1) rotate(720deg); 
        filter: brightness(3);
    }
    50% { 
        transform: scale(1.3) rotate(360deg); 
        filter: brightness(2);
    }
    100% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg); 
        filter: brightness(1);
    }
}

@keyframes perfectExplosion {
    0%, 100% { 
        transform: translateY(0) rotate(0deg) scale(1); 
        filter: drop-shadow(0 0 20px gold);
    }
    25% { 
        transform: translateY(-40px) rotate(90deg) scale(1.4); 
        filter: drop-shadow(0 0 40px gold);
    }
    50% { 
        transform: translateY(-20px) rotate(180deg) scale(1.2); 
        filter: drop-shadow(0 0 60px gold);
    }
    75% { 
        transform: translateY(-30px) rotate(270deg) scale(1.3); 
        filter: drop-shadow(0 0 40px gold);
    }
}

@keyframes perfectShine {
    0%, 100% { 
        text-shadow: 0 0 20px rgba(255,255,255,1), 0 0 40px gold, 0 0 60px gold;
        transform: scale(1);
    }
    50% { 
        text-shadow: 0 0 30px rgba(255,255,255,1), 0 0 60px gold, 0 0 80px gold, 0 0 100px gold;
        transform: scale(1.1);
    }
}

@keyframes goldenGlow {
    0%, 100% { 
        transform: translateY(0px) scale(1); 
        opacity: 0.95; 
        color: #FFD700;
    }
    50% { 
        transform: translateY(-10px) scale(1.05); 
        opacity: 1; 
        color: #FFA500;
    }
}

@keyframes diamondSpark {
    0%, 100% { 
        opacity: 0.9; 
        transform: scale(1) rotate(0deg);
        color: #E6E6FA;
    }
    25% { 
        opacity: 1; 
        transform: scale(1.1) rotate(5deg);
        color: #FFD700;
    }
    50% { 
        opacity: 1; 
        transform: scale(1.05) rotate(-5deg);
        color: #FF69B4;
    }
    75% { 
        opacity: 1; 
        transform: scale(1.1) rotate(3deg);
        color: #00CED1;
    }
}

/* Animación alternante para botones */
@keyframes alternatePulse {
    0%, 50% {
        transform: scale(1);
        box-shadow: 0 4px 15px rgba(0,200,81,0.2);
    }
    25% {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0,200,81,0.4);
    }
}

@keyframes alternatePulseIncorrect {
    0%, 50% {
        transform: scale(1);
        box-shadow: 0 4px 15px rgba(255,87,34,0.2);
    }
    75% {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(255,87,34,0.4);
    }
}

/* === ESTILOS PARA MODALES MODERNOS DE PALABRAS === */
@keyframes fadeInOverlay {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes expandToFullscreen {
    from { 
        width: 400px;
        height: 500px;
        border-radius: 25px;
    }
    to { 
        width: 100vw;
        height: 100vh;
        border-radius: 0;
    }
}

@keyframes slideInModal {
    from { 
        transform: translateY(-30px) scale(0.95);
        opacity: 0;
    }
    to { 
        transform: translateY(0) scale(1);
        opacity: 1;
    }
}

@keyframes wordCardFadeIn {
    from { 
        transform: translateY(10px);
        opacity: 0;
    }
    to { 
        transform: translateY(0);
        opacity: 1;
    }
}

.modal-container {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(20px);
    border-radius: 24px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    max-width: 500px;
    width: 90%;
    max-height: 85vh;
    overflow: hidden;
    animation: slideInModal 0.4s ease-out;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.modal-header {
    padding: 30px 30px 20px;
    text-align: center;
    position: relative;
}

.modal-title-row {
    margin-bottom: 8px;
}

.modal-title {
    font-size: 1.8rem;
    font-weight: 700;
    margin: 0;
    color: #1f2937;
    letter-spacing: -0.5px;
    text-decoration: underline;
    text-decoration-thickness: 2px;
    text-underline-offset: 4px;
}

.correct-modal .modal-title {
    text-decoration-color: #10b981;
}

.incorrect-modal .modal-title {
    text-decoration-color: #ef4444;
}

.modal-stats {
    font-size: 0.95rem;
    color: #6b7280;
    font-weight: 500;
}

.modal-content {
    padding: 0 30px 20px;
    max-height: 50vh;
    overflow-y: auto;
}

.words-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
}

.word-card {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 12px;
    padding: 16px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border: 1px solid rgba(0, 0, 0, 0.05);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    transition: all 0.2s ease;
    animation: wordCardFadeIn 0.3s ease-out;
    animation-fill-mode: both;
}

.word-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.correct-word {
    border-left: 4px solid #10b981;
}

.incorrect-word {
    border-left: 4px solid #ef4444;
}

.word-text {
    font-size: 1.1rem;
    font-weight: 600;
    color: #374151;
    flex: 1;
}

.word-checkmark {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.9rem;
    margin-left: 12px;
}

.correct-word .word-checkmark {
    background: #10b981;
    color: white;
}

.incorrect-word .word-checkmark {
    background: #ef4444;
    color: white;
}

.no-words-message {
    text-align: center;
    padding: 40px 20px;
    color: #6b7280;
}

.no-words-icon {
    font-size: 3rem;
    display: block;
    margin-bottom: 16px;
}

.no-words-message p {
    font-size: 1.1rem;
    font-weight: 500;
    margin: 0;
}

.modal-footer {
    padding: 20px 30px 30px;
    text-align: center;
}

.modal-close-btn {
    background: linear-gradient(135deg, #6366f1, #4f46e5);
    border: none;
    color: white;
    padding: 14px 32px;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    min-width: 120px;
}

.modal-close-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(99, 102, 241, 0.4);
}

.modal-close-btn:active {
    transform: translateY(0);
}

.correct-btn {
    background: linear-gradient(135deg, #10b981, #059669);
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
}

.correct-btn:hover {
    box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
}

.incorrect-btn {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
}

.incorrect-btn:hover {
    box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
}

/* === DIALOGO DE ESCRITURA EN BACK === */
.type-dialog-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 78%;
    max-width: 410px;
    background: rgba(255, 255, 255, 0.12);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.25);
    border-radius: 16px;
    padding: 5px 16px 5px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    z-index: 1000;
    /* Centra los elementos inline como los botones sin contenedor */
    text-align: center;
    /* Evita espacio extra entre líneas de elementos inline (botones) */
    line-height: 0;
}

/* Restablecer line-height en bloques internos para no afectar su texto */
.type-dialog-container .type-input-row,
.type-dialog-container .check-button-row,
.type-dialog-container .type-message,
.type-dialog-container .type-word-title { 
    line-height: normal; 
}

.type-message {
    position: absolute;
    top: -56px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 16px;
    border-radius: 12px;
    font-weight: 800;
    letter-spacing: .5px;
    white-space: nowrap;
    z-index: 5;
}

.type-message.success {
    color: #fff;
    background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
    animation: euforiaEntrance .6s ease-out, celebrationBounce 1.8s ease-in-out 1;
    box-shadow: 0 0 20px rgba(255,255,255,.4), 0 0 40px rgba(255,0,128,.25);
}

.type-message.error {
    color: #ff6b6b;
    background: rgba(255,255,255,0.12);
    border: 2px solid rgba(255,107,107,0.45);
    animation: errorAppearNew .4s ease-out;
    text-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
}

/* Título visible con la palabra objetivo (se muestra solo al acertar) */
.type-word-title {
    position: absolute;
    top: -12px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    padding: 10px 16px;
    border-radius: 14px;
    font-size: 1.8rem;
    font-weight: 900;
    color: #fff;
    background: linear-gradient(135deg, #12c2e9, #c471ed, #f64f59);
    box-shadow: 0 10px 30px rgba(0,0,0,0.15), 0 0 20px rgba(255,255,255,.22);
    letter-spacing: .5px;
    text-align: center;
    pointer-events: none;
    white-space: nowrap;
}
/* Animación eufórica simplificada */
.type-word-title.success {
    animation: euforicaPop 1.2s ease-out;
    box-shadow: 0 0 20px rgba(255,255,255,.4), 0 0 40px rgba(255,0,128,.25);
}

/* Estilo para respuesta incorrecta */
.type-word-title.error-response {
    background: linear-gradient(135deg, #ff6b6b, #ee5a24);
    color: #fff;
    animation: errorShake 0.6s ease-out;
    box-shadow: 0 0 20px rgba(255,107,107,.4), 0 0 30px rgba(238,90,36,.25);
}

/* Estilo para respuesta correcta después de dos intentos fallidos */
.type-word-title.sad-correct {
    animation: tristeSlowFade 1.2s ease-out;
    box-shadow: 0 0 20px rgba(255,255,255,.4), 0 0 40px rgba(255,0,128,.25);
}

.type-input-row {
    display: flex;
    width: 100%;
    margin-bottom: 4px; /* un poquito arriba respecto a los botones */
}

.special-chars {
    /* Ya no se usa: los botones se insertan sin contenedor */
    display: none !important;
}

.check-button-row {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    margin-top: 8px; /* 2px exactos respecto a los botones */
}

.char-btn {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
    border: 1px solid rgba(255, 255, 255, 0.25);
    border-radius: 12px;
    color: #fff;
    font-size: 1.1rem;
    font-weight: 600;
    padding: 10px 14px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    min-width: 44px;
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    /* Sin contenedor: hacerlos inline y espaciados */
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin: 0 6px 0; /* sin margen vertical: el gap superior lo da .type-input-row y abajo lo controla .check-button-row */
    vertical-align: top; /* Evita gaps por alineación de baseline */
    line-height: 1; /* Asegura altura correcta del contenido del botón */
}

/* Asegurar que el primer botón tras la fila del input no tenga margen superior */
.type-input-row + .char-btn { margin-top: 0; }

.char-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s ease;
}

.char-btn:hover {
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(6, 182, 212, 0.25));
    border-color: rgba(16, 185, 129, 0.6);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 6px 20px rgba(16, 185, 129, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1);
    color: #ffffff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.char-btn:hover::before {
    left: 100%;
}

.char-btn:active {
    transform: translateY(-1px) scale(1.02);
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.4), rgba(6, 182, 212, 0.35));
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3), inset 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.1s ease;
}

.char-btn:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3), 0 6px 20px rgba(16, 185, 129, 0.15);
}

/* Mostrar los botones de caracteres solo en PC */
@media (max-width: 1024px), (pointer: coarse) {
    .char-btn { display: none !important; }
}

.type-input {
    flex: 1;
    font-size: 1.35rem;
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.35);
    background: rgba(0,0,0,0.25);
    color: #fff;
    outline: none;
    /* Permitir selección y edición precisa aunque haya reglas globales que la bloqueen */
    -webkit-user-select: text !important;
    -moz-user-select: text !important;
    -ms-user-select: text !important;
    user-select: text !important;
    caret-color: auto !important;
}

.type-input[readonly] {
    cursor: text; /* Opcional: mantiene el cursor de texto para indicar que es un campo de entrada */
}

.type-input::placeholder {
    color: rgba(255,255,255,0.7);
}

/* Ocultar placeholder cuando el input tiene foco (mostrar solo el caret) */
.type-input:focus::placeholder { color: transparent; opacity: 0; }
.type-input:focus::-webkit-input-placeholder { color: transparent; opacity: 0; }
.type-input:focus::-moz-placeholder { color: transparent; opacity: 0; }
.type-input:focus:-ms-input-placeholder { color: transparent; opacity: 0; }
.type-input:focus::-ms-input-placeholder { color: transparent; opacity: 0; }

/* Animación de error para input vacío */
.type-input.input-error-empty {
    background: rgba(220, 53, 69, 0.3);
    border-color: #dc3545;
    animation: inputErrorShake 0.6s ease-in-out;
    box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.3);
}

.type-input.input-error-empty::placeholder {
    color: rgba(255, 255, 255, 0.9);
    animation: placeholderPulse 1s ease-in-out infinite;
}

/* Rehabilitar el color de selección dentro del input aunque .back lo anule */
.back .type-input::selection { background: rgba(16,185,129,0.35) !important; color: #fff !important; }
.back .type-input::-moz-selection { background: rgba(16,185,129,0.35) !important; color: #fff !important; }

@keyframes inputErrorShake {
    0%, 100% { transform: translateX(0); }
    15% { transform: translateX(-5px); }
    30% { transform: translateX(5px); }
    45% { transform: translateX(-3px); }
    60% { transform: translateX(3px); }
    75% { transform: translateX(-1px); }
    90% { transform: translateX(1px); }
}

@keyframes placeholderPulse {
    0%, 100% { opacity: 0.9; }
    50% { opacity: 0.6; }
}

.check-button {
    background: linear-gradient(135deg, #4ecdc4, #3558e3);
    border: none;
    color: white;
    padding: 14px 32px;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
    /* Sombra más marcada para sensación de botón elevado */
    box-shadow: 0 8px 24px rgba(53,88,227,0.45), 0 2px 8px rgba(0,0,0,0.12);
    border: 1px solid rgba(53,88,227,0.35);
    transition: transform .15s ease, box-shadow .2s ease, filter .2s ease;
    min-width: 200px;
}

.check-button:hover { 
    transform: translateY(-2px); 
    box-shadow: 0 12px 28px rgba(53,88,227,0.55), 0 4px 10px rgba(0,0,0,0.14);
}
.check-button:active { 
    transform: translateY(0);
    /* Ligeramente más "hundido" al hacer click */
    box-shadow: 0 4px 12px rgba(53,88,227,0.40), inset 0 2px 8px rgba(0,0,0,0.18);
}

.no-duplicate-button {
    background-color: #e67e22;
    border: none;
    color: white;
    padding: 14px 24px;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(230,126,34,0.35);
    transition: transform .15s ease, box-shadow .2s ease;
    margin-left: 12px;
    /* Ocultar en PC/Desktop */
    display: none;
}

.no-duplicate-button:hover { 
    transform: translateY(-2px); 
    box-shadow: 0 6px 16px rgba(230,126,34,0.5);
    background-color: #d35400;
}
.no-duplicate-button:active { transform: translateY(0); }

.no-duplicate-button.button-pressed {
    animation: buttonPress 0.3s ease;
    background-color: #d35400;
}

.check-button.button-pressed {
    background: linear-gradient(135deg, #2563eb, #1d4ed8);
    transform: translateY(1px) scale(0.98);
    box-shadow: 0 2px 8px rgba(53,88,227,0.6);
    transition: all 0.1s ease;
}


    
    .check-button-row {
        justify-content: center;
        align-items: center;
    }

    /* En móviles, ocultar botones de caracteres especiales (teclado virtual los cubre) */
    .special-chars { display: none !important; }


/* Animación para la aparición del botón */
@keyframes slideInFromRight {
    0% {
        opacity: 0;
        transform: translateX(20px);
    }
    100% {
        opacity: 1;
        transform: translateX(0);
    }
}


    
    .check-button-row {
        justify-content: center;
        align-items: center;
    }


/* Animación para la aparición del botón */
@keyframes slideInFromRight {
    0% {
        opacity: 0;
        transform: translateX(20px);
    }
    100% {
        opacity: 1;
        transform: translateX(0);
    }
}

.type-input-container {
    position: relative;
    width: 100%;
    display: flex;
    align-items: center;
}

.type-input-container .type-input {
    width: 100%;
    padding-right: 45px; /* Espacio para el botón clear */
}

.clear-button-inside {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: linear-gradient(135deg, #1e3a8a, #1e40af);
    border: 1px solid rgba(30, 58, 138, 0.3);
    border-radius: 8px;
    color: #fff;
    font-size: 0.9rem;
    padding: 5px 7px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 30px;
    height: 30px;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(30, 58, 138, 0.3);
}

.clear-button-inside:hover {
    background: linear-gradient(135deg, #1e40af, #2563eb);
    border-color: rgba(30, 58, 138, 0.4);
    color: #fff;
    box-shadow: 0 4px 12px rgba(30, 58, 138, 0.4);
    transform: translateY(-50%) translateY(-1px) scale(1.02);
}

.clear-button-inside:active {
    background: linear-gradient(135deg, #1e3a8a, #1d4ed8);
    transform: translateY(-50%) scale(0.98);
    box-shadow: 0 2px 6px rgba(30, 58, 138, 0.5);
}

/* Animación escalonada para las tarjetas de palabras */
.word-card:nth-child(1) { animation-delay: 0s; }
.word-card:nth-child(2) { animation-delay: 0.05s; }
.word-card:nth-child(3) { animation-delay: 0.1s; }
.word-card:nth-child(4) { animation-delay: 0.15s; }
.word-card:nth-child(5) { animation-delay: 0.2s; }
.word-card:nth-child(6) { animation-delay: 0.25s; }
.word-card:nth-child(7) { animation-delay: 0.3s; }
.word-card:nth-child(8) { animation-delay: 0.35s; }

/* === ESTILOS PARA MODAL DE BANDERA === */
.flag-card-container {
    width: 100%;
    height: 500px;
    max-height: 500px;
    max-width: 400px;
    background: linear-gradient(to right, #1f3658, #3558e3);
    border-radius: 25px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    border: 3px solid #aab0b4;
    overflow: hidden;
    position: relative;
    animation: slideInModal 0.4s ease-out;
    display: flex;
    flex-direction: column;
}

.flag-controls-floating {
    position: absolute;
    top: 15px;
    right: 15px;
    display: flex;
    gap: 8px;
    z-index: 10;
}

.flag-control-btn {
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.1);
    color: #374151;
    width: 40px;
    height: 40px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(10px);
}

.flag-control-btn:hover {
    background: #ffffff;
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
}

.flag-control-btn.close-btn {
    background: rgba(239, 68, 68, 0.9);
    color: white;
    border-color: rgba(239, 68, 68, 0.3);
}

.flag-control-btn.close-btn:hover {
    background: rgba(239, 68, 68, 1);
    transform: translateY(-2px) scale(1.05);
}

.flag-card-body-full {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
    overflow: hidden;
    position: relative;
    border-radius: 0 0 22px 22px;
}

.flag-display {
    width: 100%;
    height: 100%;
    border-radius: 0 0 22px 22px;
    box-shadow: none;
    border: none;
    transition: all 0.3s ease;
    display: block;
}

/* Responsive design para modal de bandera */
@media (max-width: 480px) {
    .flag-card-container {
        width: 100%;
        height: 550px;
        max-height: 550px;
        max-width: 400px;
        margin: 10px;
        border-radius: 25px;
        border: 3px solid #aab0b4;
        background: linear-gradient(to right, #1f3658, #3558e3);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .flag-controls-floating {
        top: 10px;
        right: 10px;
        gap: 6px;
    }
    
    .flag-card-body-full {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
        overflow: hidden;
        position: relative;
        border-radius: 0 0 22px 22px;
    }
    
    .flag-display {
        width: 100%;
        height: 100%;
        border-radius: 0 0 22px 22px;
        box-shadow: none;
        border: none;
        transition: all 0.3s ease;
        display: block;
    }
    
    .flag-control-btn {
        width: 36px;
        height: 36px;
        border-radius: 10px;
    }
    
    /* Ocultar el botón de pantalla completa en móviles */
    .fullscreen-btn {
        display: none !important;
    }
}

.flag-modal {
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(20px);
    border-radius: 20px;
    box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    overflow: hidden;
    animation: slideInModal 0.4s ease-out;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.flag-header {
    padding: 20px 30px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.9));
}

.flag-title {
    font-size: 1.5rem;
    font-weight: 700;
    margin: 0;
    color: #1f2937;
    letter-spacing: -0.3px;
}

.flag-close-btn {
    background: rgba(239, 68, 68, 0.1);
    border: none;
    color: #ef4444;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.flag-close-btn:hover {
    background: rgba(239, 68, 68, 0.2);
    transform: scale(1.1);
}

.flag-content {
    padding: 30px;
    text-align: center;
    background: linear-gradient(135deg, #f8fafc, #f1f5f9);
}

.flag-image {
    max-width: 100%;
    height: auto;
    max-height: 300px;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    transition: transform 0.3s ease;
    border: 2px solid rgba(255, 255, 255, 0.8);
}

.flag-image:hover {
    transform: scale(1.02);
}

/* Cursor pointer para las tarjetas clickeables */
.word-card {
    cursor: pointer;
}

.word-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
}

/* Responsive design para modal de bandera */
@media (max-width: 480px) {
    .flag-modal {
        width: 95%;
        margin: 10px;
    }
    
    .flag-header {
        padding: 15px 20px;
    }
    
    .flag-content {
        padding: 20px;
    }
    
    .flag-title {
        font-size: 1.3rem;
    }
    
    .flag-image {
        max-height: 200px;
    }
}

/* === ESTILOS PARA OVERLAY DE CONECTIVIDAD === */
.connectivity-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(135deg, rgba(220, 38, 51, 0.95) 0%, rgba(153, 27, 39, 0.98) 100%);
    backdrop-filter: blur(20px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    opacity: 0;
    visibility: hidden;
    transition: all 0.5s ease-in-out;
    color: white;
    font-family: Arial, sans-serif;
    padding: 20px;
    box-sizing: border-box;
}

.connectivity-overlay.show {
    opacity: 1;
    visibility: visible;
}

.connectivity-content {
    text-align: center;
    max-width: 600px;
    animation: connectivityPulse 2s ease-in-out infinite;
}

.connectivity-icon {
    font-size: 4rem;
    margin-bottom: 20px;
    display: block;
    color: #fff;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    animation: disconnectedBlink 1.5s ease-in-out infinite;
}

.connectivity-title {
    font-size: 2rem;
    font-weight: bold;
    margin: 0 0 15px 0;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    letter-spacing: -0.5px;
}

.connectivity-message {
    font-size: 1.2rem;
    margin: 0 0 30px 0;
    line-height: 1.5;
    opacity: 0.9;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.connectivity-status {
    background: rgba(0, 0, 0, 0.3);
    padding: 12px 20px;
    border-radius: 50px;
    display: inline-flex;
    align-items: center;
    gap: 10px;
    font-size: 1rem;
    font-weight: 600;
    border: 2px solid rgba(255, 255, 255, 0.2);
    margin-bottom: 25px;
    animation: statusPulse 2s ease-in-out infinite;
}

.connectivity-loading-dots {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-top: 20px;
}

.connectivity-dot {
    width: 10px;
    height: 10px;
    background: #fff;
    border-radius: 50%;
    animation: dotBounce 1.5s ease-in-out infinite;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
}

.connectivity-dot:nth-child(1) { animation-delay: 0s; }
.connectivity-dot:nth-child(2) { animation-delay: 0.3s; }
.connectivity-dot:nth-child(3) { animation-delay: 0.6s; }

.connectivity-retry-section {
    margin-top: 25px;
}

.connectivity-retry-btn {
    background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);
    color: #dc3545;
    border: 2px solid rgba(255, 255, 255, 0.3);
    padding: 12px 25px;
    font-size: 1rem;
    font-weight: 600;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin-top: 15px;
}

.connectivity-retry-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 35px rgba(0, 0, 0, 0.3);
    background: linear-gradient(135deg, #ffffff 0%, #f1f3f4 100%);
}

.connectivity-retry-btn:active {
    transform: translateY(0);
}

.connectivity-retry-btn.checking {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none;
}

/* Animaciones para el overlay de conectividad */
@keyframes connectivityPulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.02);
    }
}

@keyframes disconnectedBlink {
    0%, 50%, 100% {
        opacity: 1;
        transform: rotate(0deg);
    }
    25% {
        opacity: 0.5;
        transform: rotate(-5deg);
    }
    75% {
        opacity: 0.7;
        transform: rotate(5deg);
    }
}

@keyframes statusPulse {
    0%, 100% {
        border-color: rgba(255, 255, 255, 0.2);
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
    }
    50% {
        border-color: rgba(255, 255, 255, 0.5);
        box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
    }
}

@keyframes dotBounce {
    0%, 100% {
        transform: translateY(0px);
        opacity: 0.7;
    }
    50% {
        transform: translateY(-15px);
        opacity: 1;
    }
}

/* Efectos de reconexión exitosa */
.connectivity-overlay.reconnected {
    background: linear-gradient(135deg, rgba(40, 167, 69, 0.95) 0%, rgba(32, 134, 56, 0.98) 100%);
}

.connectivity-overlay.reconnected .connectivity-icon {
    animation: successSpin 1s ease-in-out;
}

.connectivity-overlay.reconnected .connectivity-title {
    color: #d4edda;
}

.connectivity-overlay.reconnected .connectivity-message {
    color: #d4edda;
}

@keyframes successSpin {
    0% {
        transform: rotate(0deg) scale(1);
        opacity: 0.5;
    }
    50% {
        transform: rotate(180deg) scale(1.2);
        opacity: 1;
    }
    100% {
        transform: rotate(360deg) scale(1);
        opacity: 1;
    }
}

/* Responsive design para overlay de conectividad */
@media (max-width: 768px) {
    .connectivity-icon {
        font-size: 3.5rem;
    }
    
    .connectivity-title {
        font-size: 1.8rem;
    }
    
    .connectivity-message {
        font-size: 1.1rem;
    }
    
    .connectivity-status {
        font-size: 0.95rem;
        padding: 10px 18px;
    }
    
    .connectivity-retry-btn {
        font-size: 0.95rem;
        padding: 10px 20px;
    }
}

@media (max-width: 480px) {
    .connectivity-title {
        font-size: 1.6rem;
    }
    
    .connectivity-message {
        font-size: 1rem;
    }
    
    .connectivity-icon {
        font-size: 3rem;
    }
    
    .connectivity-status {
        font-size: 0.9rem;
        padding: 8px 15px;
    }
    
    .connectivity-retry-btn {
        font-size: 0.9rem;
        padding: 8px 18px;
    }
    
    .connectivity-dot {
        width: 8px;
        height: 8px;
    }

    /* Estilos responsivos para botones en móviles */
    .check-button-row {
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
    }

    .check-button, .no-duplicate-button {
        font-size: 0.95rem;
        padding: 12px 16px;
        margin: 2px;
    }
    
    .no-duplicate-button {
        margin-left: 0;
        /* Oculto por defecto, se mostrará con JavaScript */
        display: none;
    }
    
    /* Clase para mostrar el botón cuando el input está activo */
    .no-duplicate-button.show-on-focus {
        display: inline-flex !important;
    }
}

/* Estilos para tablets y pantallas medianas */
@media (min-width: 769px) and (max-width: 1023px) {
    /* Ocultar botón "No sé" duplicado en tablets */
    .no-duplicate-button {
        display: none !important;
    }
}

/* Estilos específicos para PC/Desktop (pantallas grandes) */
@media (min-width: 1024px) {
    /* Ocultar botón "No sé" duplicado en PC */
    .no-duplicate-button {
        display: none !important;
    }
    
    .connectivity-content {
        max-width: 700px;
        padding: 40px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 25px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .connectivity-icon {
        font-size: 4.5rem;
        margin-bottom: 25px;
    }
    
    .connectivity-title {
        font-size: 2.2rem;
        margin-bottom: 20px;
    }
    
    .connectivity-message {
        font-size: 1.3rem;
        margin-bottom: 35px;
        max-width: 500px;
        margin-left: auto;
        margin-right: auto;
    }
    
    .connectivity-status {
        padding: 15px 30px;
        font-size: 1.1rem;
        margin-bottom: 30px;
    }
    
    .connectivity-retry-btn {
        padding: 15px 35px;
        font-size: 1.1rem;
        gap: 10px;
    }
    
    .connectivity-retry-btn:hover {
        transform: translateY(-3px);
    }
    
    .connectivity-dot {
        width: 12px;
        height: 12px;
    }
}



/* === ESTILOS PARA MODAL DE CONTINUACIÓN === */
.continue-game-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20000;
    opacity: 0;
    animation: fadeInOverlay 0.4s ease-out forwards;
}

.continue-game-modal {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.95) 100%);
    backdrop-filter: blur(25px);
    border-radius: 25px;
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);
    max-width: 500px;
    width: 90%;
    overflow: hidden;
    animation: slideInModal 0.5s ease-out;
    border: 2px solid rgba(255, 255, 255, 0.3);
    position: relative;
}

.continue-modal-header {
    padding: 35px 35px 25px;
    text-align: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    position: relative;
    overflow: hidden;
}

.continue-modal-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><defs><pattern id="stars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.5" fill="white" opacity="0.2"/><circle cx="12" cy="8" r="0.3" fill="white" opacity="0.15"/><circle cx="8" cy="15" r="0.4" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="20" fill="url(%23stars)"/></svg>') repeat;
    animation: sparkle 25s linear infinite;
    opacity: 0.3;
}

.continue-modal-icon {
    font-size: 3.5rem;
    margin-bottom: 15px;
    display: block;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    animation: bounce 2s infinite;
    position: relative;
    z-index: 2;
}

.continue-modal-title {
    font-size: 1.8rem;
    font-weight: 700;
    margin: 0 0 8px 0;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
}

.continue-modal-subtitle {
    font-size: 1.1rem;
    opacity: 0.9;
    margin: 0;
    font-weight: 400;
    position: relative;
    z-index: 2;
}

.continue-modal-content {
    padding: 30px 35px;
}

.continue-progress-info {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 25px;
    border: 1px solid rgba(102, 126, 234, 0.2);
    text-align: center;
}

.continue-progress-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #374151;
    margin-bottom: 15px;
}

.continue-progress-stats {
    display: flex;
    justify-content: space-around;
    gap: 15px;
}

.continue-stat-item {
    flex: 1;
    text-align: center;
}

.continue-stat-number {
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: 5px;
}

.continue-stat-number.correct {
    color: #10b981;
}

.continue-stat-number.incorrect {
    color: #ef4444;
}

.continue-stat-number.remaining {
    color: #f59e0b;
}

.continue-stat-label {
    font-size: 0.9rem;
    color: #6b7280;
    font-weight: 500;
}

.continue-modal-buttons {
    display: flex;
    gap: 15px;
    margin-top: 20px;
}

.continue-btn {
    flex: 1;
    padding: 16px 24px;
    border: none;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
}

.continue-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.continue-btn:hover::before {
    left: 100%;
}

.continue-btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
}

.continue-btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
}

.continue-btn-secondary {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    color: #374151;
    border: 2px solid rgba(102, 126, 234, 0.2);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
}

.continue-btn-secondary:hover {
    transform: translateY(-2px);
    background: linear-gradient(135deg, #ffffff 0%, #f1f5f9 100%);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    border-color: rgba(102, 126, 234, 0.3);
}

.continue-btn:active {
    transform: translateY(0);
}

@media (max-width: 480px) {
    .continue-game-modal {
        width: 95%;
        margin: 20px;
    }
    
    .continue-modal-header {
        padding: 25px 20px 20px;
    }
    
    .continue-modal-content {
        padding: 20px;
    }
    
    .continue-modal-buttons {
        flex-direction: column;
        gap: 12px;
    }
    
    .continue-modal-title {
        font-size: 1.5rem;
    }
    
    .continue-modal-icon {
        font-size: 3rem;
    }
}

        /* Estilos para el título creativo */
        .creative-title-container {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667eea 100%);
            padding: 1px 10px 1px 10px;
            position: relative;
            overflow: hidden;
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }
        
        .title-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><defs><pattern id="stars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.5" fill="white" opacity="0.3"/><circle cx="12" cy="8" r="0.3" fill="white" opacity="0.2"/><circle cx="8" cy="15" r="0.4" fill="white" opacity="0.25"/></pattern></defs><rect width="100" height="20" fill="url(%23stars)"/></svg>') repeat;
            animation: sparkle 20s linear infinite;
        }
        
        .creative-title {
            margin: 0;
            text-align: center;
            color: white;
            font-size: 22px;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
            position: relative;
            z-index: 2;
            text-shadow: 0 2px 8px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        
        .globe-icon {
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 28px;
            animation: rotate 4s ease-in-out infinite;
        }
        
        .title-text {
            background: linear-gradient(45deg, #FFD700, #FFF, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes sparkle {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }
        @keyframes rotate {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(10deg) scale(1.1); }
        }
        @keyframes glow {
            0% { filter: drop-shadow(0 0 5px rgba(255,215,0,0.3)); }
            100% { filter: drop-shadow(0 0 15px rgba(255,215,0,0.6)); }
        }

        /* === TECLADO VIRTUAL MODERNO === */
        .virtual-keyboard-overlay {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50000;
            display: none;
            align-items: flex-end;
            justify-content: center;
            pointer-events: auto; /* permitir interacción para cerrar y usar teclado */
        }
        
        /* Ocultar teclado virtual solo en pantallas de PC/Desktop grandes */
        @media (min-width: 1200px) {
            .virtual-keyboard-overlay {
                display: none !important;
            }
        }
        .virtual-keyboard {
            pointer-events: auto;
            width: 100%;
            max-width: 740px; /* un poco más ancho para dar más espacio a las teclas */
            margin: 0 auto;
            padding: 10px 6px 14px; /* reducir padding lateral para ganar ancho útil */
            border-radius: 18px 18px 0 0;
            background: linear-gradient(180deg, rgba(30,41,59,0.95), rgba(15,23,42,0.96));
            box-shadow: 0 -8px 30px rgba(0,0,0,0.4);
            border-top: 1px solid rgba(255,255,255,0.08);
            backdrop-filter: blur(10px);
            transform: translateY(100%);
            transition: transform 260ms cubic-bezier(0.22, 1, 0.36, 1);
        }
        .virtual-keyboard.show {
            transform: translateY(0);
        }
        .vk-row {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px; /* separación mínima para ensanchar teclas */
            margin-top: 2px; /* espacio entre filas reducido */
        }
        /* Fila superior: mismo gap mínimo para máxima anchura */
        .vk-row[data-row="1"] { gap: 2px; }
        .vk-row.shifted {
            grid-template-columns: repeat(8, 1fr); /* sin tecla Enter: 8 columnas */
        }
        .vk-key {
            height: 44px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.12);
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
            color: #fff;
            font-weight: 700;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: transform 0.06s ease, box-shadow 0.12s ease, background 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
        .vk-key:active {
            transform: translateY(1px) scale(0.99);
            box-shadow: 0 1px 6px rgba(0,0,0,0.3) inset;
        }
        .vk-key.primary {
            background: linear-gradient(180deg, #2563eb, #1d4ed8);
            border-color: rgba(37,99,235,0.6);
        }
        .vk-key.warn {
            background: linear-gradient(180deg, #e67e22, #d35400);
            border-color: rgba(230,126,34,0.6);
        }
        .vk-key.danger {
            background: linear-gradient(180deg, #ef4444, #dc2626);
            border-color: rgba(239,68,68,0.6);
        }
        .vk-footer {
            display: grid;
            grid-template-columns: auto minmax(96px, 1fr) 56px; /* controles + barra espaciadora reducida + ocultar */
            gap: 8px;
            margin-top: 2px; /* reducir separación bajo las filas/acentos */
            align-items: center;
        }
        .vk-controls { display: flex; gap: 6px; align-items: center; }
        .vk-group { display: inline-flex; gap: 6px; align-items: center; }
    .vk-radio { position: relative; display: inline-flex; align-items: center; cursor: pointer; }
        .vk-radio input { position: absolute; opacity: 0; pointer-events: none; }
        .vk-radio span {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            padding: 0 10px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.14);
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
            color: #fff;
            font-weight: 700;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
            user-select: none;
            cursor: pointer;
        }
        .vk-radio input:checked + span {
            background: linear-gradient(180deg, #2563eb, #1d4ed8);
            border-color: rgba(37,99,235,0.6);
        }
        .vk-key.space { grid-column: 2 / span 1; margin-top: 2px; margin-bottom: 2px; }
        .vk-key.hide { grid-column: 3 / span 1; height: 44px; display: flex; align-items: center; justify-content: center; }
        .vk-key.hide i { pointer-events: none; }
        .vk-key.small { font-size: 14px; font-weight: 600; }
        
        /* Bloque de acentos */
    .vk-accents { margin-top: 2px; }
        .vk-accents .row-accents {
            display: grid;
            grid-template-columns: repeat(6, 1fr); /* 5 acentos + 1 borrar */
            gap: 2px; /* igualar separación a 2px */
        }
        /* Estilo elegante para las teclas de acentos */
        .vk-accents .vk-key {
            background: linear-gradient(180deg, #a78bfa, #7c3aed); /* violeta suave a profundo */
            border-color: rgba(167, 139, 250, 0.65);
            box-shadow: 0 2px 10px rgba(124, 58, 237, 0.35), inset 0 1px 0 rgba(255,255,255,0.25);
            text-shadow: 0 1px 0 rgba(0,0,0,0.25);
            height: 36px; /* más bajas */
            font-size: 15px;
        }
        /* Tecla borrar de acentos: color distinto (rojo elegante) */
        .vk-accents .vk-key[data-key="backspace"] {
            background: linear-gradient(180deg, #f43f5e, #e11d48);
            border-color: rgba(244, 63, 94, 0.6);
            box-shadow: 0 2px 10px rgba(225, 29, 72, 0.35), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .vk-accents .vk-key[data-key="backspace"]:active {
            background: linear-gradient(180deg, #e11d48, #be123c);
        }
        .vk-accents .vk-key:active {
            background: linear-gradient(180deg, #946cf8, #6d28d9);
        }
        .vk-accents .row-n-tilde {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin-top: 8px;
        }
        .vk-accents .row-n-tilde .vk-key { grid-column: 3; }

        /* Efecto visual al pulsar teclas del teclado virtual */
        @keyframes keyHoverFlash {
            0% {
                box-shadow: 0 0 0 0 rgba(255,255,255,0.35), 0 0 16px rgba(79,70,229,0.6);
                transform: translateY(0) scale(1.02);
                filter: brightness(1.08);
            }
            100% {
                box-shadow: 0 2px 8px rgba(0,0,0,0.25);
                transform: translateY(0) scale(1);
                filter: brightness(1);
            }
        }
        .vk-key.press-glow {
            animation: keyHoverFlash 1s ease-out;
        }
        /* Mejora de legibilidad del teclado en pantallas móviles/táctiles */
        @media (max-width: 768px), (pointer: coarse) {
            /* Teclas principales más altas y con fuente mayor */
            .vk-key { height: 52px; font-size: 18px; }
            .vk-key.small { font-size: 16px; }
            .vk-key.hide { height: 52px; }
            .vk-row { gap: 3px; margin-top: 2px; }
            .vk-row[data-row="1"] { gap: 3px; }
            .vk-footer { gap: 8px; margin-top: 2px; }
            /* Acentos un poco más grandes también */
            .vk-accents { margin-top: 2px; }
            .vk-accents .vk-key { height: 42px; font-size: 17px; }
            .vk-accents .row-accents, .vk-accents .row-n-tilde { gap: 3px; }
        }
    </style></head>
<body>

<!-- Overlay de Conectividad -->
<div id="connectivity-overlay" class="connectivity-overlay">
    <div class="connectivity-content">
        <span class="connectivity-icon">📡</span>
        <h1 class="connectivity-title">Sin Conexión</h1>
        <p class="connectivity-message">
            Parece que tu conexión a Internet es débil o se ha perdido.<br>
            Esta aplicación necesita conexión para funcionar correctamente.
        </p>
        
        <div class="connectivity-status">
            <i class="fas fa-wifi"></i>
            <span id="connectivity-status-text">Verificando conexión...</span>
        </div>
        
        <div class="connectivity-loading-dots">
            <div class="connectivity-dot"></div>
            <div class="connectivity-dot"></div>
            <div class="connectivity-dot"></div>
        </div>
        
        <div class="connectivity-retry-section">
            <button id="connectivity-retry-btn" class="connectivity-retry-btn">
                <i class="fas fa-redo"></i>
                <span>Intentar de nuevo</span>
            </button>
        </div>
    </div>
</div>



<!-- Título creativo -->
<div class="creative-title-container">
    <div class="title-background"></div>
    <h1 class="creative-title">
        <i class="fas fa-briefcase globe-icon"></i>
        <span class="title-text">Profesiones(1)</span>
    </h1>
</div>

<div class="top-status-bar">

    <div class="pill back-arrow" onclick="goBack()">
        <span><i class="fas fa-arrow-left"></i></span>
    </div>
  <div class="pill pill-faltan">
    <span>T: <span id="total-cards"></span></span>
  </div>
    <div class="pill pill-correctas">
        <span><i class="fas fa-check"></i> <span id="correctas-count">0</span></span>
    </div>
    <div class="pill pill-incorrectas">
        <span><i class="fas fa-times"></i> <span id="incorrectas-count">0</span></span>
    </div>
    
   
</div>


    <div id="flashcard-container-wrapper">

<!--------------------------------------------------------------------->

<div id="flashcard-container">
    <div class="editor-name">@Faouzi ElHilali</div>
    <!-- Tarjetas de imágenes -->
    <div class="flashcard">
        <div class="front">                 
            <img src="https://fawzinoo.github.io/Fotos/medico.webp" alt="Médico">
        </div>
        <div class="back">Médico</div>
    </div>

    <div class="flashcard">
        <div class="front">
            <img src="https://fawzinoo.github.io/Fotos/dentista.webp" alt="Dentista">
        </div>
        <div class="back">Dentista</div>
    </div>

    <div class="flashcard">
        <div class="front">
            <img src="https://fawzinoo.github.io/Fotos/veterinario.webp" alt="Veterinario">
        </div>
        <div class="back">Veterinario</div>
    </div>


    <div class="flashcard">
        <div class="front">
            <img src="https://fawzinoo.github.io/Fotos/enfermo.webp" alt="Enfermero">
        </div>
        <div class="back">Enfermero</div>
    </div>



    
    <style>
        /* Icono solo para el de arriba; no rompe el texto que actualiza el JS */
        #porcentaje-guardado {
            display: inline-flex;
            align-items: center;
            position: relative; /* Para hints posicionados */
            overflow: visible;
        }
        #porcentaje-guardado::before {
            content: "\f295"; /* fa-percent */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            font-size: 16px;
            margin-right: 6px;
        }
    </style>

    <!-- Override: cambiar icono del porcentaje de aciertos -->
    <style>
        #porcentaje-guardado::before {
            content: "\f091"; /* fa-trophy */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            font-size: 16px;
            margin-right: 6px;
        }
        /* Transición para ocultar/mostrar el cuadro de stats */
        #stats-box {
            transition: opacity 320ms ease, transform 320ms ease, filter 320ms ease;
        }
        #stats-box.hidden {
            opacity: 0;
            transform: scale(0.75);
            filter: blur(2px);
            pointer-events: none;
        }
        /* Hints: texto limpio sin brillos/luces, en amarillo sólido */
        .pill-hint {
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 14px;
            white-space: nowrap;
            z-index: 100;
            overflow: hidden; /* para el tipeo */
            pointer-events: none; /* no bloquea clics */
            /* Tipografía y color moderno */
            font-weight: 900;
            font-size: 18px;
            letter-spacing: 0.3px;
            line-height: 1.1;
            color: #ffeb3b; /* amarillo sólido */
            text-shadow: none; /* sin efecto de luz */
            -webkit-text-stroke: 1.25px #000; /* contorno negro para "revistido de negro" */
            paint-order: stroke fill;
            /* Efectos */
            opacity: 0;
            width: 0ch; /* arranca sin ancho y “tipea” */
            will-change: transform, opacity;
            animation:
                typing var(--type-dur, 1200ms) steps(var(--chars, 12)) var(--delay, 0ms) both,
                hintEnter 640ms cubic-bezier(0.22, 1, 0.36, 1) calc(var(--delay, 0ms) + var(--intro-delay, 180ms)) both,
                hintFadeOut 480ms ease-in var(--fade-delay, 2200ms) forwards;
        }
        .pill-hint::before {
            /* Quitar aura/halo */
            content: none !important;
            display: none !important;
        }
        .pill-hint::after { display: none; }
        @keyframes typing {
            from { width: 0ch; }
            to { width: calc(var(--chars, 12) * 1ch); }
        }
        @keyframes hintEnter {
            0%   { opacity: 0; transform: translateY(-50%) translateX(14px) scale(0.96) rotate(-1.5deg); filter: blur(3px); }
            60%  { opacity: 1; transform: translateY(-50%) translateX(-2px) scale(1.02) rotate(0.3deg); filter: blur(0.5px); }
            100% { opacity: 1; transform: translateY(-50%) translateX(0) scale(1) rotate(0); filter: blur(0); }
        }
        /* caretBlink eliminado: sin cursor parpadeante */
        @keyframes hintFadeOut {
            0%   { opacity: 1; transform: translateY(-50%) translateX(0); filter: blur(0); }
            100% { opacity: 0; transform: translateY(-50%) translateX(-6px); filter: blur(2px); }
        }
    </style>

    <!-- Firma del editor dentro del contenedor de tarjetas -->
    <style>
        .editor-name {
            position: absolute;
            bottom: 5px;
            left: 15px; /* abajo izquierda del contenedor */
            font-size: 9px;
            animation: colorTintineo 3s infinite;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            z-index: 21; /* sobre el contenido base */
            pointer-events: none; /* no bloquea clics */
        }
        @keyframes colorTintineo {
            0% { color: #ff0000; }
            20% { color: #ffff00; }
            40% { color: #0000ff; }
            60% { color: #ffffff; }
            80% { color: #000000; }
            100% { color: #ff0000; }
        }
    </style>

    <!-- Cuadro unificado para ambos porcentajes (misma talla de pills, separados por línea) -->
    <div id="stats-box" style="
        position: absolute;
        bottom: 6px;
        right: 8px;
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        /* Caja elegante sin alterar el tamaño de los pills */
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 14px;
        padding: 6px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.18);
        border: 1px solid rgba(255,255,255,0.14);
        transform: scale(0.8);
        transform-origin: bottom right;
    ">
    <!-- Porcentaje de aciertos (sin cambiar su tamaño) -->
    <div class="pill" id="porcentaje-guardado" style="
        background: rgba(255, 255, 255, 0.08);
        color: white;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.2);
        min-width: 65px;
        text-align: center;
    "><span id="current-percentage">0%</span></div>

    <!-- Separador fino entre ambos -->
    <div style="
        width: 100%;
        height: 1px;
        background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.35), rgba(255,255,255,0));
                "></div>
    <div class="pill" id="last-game-pill" style="
        background: rgba(255, 255, 255, 0.08);
        color: white;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.2);
        min-width: 65px;
        position: relative; /* Para hints posicionados */
        overflow: visible;
    ">
        <span><i class="fas fa-chart-line"></i> <span id="last-game-percentage">0%</span></span>
    </div>
    </div>

</div>
    </div>
    
    <audio id="soundResetButton" src="https://fawzinoo.github.io/audios/bellding-254774.mp3" preload="auto"></audio>
    <audio id="shuffleSound" src="https://fawzinoo.github.io/audios/naipe.mp3" preload="auto"></audio>
    <audio id="buttonClickSound" src="https://fawzinoo.github.io/audios/botonn.mp3" preload="auto"></audio>
    <audio id="keyboardSound" src="https://fawzinoo.github.io/audios/teclas1.mp3" preload="auto"></audio>
    <audio id="keyboardSound" src="https://fawzinoo.github.io/audios/tecla.mp3" preload="auto"></audio>
    <audio id="trashSound" src="https://fawzinoo.github.io/audios/trash.mp3" preload="auto"></audio>

    <div class="button-container">
        <button class="button" id="reset-button">Reiniciar</button>
        <button class="button" id="skip-button" style="background-color: #e67e22;">
            <i class="fas fa-forward"></i> No sé
        </button>
        <button class="button" id="shuffle-button" style="background-color: #9b59b6;">
            <i class="fas fa-random"></i> Mezclar
        </button>
    </div>
    

    <!-- Análisis de audio para verificación fonética -->
    <script src="https://unpkg.com/meyda/dist/web/meyda.min.js"></script>

    <!-- Agregar la librería de confeti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

    <script>

        document.addEventListener('DOMContentLoaded', () => {
            const flashcardContainer = document.getElementById('flashcard-container');
            if (flashcardContainer) {
                // Listener en fase de CAPTURA para interceptar clics "fantasma" y manejar la lógica de volteo
                flashcardContainer.addEventListener('click', (event) => {
                    // 1. Lógica para ignorar el "clic fantasma"
                    if (window.ignoreClickAfterButton) {
                        const rect = window.ignoreClickAfterButton;
                        // Comprueba si el clic ocurrió dentro de los límites del botón desaparecido
                        if (event.clientX >= rect.left && event.clientX <= rect.right &&
                            event.clientY >= rect.top && event.clientY <= rect.bottom) {
                            
                            // Restablece la bandera y detiene completamente el evento.
                            window.ignoreClickAfterButton = null;
                            event.stopPropagation();
                            event.preventDefault();
                            return; // El clic fue ignorado, no hacer nada más.
                        }
                        // Si el clic no fue en el área fantasma, limpiar la bandera para futuros clics.
                        window.ignoreClickAfterButton = null;
                    }

                    // 2. Lógica para evitar el volteo al hacer clic en el área de escritura
                    const typeDialog = event.target.closest('.type-dialog-container');
                    if (typeDialog) {
                        // Si el clic fue dentro del área de escritura, no hagas nada.
                        // No es necesario stopPropagation porque la lógica de volteo está más abajo.
                        return;
                    }
                    
                    // 3. Lógica para voltear la tarjeta (si ninguna de las condiciones anteriores se cumplió)
                    const currentCard = document.querySelector('.flashcard.is-visible');
                    if (currentCard && !currentCard.classList.contains('flipped')) {
                        // Solo voltea si la tarjeta es visible y está en el anverso.
                        flipCard(currentCard);
                    }
                }, true); // <-- ¡IMPORTANTE! Usar la fase de captura.
            }
        });

        

        function vibrar(ms = 80) {
    if (window.navigator && window.navigator.vibrate) {
        window.navigator.vibrate(ms);
    }
}

        function playErrorSound() {
    const errorAudio = new Audio('https://fawzinoo.github.io/audios/error.mp3');
    errorAudio.volume = 0.5;
    errorAudio.play().catch(() => {});
}

function playButtonSound() {
    // Agregar vibración leve a todos los botones
    vibrar(50); // Vibración más suave que los botones principales
    
    const buttonAudio = document.getElementById('buttonClickSound');
    if (buttonAudio) {
        buttonAudio.currentTime = 0; // Reiniciar el audio
        buttonAudio.volume = 0.7;
        buttonAudio.play().catch(() => {});
    }
}

function playKeyboardSound() {
    const keyboardSound = document.getElementById('keyboardSound');
    if (keyboardSound) {
        keyboardSound.currentTime = 0;
        keyboardSound.volume = 0.4;
        keyboardSound.play().catch(() => {});
    }
}

function playTrashSound() {
    const trashSound = document.getElementById('trashSound');
    if (trashSound) {
        trashSound.currentTime = 0;
        trashSound.volume = 0.6;
        trashSound.play().catch(() => {});
    }
}

function quitarAcentos(str){
    return (str||'')
      .toLowerCase()
      .normalize('NFD')
      .replace(/\p{Diacritic}+/gu,'')
      .trim();
}

function goBack() {
    // Reproducir sonido de botón
    playButtonSound();
    
    // Verificar si hay historial de navegación
    if (window.history.length > 1) {
        // Usar history.back() para regresar a la página anterior
        window.history.back();
    } else if (document.referrer && document.referrer !== window.location.href) {
        // Si no hay historial pero sí hay referrer, ir al referrer
        window.location.href = document.referrer;
    } else {
        // Como último recurso, redirigir a la página principal
        window.location.href = 'https://fawzinoo.github.io/Rep/Vocabulario.html';
    }
}

// --- NUEVO SISTEMA DE RECONOCIMIENTO DE VOZ (CLIENTE) ---

let mediaRecorder;
let audioChunks = [];
let isRecording = false;

// Sistema de tarjetas completadas
let completedCards = new Set();
let correctCount = 0;
let incorrectCount = 0;
let currentCardIndex = 0;
let voiceAttempts = 0; // Contador para los intentos de voz
let canFlipBack = true;
let canFlip = true; // Controla si se puede voltear la tarjeta
// Timer para programar la actualización del porcentaje tras re-aparecer el cuadro
let percentageUpdateTimeoutId = null;
let statsShowTimeoutId = null;
let statsHideTimeoutId = null;

// Estado: ventana entre 1er y 2º intento
let betweenAttempts = false;
// Timeouts para gestionar ventana entre intentos
let errorDelayTimeoutId = null;       // 2s de mensaje Incorrecto tras primer fallo
let resumeRecognitionTimeoutId = null; // ~100ms antes de reanudar reconocimiento



// Flags para controlar el botón "No sé" en estados de back
let showingErrorMessage = false;           // true mientras se muestra el mensaje "Incorrecto"
let lockedAfterSecondIncorrect = false;    // bloquea el botón tras segundo intento fallido hasta pasar de tarjeta
let lockedAfterCorrect = false;            // bloquea el botón tras acierto hasta pasar de tarjeta

function setSkipEnabled(enabled) {
    const skipBtn = document.getElementById('skip-button');
    if (!skipBtn) return;
    skipBtn.disabled = !enabled;
    skipBtn.style.opacity = enabled ? '1' : '0.5';
    skipBtn.style.pointerEvents = enabled ? 'auto' : 'none';
    // Sincronizar también el estado con el botón móvil "No sé" (si existe en la tarjeta visible)
    try {
        const visibleBack = document.querySelector('.flashcard.is-visible .back');

        if (mobileSkip) {
            mobileSkip.disabled = !enabled;
            // También actualizar accesibilidad
            mobileSkip.setAttribute('aria-disabled', (!enabled).toString());
        }
    } catch {}
}

// Habilita "No sé" solo en dos momentos:
// 1) Cuando la tarjeta visible está en front (antes del primer intento)
// 2) Tras el primer fallo, en la ventana entre intentos (betweenAttempts=true)
function updateSkipButtonState() {
    const card = document.querySelector('.flashcard.is-visible');
    if (!card) { setSkipEnabled(false); return; }
    const isFront = !card.classList.contains('flipped');
    if (isFront) {
        // Permitido al estar en front (antes del 1er intento)
        setSkipEnabled(true);
        return;
    }
    // Back: activar por defecto salvo condiciones de bloqueo
    // Bloqueos explícitos: mientras se muestran mensajes de error, y después del segundo incorrecto
    if (showingErrorMessage || lockedAfterSecondIncorrect || lockedAfterCorrect) { 
        setSkipEnabled(false); 
        return; 
    }
    // En la ventana entre intentos tras el primer fallo: desactivado
    if (betweenAttempts) {
        setSkipEnabled(false);
        return;
    }
    // Para modo escritura, permitir "No sé" por defecto en back
    setSkipEnabled(true);
}

// === Helpers de UI: botón móvil "No sé" ===
function showMobileSkipButton() {
    try {
        // Mostrar el botón móvil en la tarjeta visible
        const scope = document.querySelector('.flashcard.is-visible') || document;
        scope.querySelectorAll('.mobile-skip-button').forEach(btn => {
            btn.classList.add('keyboard-visible');
            btn.setAttribute('aria-hidden', 'false');
            btn.style.pointerEvents = 'auto';
        });
    } catch (e) { /* noop */ }
}

function hideMobileSkipButton(immediate = true) {
    try {
        // Ocultar el botón móvil en la tarjeta visible
        const scope = document.querySelector('.flashcard.is-visible') || document;
        scope.querySelectorAll('.mobile-skip-button').forEach(btn => {
            btn.classList.remove('keyboard-visible');
            btn.setAttribute('aria-hidden', 'true');
            // No animamos por ahora; immediate no cambia comportamiento, pero se conserva firma
            btn.style.pointerEvents = 'none';
        });
    } catch (e) { /* noop */ }
}

// Permitir saltar tarjeta como "No sé"
function skipCurrentCardAsUnknown() {
    console.log('🎯 skipCurrentCardAsUnknown iniciada');
    // Respetar estado de habilitación del botón
    const btn = document.getElementById('skip-button');
    if (btn && btn.disabled) {
        console.log('❌ Botón skip deshabilitado, cancelando');
        return;
    }
    
    // Cancelar timeouts pendientes de la ventana entre intentos
    if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
    if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }
    
    // Limpiar estados de bloqueo
    betweenAttempts = false;
    showingErrorMessage = false;
    lockedAfterSecondIncorrect = false;
    lockedAfterCorrect = false;
    
    // Evitar doble procesamiento si no hay tarjetas o ya está completada
    const flashcardsList = Array.from(document.querySelectorAll('.flashcard'));
    if (flashcardsList.length === 0) return;
    if (completedCards.has(currentCardIndex)) {
        // Si ya está completada, simplemente avanza
        goToNextCard();
        return;
    }

    // Marcar como incorrecta
    try {
        const currentCard = flashcardsList[currentCardIndex];
        const back = currentCard.querySelector('.back');
        const targetWord = currentCard.dataset.answer || (back ? back.textContent.trim() : '');
        if (targetWord) {
            incorrectWords.push(targetWord);
        }
    } catch (e) {}
    incorrectCount += 1;
    completedCards.add(currentCardIndex);

    // Persistir y actualizar UI
    saveGameProgress();
    updateCounters();
    updateCardCounter();

    // Resetear contador de intentos para la siguiente tarjeta
    voiceAttempts = 0;
    
    // Habilitar botón mezclar al saltar tarjeta
    const shuffleBtn = document.getElementById('shuffle-button');
    if (shuffleBtn) {
        shuffleBtn.disabled = false;
    }
    
    // Si está visible el teclado virtual en móvil, ocultarlo y esconder el botón móvil "No sé"
    try {
        const vk = document.getElementById('vk');
        const vkOverlay = document.getElementById('vk-overlay');
        if (vk && vk.classList.contains('show')) {
            vk.classList.remove('show');
            setTimeout(() => { if (vkOverlay) vkOverlay.style.display = 'none'; }, 220);
        }

    } catch {}
    
    // Avanzar a la siguiente tarjeta
    goToNextCard();
}

function scheduleStatsBoxUpdate() {
    const statsBox = document.getElementById('stats-box');
    if (!statsBox) { 
        // Fallback: aplicar inmediatamente
        updateCounters();
        if (typeof updateSuccessPercentage === 'function') updateSuccessPercentage();
        return; 
    }
    // Cancelar temporizadores anteriores
    if (statsShowTimeoutId) { clearTimeout(statsShowTimeoutId); statsShowTimeoutId = null; }
    if (statsHideTimeoutId) { clearTimeout(statsHideTimeoutId); statsHideTimeoutId = null; }
    if (percentageUpdateTimeoutId) { clearTimeout(percentageUpdateTimeoutId); percentageUpdateTimeoutId = null; }

    // 1) Mostrar cuadro ahora mismo
    statsBox.classList.remove('hidden');
    // 2) En 2s, aplicar actualización del marcador
    statsShowTimeoutId = setTimeout(() => {
        updateCounters();
        if (typeof updateSuccessPercentage === 'function') updateSuccessPercentage();
        // 3) Mantener visible y ocultar 3s después
        statsHideTimeoutId = setTimeout(() => {
            statsBox.classList.add('hidden');
        }, 3000);
    }, 2000);
}

// Función para normalizar el texto: quitar acentos, puntuación y a minúsculas.
function normalizeText(text) {
    if (!text) return "";
    return text.trim();
}

// === SISTEMA DE PERMISOS DE MICRÓFONO ===
let microphonePermissionGranted = null; // null = no preguntado, true = permitido, false = denegado
let microphonePermissionAsked = false;

// Helper: saber si el modal de micrófono ya está visible
function isMicModalVisible() {
    const overlay = document.getElementById('microphone-permission-overlay');
    return !!(overlay && overlay.classList.contains('show') && overlay.style.display !== 'none');
}

// Verificar si ya se han pedido permisos anteriormente
function checkPreviousMicrophonePermission() {
    const permission = localStorage.getItem('microphonePermissionGranted');
    if (permission !== null) {
        microphonePermissionGranted = permission === 'true';
        microphonePermissionAsked = true;
        console.log(`🎤 Permiso de micrófono previo: ${microphonePermissionGranted ? 'CONCEDIDO' : 'DENEGADO'}`);
    }
}

// Mostrar modal de permisos personalizado
function showMicrophonePermissionModal() {
    return new Promise((resolve) => {
        const overlay = document.getElementById('microphone-permission-overlay');
        const allowBtn = document.getElementById('microphone-permission-allow');
        if (!overlay || !allowBtn) {
            console.error('❌ No se pudo encontrar el modal de permisos');
            resolve(false);
            return;
        }
        // Mostrar overlay simple (como en la imagen)
        overlay.classList.add('show');
        overlay.style.pointerEvents = 'auto';
        overlay.style.display = 'flex';
        overlay.style.zIndex = '999999';

        const onAllow = async () => {
            overlay.classList.remove('show');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphonePermissionGranted = true;
                microphonePermissionAsked = true;
                localStorage.setItem('microphonePermissionGranted', 'true');
                stream.getTracks().forEach(t => t.stop());
                resolve(true);
            } catch (e) {
                microphonePermissionGranted = false;
                microphonePermissionAsked = true;
                localStorage.setItem('microphonePermissionGranted', 'false');
                resolve(false);
            } finally {
                allowBtn.removeEventListener('click', onAllow);
            }
        };
        allowBtn.addEventListener('click', onAllow, { once: true });
    });
}

// Función principal para manejar permisos de micrófono
async function handleMicrophonePermission() {
    // Respetar estado previo desde localStorage (cargado por checkPreviousMicrophonePermission)
    if (microphonePermissionAsked && microphonePermissionGranted) {
        console.log('✅ Permisos de micrófono previamente concedidos');
        return true;
    }
    if (microphonePermissionAsked && !microphonePermissionGranted) {
        console.log('❌ Permisos de micrófono previamente denegados');
        return false;
    }
    
    // Primera vez: mostrar modal personalizado sin consultar APIs que disparen el prompt nativo
    console.log('🆕 Primera solicitud de permisos de micrófono (modal personalizado primero)');
    const result = await showMicrophonePermissionModal();
    if (!result) {
        console.log('❌ Permisos denegados');
        return false;
    }
    console.log('🎉 ¡Permisos de micrófono completamente concedidos!');
    return true;
}

// Inicializar sistema de permisos
async function initializeMicrophonePermissions() {
    checkPreviousMicrophonePermission();
    // Intentar usar Permissions API si está disponible
    try {
        if (navigator.permissions && navigator.permissions.query) {
            // Nota: Algunos navegadores no soportan { name: 'microphone' }
            const status = await navigator.permissions.query({ name: 'microphone' });
            if (status.state === 'granted') {
                microphonePermissionGranted = true;
                microphonePermissionAsked = true;
                localStorage.setItem('microphonePermissionGranted', 'true');
            } else if (status.state === 'denied') {
                microphonePermissionGranted = false;
                microphonePermissionAsked = true;
                localStorage.setItem('microphonePermissionGranted', 'false');
            } else {
                // 'prompt'
                microphonePermissionAsked = false;
            }
            status.onchange = () => {
                const st = status.state;
                microphonePermissionGranted = (st === 'granted');
                microphonePermissionAsked = (st !== 'prompt');
                localStorage.setItem('microphonePermissionGranted', microphonePermissionGranted ? 'true' : 'false');
            };
        }
    } catch (e) {
        console.warn('Permissions API no disponible para micrófono:', e);
    }
    console.log('🎤 Sistema de permisos de micrófono inicializado');
}


function startVoiceRecognition(targetWord, backElement) {
    // Deshabilitado: el modo de juego es por escritura. Se mantiene solo "No sé" con el detector mínimo al voltear a back.
    console.log('Reconocimiento de voz deshabilitado: usar entrada escrita.');
    return;
}

// Función separada para el reconocimiento de voz real
function startSpeechRecognition(targetWord, backElement) {
    // Deshabilitado: el modo de juego es por escritura. No iniciar reconocimiento ni UI.
    console.log('Reconocimiento de voz (speech) deshabilitado.');
    return;
}
// Indicador de escucha: deshabilitado en modo escrito
function showListeningIndicator(backElement) { /* noop */ }
function ensureIndicatorVisible(backElement) { /* noop */ }
function removeListeningIndicator(backElement) { /* noop */ }
// Limpieza del back: ya no preservamos indicadores de voz
function clearBackContent(backElement) {
    if (!backElement) return;
                backElement.innerHTML = `
                    <div class=\"type-message\" id=\"type-message\" style=\"display:none;\"></div>
                    <div class=\"type-word-title\" id=\"type-word-title\" style=\"display:none;\"></div>
                    <div class=\"type-dialog-container\"> 
                        <div class=\"type-input-row\"> 
                            <input id=\"type-input\" class=\"type-input\" type=\"text\" autocomplete=\"off\" placeholder=\"Escribe aquí...\" />
                            <button id=\"check-button\" class=\"check-button\">comprobar</button>
                        </div>
                    </div>
                `;
    // Como fallback, intenta limpiar en la tarjeta visible
    const visibleBack = document.querySelector('.flashcard.is-visible .back');
    if (visibleBack) {
        visibleBack.querySelectorAll('.listening-indicator').forEach(el => el.remove());
    }
}


let isShuffling = false;
// Límite de usos del botón Mezclar por partida
let shuffleClickCount = 0;
const SHUFFLE_MAX_CLICKS = 3;

// Restaurar contador de Mezclar desde localStorage (persiste hasta fin de juego)
try {
    const savedShuffle = parseInt(localStorage.getItem('profesiones11_shuffleCount') || '0', 10);
    if (!isNaN(savedShuffle) && savedShuffle >= 0) {
        shuffleClickCount = savedShuffle;
    }
} catch (e) { /* ignore */ }

document.getElementById('shuffle-button').addEventListener('click', () => {
    // Si alcanzó el límite, mostrar aviso creativo y no mezclar
    if (shuffleClickCount >= SHUFFLE_MAX_CLICKS) {
        vibrar(60);
        const existing = document.getElementById('shuffle-limit-toast');
        if (existing) existing.remove();
        const toast = document.createElement('div');
        toast.id = 'shuffle-limit-toast';
        toast.innerHTML = `
            <div style="
                display: flex; align-items: center; justify-content: center;
                gap: 12px; font-size: 16px; font-weight: 600;">
                <span>Has mezclado 3 veces. ¡Ahora confía en tu memoria! 🧠</span>
            </div>`;
        toast.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(40,0,60,0.95) 0%, rgba(80,0,120,0.95) 100%);
            color: #fff; padding: 18px 24px; border-radius: 16px; font-weight: 600; font-size: 15px;
            z-index: 10000; backdrop-filter: blur(10px); border: 1px solid rgba(156,39,176,0.35);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 24px rgba(156,39,176,0.2);
            animation: modernFadeInOut 2.2s ease; min-width: 280px; text-align: center;`;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 2200);
        return;
    }

    if (isShuffling) return;
    isShuffling = true;
    shuffleClickCount++;
    try { localStorage.setItem('profesiones11_shuffleCount', String(shuffleClickCount)); } catch (e) {}
    
    vibrar(80); 
    document.getElementById('shuffleSound').play().catch(() => {});
    shuffleCards();
    
    setTimeout(() => { 
        isShuffling = false;
    }, 800); // Evita abusos rápidos
});

// Botón "No sé"
const skipBtn = document.getElementById('skip-button');
if (skipBtn) {
    skipBtn.addEventListener('click', () => {
        vibrar(60);
        playButtonSound();
        skipCurrentCardAsUnknown();
    });
}

let _successAudioEl = null;
function playSuccessSound(onEnded) {
    try {
        if (!_successAudioEl) {
            _successAudioEl = new Audio('https://fawzinoo.github.io/audios/win.mp3');
            _successAudioEl.preload = 'auto';
            _successAudioEl.volume = 0.7;
            try { _successAudioEl.load(); } catch {}
        } else {
            try { _successAudioEl.pause(); _successAudioEl.currentTime = 0; } catch {}
        }
        _successAudioEl.onended = null;
        if (typeof onEnded === 'function') _successAudioEl.onended = onEnded;
        _successAudioEl.play().catch(() => { if (typeof onEnded === 'function') onEnded(); });
        return _successAudioEl;
    } catch (e) {
        if (typeof onEnded === 'function') onEnded();
        return null;
    }
}

function showCountdown(card) {
    // Limpiar detección de teclado móvil si existe
    const back = card.querySelector('.back');
    if (back._cleanupKeyboardDetection) {
        back._cleanupKeyboardDetection();
        delete back._cleanupKeyboardDetection;
    }
    // Evitar countdowns duplicados
    if (back._countdownRunning) {
        console.log('⏳ Countdown ya en curso, se ignora');
        return;
    }
    back._countdownRunning = true;
    // Mantener visible el cuadro de escritura durante el countdown
    // Limpiar cualquier fallback previo
    try {
        if (back._countdownFallbackTimeout) {
            clearTimeout(back._countdownFallbackTimeout);
            back._countdownFallbackTimeout = null;
        }
    } catch (e) {}
    
    // Elimina cualquier timer previo
    back.querySelectorAll('.countdown-inline').forEach(el => el.remove());

    // Verificar si es la última tarjeta (tras marcar la actual como completada, remaining debe ser 0 si era la última)
    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
    const remainingCards = flashcards.filter((_, index) => !completedCards.has(index)).length;
    const isLastCard = remainingCards <= 0;

    // Crea el contenedor del timer
    const timerDiv = document.createElement('div');
    timerDiv.className = 'countdown-inline';
    const messageText = isLastCard ? 'Finalizando...' : 'Siguiente tarjeta en...';
    timerDiv.innerHTML = `
        <div class="countdown-inline-circle">
            <span class="countdown-inline-number">3</span>
        </div>
        <div class="countdown-inline-text">${messageText}</div>
    `;
    back.appendChild(timerDiv);

    let count = 3;
    const numberSpan = timerDiv.querySelector('.countdown-inline-number');

    // Fallback de seguridad: forzar avance si el contador no termina
    try {
        back._countdownFallbackTimeout = setTimeout(() => {
            try { timerDiv.remove(); } catch {}
            back._countdownFallbackTimeout = null;
            back._countdownRunning = false;
            console.log('⛑️ Fallback de countdown: avanzando a la siguiente tarjeta');
            goToNextCard();
        }, 5000);
    } catch (e) {}

    function updateCounter() {
        numberSpan.textContent = count;
        timerDiv.classList.remove('pulse-timer');
        void timerDiv.offsetWidth;
        timerDiv.classList.add('pulse-timer');
        if (count > 0) {
            count--;
            setTimeout(updateCounter, 1000);
        } else {
            timerDiv.remove();
            try {
                if (back._countdownFallbackTimeout) {
                    clearTimeout(back._countdownFallbackTimeout);
                    back._countdownFallbackTimeout = null;
                }
            } catch (e) {}
            back._countdownRunning = false;
            console.log('🏁 Countdown terminado: llamando goToNextCard()');
            goToNextCard();
        }
    }
    updateCounter();
}

function goToNextCard() {
    // Evitar flips accidentales por eventos residuales (tap/click) al avanzar
    // Bloquea momentáneamente el volteo hasta que termine la transición
    canFlip = false;
    // Cerrar cualquier teclado virtual activo y limpiar estados móviles
    try {
        const vkOverlay = document.getElementById('vk-overlay');
        const vk = document.getElementById('vk');
        if (vk && vkOverlay) {
            vk.classList.remove('show');
            vkOverlay.style.display = 'none';
        }
        // Clases globales de teclado/caret
        document.body.classList.remove('keyboard-visible');
        document.documentElement.classList.remove('keyboard-visible');
        document.body.classList.add('keyboard-hidden');
        document.documentElement.classList.add('keyboard-hidden');

    } catch (e) {}
    
    // Reactivar el botón de mezclar al pasar a la siguiente tarjeta
    document.getElementById('shuffle-button').disabled = false;

    // REPRODUCIR SONIDO DE NAIPE al cambiar de tarjeta
    document.getElementById('shuffleSound').play().catch(() => {});

    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
    completedCards.add(currentCardIndex);
    updateCardCounter();
    
    // GUARDAR PROGRESO AUTOMÁTICAMENTE al completar una tarjeta
    saveGameProgress();
    
    canFlipBack = true; // Permitir voltear en la nueva tarjeta
    updateCounters();
    voiceAttempts = 0; // Reiniciar intentos para la nueva tarjeta
    // Cancelar cualquier timeout entre intentos por seguridad
    if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
    if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }
    showingErrorMessage = false;
    lockedAfterSecondIncorrect = false;
    lockedAfterCorrect = false;

    // Buscar la siguiente tarjeta pendiente empezando DESPUÉS de la actual (búsqueda circular)
    const total = flashcards.length;
    let nextIndex = -1;
    for (let step = 1; step <= total; step++) {
        const i = (currentCardIndex + step) % total;
        if (!completedCards.has(i)) {
            nextIndex = i;
            break;
        }
    }
    
    if (nextIndex !== -1) {
        currentCardIndex = nextIndex;
        showCard(currentCardIndex);
        // Rehabilitar el volteo tras un pequeño retardo para evitar flip indeseado
        setTimeout(() => { canFlip = true; }, 300);
    } else {
        // Guardar porcentaje del último partido jugado
        saveLastGamePercentage();
        
        // Decidir qué función llamar según el resultado
        if (correctCount > incorrectCount) {
            // Verificar si es perfecto (sin errores)
            if (incorrectCount === 0) {
                showCompletionEuforiaMaxima(); // PERFECTO: sin errores
            } else {
                showCompletioneuforia(); // GANA: con algunos errores
            }
        } else if (incorrectCount > correctCount) {
            showCompletionPerdida(); // Perdió: mensaje motivacional
        } else {
            showCompletionEmpate(); // Empate: mensaje equilibrado
        }
        // En pantallas finales no necesitamos flip, pero por seguridad reactivamos
        setTimeout(() => { canFlip = true; }, 300);
    }
}

function showCard(index) {
    // Al mostrar una tarjeta (siempre front), forzar cierre del teclado virtual
    try {
        const vkOverlay = document.getElementById('vk-overlay');
        const vk = document.getElementById('vk');
        if (vk && vkOverlay) {
            vk.classList.remove('show');
            vkOverlay.style.display = 'none';
        }
        document.body.classList.remove('keyboard-visible');
        document.documentElement.classList.remove('keyboard-visible');
        document.body.classList.add('keyboard-hidden');
        document.documentElement.classList.add('keyboard-hidden');
    } catch (e) {}
    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
flashcards.forEach(card => {
    card.classList.remove('is-visible', 'flipped');
    const back = card.querySelector('.back');
    // Elimina cualquier contador de intentos
    back.querySelectorAll('.intentos-back').forEach(el => el.remove());
    if (card.dataset.answer) {
        back.innerHTML = card.dataset.answer;
    }
});

    if (flashcards[index]) {
        flashcards[index].classList.add('is-visible');
    }
    updateCounters();
    // Al mostrar una tarjeta, estamos en front: habilitar skip
    betweenAttempts = false;
    updateSkipButtonState();
}

function updateProgress() {
    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
    const totalCards = flashcards.length;
    const percentage = totalCards > 0 ? Math.round((completedCards.size / totalCards) * 100) : 0;
    const porcentajeDiv = document.getElementById('porcentaje-guardado');
    const porcentajeSpan = document.getElementById('current-percentage');
    if (porcentajeDiv && porcentajeSpan) {
        porcentajeSpan.textContent = `${percentage}%`;
    }
}

function updateCounters() {
    // Correctas
    const correctasPill = document.querySelector('.pill-correctas');
    const prevCorrect = Number(correctasPill.getAttribute('data-prev') || 0);
    document.getElementById('correctas-count').textContent = correctCount;

    if (correctCount > prevCorrect) {
        correctasPill.classList.remove('glow-correct');
        void correctasPill.offsetWidth; // Reinicia animación
        correctasPill.classList.add('glow-correct');
    }
    correctasPill.setAttribute('data-prev', correctCount);

    // Incorrectas
    const incorrectasPill = document.querySelector('.pill-incorrectas');
    const prevIncorrect = Number(incorrectasPill.getAttribute('data-prev') || 0);
    document.getElementById('incorrectas-count').textContent = incorrectCount;

    if (incorrectCount > prevIncorrect) {
        incorrectasPill.classList.remove('glow-error');
        void incorrectasPill.offsetWidth; // Reinicia animación
        incorrectasPill.classList.add('glow-error');
    }
    incorrectasPill.setAttribute('data-prev', incorrectCount);

    updateCardCounter();
}

function showCompletionEuforiaMaxima() {
    // LIMPIAR PROGRESO GUARDADO al completar el juego
    clearCurrentProgress();
    // Desactivar Mezclar en fin de juego
    try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch {}
    
    // Reproducir audio de victoria máxima
    const audioVictoriaMaxima = new Audio('https://fawzinoo.github.io/audios/victoriamaxima.mp3');
    audioVictoriaMaxima.play().catch(error => {
        console.log('Error al reproducir audio de victoria máxima:', error);
    });
    
    // Crear overlay que cubra toda la pantalla
    const fullScreenOverlay = document.createElement('div');
    fullScreenOverlay.id = 'euforia-maxima-overlay';
    fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(45deg, #FFD700 0%, #FFA500 25%, #FF4500 50%, #FF1493 75%, #9932CC 100%);
        background-size: 400% 400%;
        animation: rainbowBackground 3s ease infinite, perfectEntrance 1s ease-out;
    `;
    
    fullScreenOverlay.innerHTML = `
        <div id="trophy-container" style="font-size: 4rem; margin-bottom: 20px; animation: perfectExplosion 1.5s infinite;">🏆</div>
        <div style="font-size: 4rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255,255,255,1); animation: perfectShine 2s ease-in-out infinite;">
            ¡PERFECTO!
        </div>
        <div style="font-size: 2.5rem; margin-bottom: 10px; opacity: 0.95; animation: goldenGlow 2.5s ease-in-out infinite;">
            ¡Sin errores! ¡Eres increíble!
        </div>
        <div style="font-size: 1.8rem; opacity: 0.9; animation: diamondSpark 2s infinite;">
            ¡PUNTUACIÓN MÁXIMA!
        </div>
    `;
    
    // Añadir el overlay al body
    document.body.appendChild(fullScreenOverlay);
    
    // Efecto de confeti DOBLE para perfecto
    confetti({
        particleCount: 200,
        spread: 100,
        origin: { y: 0.4 }
    });
    
    // Segundo confeti con delay
    const confettiTimeoutId = setTimeout(() => {
        confetti({
            particleCount: 150,
            spread: 80,
            origin: { y: 0.7 }
        });
    }, 500);
    
    // DETENER la animación de la copa después de 3 segundos
    const trophyTimeoutId = setTimeout(() => {
        const trophyContainer = fullScreenOverlay.querySelector('#trophy-container');
        if (trophyContainer) {
            trophyContainer.style.animation = 'none';
        }
    }, 3000);
    
    // Permitir salto por clic o toque en cualquier parte
    let skipped = false;
    const clearAll = () => {
        if (skipped) return; skipped = true;
        try { audioVictoriaMaxima.pause(); audioVictoriaMaxima.currentTime = 0; } catch (e) {}
        try { clearTimeout(confettiTimeoutId); } catch (e) {}
        try { clearTimeout(trophyTimeoutId); } catch (e) {}
        if (typeof confetti === 'function' && typeof confetti.reset === 'function') {
            try { confetti.reset(); } catch (e) {}
        }
        if (fullScreenOverlay && fullScreenOverlay.parentNode) {
            fullScreenOverlay.remove();
        }
        document.removeEventListener('click', onSkip, true);
        document.removeEventListener('touchstart', onSkip, true);
    showCompletionMessage();
    };
    const onSkip = () => clearAll();
    document.addEventListener('click', onSkip, true);
    document.addEventListener('touchstart', onSkip, true);
    
    // Fallback automático
    const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
}

function showCompletioneuforia() {
    // LIMPIAR PROGRESO GUARDADO al completar el juego
    clearCurrentProgress();
    // Desactivar Mezclar en fin de juego
    try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch {}
    
    // Reproducir audio de victoria normal
    const audioVictoriaNormal = new Audio('https://fawzinoo.github.io/audios/victorianormal.mp3');
    audioVictoriaNormal.play().catch(error => {
        console.log('Error al reproducir audio de victoria normal:', error);
    });
    
    // Crear overlay que cubra toda la pantalla
    const fullScreenOverlay = document.createElement('div');
    fullScreenOverlay.id = 'euforia-overlay';
    fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #28a745 0%, #20c997 50%, #17a2b8 100%);
        animation: euforiaEntrance 0.8s ease-out;
    `;
    
    fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: celebrationBounce 1.2s infinite;">🥇</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: euforiaWiggle 1.5s ease-in-out infinite;">
            ¡FANTÁSTICO!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: happyFloat 2s ease-in-out infinite;">
            ¡Excelente resultado!
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: sparkle 1.8s infinite;">
            Calculando puntuación...
        </div>
    `;
    
    // Añadir el overlay al body
    document.body.appendChild(fullScreenOverlay);
    
    // Efecto de confeti normal
    confetti({
        particleCount: 150,
        spread: 70,
        origin: { y: 0.6 }
    });
    
    // Permitir salto por clic o toque en cualquier parte
    let skipped = false;
    const clearAll = () => {
        if (skipped) return; skipped = true;
        try { audioVictoriaNormal.pause(); audioVictoriaNormal.currentTime = 0; } catch (e) {}
        if (typeof confetti === 'function' && typeof confetti.reset === 'function') {
            try { confetti.reset(); } catch (e) {}
        }
        if (fullScreenOverlay && fullScreenOverlay.parentNode) {
            fullScreenOverlay.remove();
        }
        document.removeEventListener('click', onSkip, true);
        document.removeEventListener('touchstart', onSkip, true);
    showCompletionMessage();
    };
    const onSkip = () => clearAll();
    document.addEventListener('click', onSkip, true);
    document.addEventListener('touchstart', onSkip, true);
    
    const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
}

function showCompletionPerdida() {
    // LIMPIAR PROGRESO GUARDADO al completar el juego
    clearCurrentProgress();
    // Desactivar Mezclar en fin de juego
    try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch {}
    
    // Reproducir audio de derrota
    const audioDerrota = new Audio('https://fawzinoo.github.io/audios/derrota.mp3');
    audioDerrota.play().catch(error => {
        console.log('Error al reproducir audio de derrota:', error);
    });
    
    // Crear overlay que cubra toda la pantalla
    const fullScreenOverlay = document.createElement('div');
    fullScreenOverlay.id = 'perdida-overlay';
    fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 50%, #fd79a8 100%);
        animation: sadFadeIn 1s ease-in;
    `;
    
    fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: sadDrop 2s ease-out infinite;">😔</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: disappointedSway 2.5s ease-in-out infinite;">
            ¡A seguir practicando!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: gentleFloat 3s ease-in-out infinite;">
            La práctica hace al maestro
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: fadingHope 2.2s infinite;">
            Calculando resultados...
        </div>
    `;
    
    // Añadir el overlay al body
    document.body.appendChild(fullScreenOverlay);
    
    // NO hay confeti para perdida
    
    // Permitir salto por clic o toque en cualquier parte
    let skipped = false;
    const clearAll = () => {
        if (skipped) return; skipped = true;
        try { audioDerrota.pause(); audioDerrota.currentTime = 0; } catch (e) {}
        if (fullScreenOverlay && fullScreenOverlay.parentNode) {
            fullScreenOverlay.remove();
        }
        document.removeEventListener('click', onSkip, true);
        document.removeEventListener('touchstart', onSkip, true);
    showCompletionMessage();
    };
    const onSkip = () => clearAll();
    document.addEventListener('click', onSkip, true);
    document.addEventListener('touchstart', onSkip, true);
    
    const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
}

function showCompletionEmpate() {
    // LIMPIAR PROGRESO GUARDADO al completar el juego
    clearCurrentProgress();
    // Desactivar Mezclar en fin de juego
    try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch {}
    
    // Reproducir audio de empate (palpitaciones)
    const audioEmpate = new Audio('https://fawzinoo.github.io/audios/empate.mp3');
    audioEmpate.play().catch(error => {
        console.log('Error al reproducir audio de empate:', error);
    });
    
    // Crear overlay que cubra toda la pantalla
    const fullScreenOverlay = document.createElement('div');
    fullScreenOverlay.id = 'empate-overlay';
    fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #74b9ff 0%, #0984e3 50%, #6c5ce7 100%);
        animation: neutralZoom 0.6s ease-out;
    `;
    
    fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: balanceSway 2s ease-in-out infinite;">⚖️</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: steadyPulse 2s infinite;">
            ¡Empate perfecto!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: calmWave 2.5s ease-in-out infinite;">
            Resultado equilibrado
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: steadyGlow 2s infinite;">
            Analizando desempeño...
        </div>
    `;
    
    // Añadir el overlay al body
    document.body.appendChild(fullScreenOverlay);
    
    // NO hay confeti para empate
    
    // Permitir salto por clic o toque en cualquier parte
    let skipped = false;
    const clearAll = () => {
        if (skipped) return; skipped = true;
        try { audioEmpate.pause(); audioEmpate.currentTime = 0; } catch (e) {}
        if (fullScreenOverlay && fullScreenOverlay.parentNode) {
            fullScreenOverlay.remove();
        }
        document.removeEventListener('click', onSkip, true);
        document.removeEventListener('touchstart', onSkip, true);
    showCompletionMessage();
    };
    const onSkip = () => clearAll();
    document.addEventListener('click', onSkip, true);
    document.addEventListener('touchstart', onSkip, true);
    
    const finishTimeoutId = setTimeout(() => { clearAll(); }, 9000);
}
function showCompletionMessage() {
    
    const container = document.getElementById('flashcard-container');
    // Mantener Mezclar desactivado en la pantalla final
    try { const sb = document.getElementById('shuffle-button'); if (sb) sb.disabled = true; } catch {}
    
    if (correctCount > incorrectCount) {
        if (incorrectCount === 0) {
            // CASO 1A: Victoria PERFECTA (sin errores) - Diseño moderno dorado/negro
            container.innerHTML = `
                <div style="
                    display: flex; 
                    flex-direction: column; 
                    justify-content: center; 
                    align-items: center; 
                    height: 100%; 
                    color: white; 
                    text-align: center;
                    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #1a1a1a 100%);
                    border-radius: 25px;
                    position: relative;
                    overflow: hidden;
                    border: 2px solid #FFD700;
                ">
                    <div style="
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: radial-gradient(circle at 30% 20%, rgba(255,215,0,0.1) 0%, transparent 50%),
                                    radial-gradient(circle at 70% 80%, rgba(255,215,0,0.05) 0%, transparent 50%);
                    "></div>
                    
                    <div id="final-trophy" style="font-size: 4rem; margin-bottom: 30px; animation: perfectExplosion 2s infinite; filter: drop-shadow(0 0 20px #FFD700);">🏆</div>
                    
                    <div style="
                        background: linear-gradient(135deg, rgba(26,26,26,0.95) 0%, rgba(45,45,45,0.95) 100%);
                        padding: 25px 35px;
                        border-radius: 20px;
                        backdrop-filter: blur(20px);
                        border: 1px solid rgba(255,215,0,0.3);
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 0 20px rgba(255,215,0,0.1);
                        margin-bottom: 20px;
                        width: 280px;
                    ">
                        <div style="font-size: 1.1rem; margin-bottom: 20px; color: #FFD700; font-weight: 600; letter-spacing: 1px;">
                            ⭐ PUNTUACIÓN MÁXIMA ⭐
                        </div>
                        <div id="correct-words-btn" style="
                            font-size: 1.1rem; 
                            color: #ffffff; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(0,200,81,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                            font-weight: 500;
                            animation: pulse 2s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                            ✅ Correctas: ${correctCount} (Ver)
                        </div>
                        <div style="
                            font-size: 1.1rem; 
                            color: white; 
                            opacity: 0.7; 
                            font-weight: 500;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, rgba(136,136,136,0.2) 0%, rgba(136,136,136,0.1) 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(136,136,136,0.3);
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        ">
                            ❌ Incorrectas: ${incorrectCount}
                        </div>
                        <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #FFD700; font-weight: 400; text-align: center;">
                            Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                        </div>
                    </div>
                </div>
            `;
        } else {
            // CASO 1B: Victoria NORMAL - Diseño moderno azul/gris
            container.innerHTML = `
                <div style="
                    display: flex; 
                    flex-direction: column; 
                    justify-content: center; 
                    align-items: center; 
                    height: 100%; 
                    color: white; 
                    text-align: center;
                    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
                    border-radius: 25px;
                    position: relative;
                    overflow: hidden;
                    border: 2px solid #4FC3F7;
                ">
                    <div style="
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: radial-gradient(circle at 30% 20%, rgba(79,195,247,0.1) 0%, transparent 50%),
                                    radial-gradient(circle at 70% 80%, rgba(79,195,247,0.05) 0%, transparent 50%);
                    "></div>
                    
                    <div id="celebration-emoji" style="font-size: 4rem; margin-bottom: 30px; animation: perfectExplosion 2s infinite; filter: drop-shadow(0 0 20px #4FC3F7);">🥇</div>
                    
                    <div style="
                        background: linear-gradient(135deg, rgba(30,60,114,0.95) 0%, rgba(42,82,152,0.95) 100%);
                        padding: 25px 35px;
                        border-radius: 20px;
                        backdrop-filter: blur(20px);
                        border: 1px solid rgba(79,195,247,0.3);
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 0 20px rgba(79,195,247,0.1);
                        margin-bottom: 20px;
                        width: 280px;
                    ">
                        <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡ENHORABUENA!
                        </div>
                         <div id="correct-words-btn" style="
                            font-size: 1.1rem; 
                            color: #ffffff; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(0,200,81,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                            font-weight: 500;
                            animation: alternatePulse 4s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                            ✅ Correctas: ${correctCount} (Ver)
                        </div>
                        <div id="incorrect-words-btn" style="
                              font-size: 1.1rem; 
                            color: white; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(255,87,34,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                            font-weight: 500;
                            animation: alternatePulseIncorrect 4s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                            ❌ Incorrectas: ${incorrectCount} (Ver)
                        </div>
                        <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #B0BEC5; font-weight: 400; text-align: center;">
                            Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                        </div>
                    </div>
                </div>
            `;
        }
    } else if (incorrectCount > correctCount) {
        // CASO 2: Pérdida - Diseño moderno púrpura/gris
        container.innerHTML = `
            <div style="
                display: flex; 
                flex-direction: column; 
                justify-content: center; 
                align-items: center; 
                height: 100%; 
                color: white; 
                text-align: center;
                background: linear-gradient(135deg, #4A148C 0%, #6A1B9A 50%, #4A148C 100%);
                border-radius: 25px;
                position: relative;
                overflow: hidden;
                border: 2px solid #BA68C8;
            ">
                <div style="font-size: 4rem; margin-bottom: 25px; filter: drop-shadow(0 0 15px #BA68C8);">😔</div>
              
               
                <div style="
                    background: linear-gradient(135deg, rgba(74,20,140,0.95) 0%, rgba(106,27,154,0.95) 100%);
                    padding: 20px 30px;
                    border-radius: 18px;
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(186,104,200,0.3);
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    width: 280px;
                ">
                 <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡A SEGUIR PRACTICANDO!
                        </div>
                    <div id="correct-words-btn" style="
                        font-size: 1.1rem; 
                        margin-bottom: 12px;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(0,200,81,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                        font-weight: 500;
                        animation: alternatePulse 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                        ✅ Correctas: ${correctCount} (Ver)
                    </div>
                    <div id="incorrect-words-btn" style="
                        font-size: 1.1rem;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(255,87,34,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                        font-weight: 500;
                        animation: alternatePulseIncorrect 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                        ❌ Incorrectas: ${incorrectCount} (Ver)
                    </div>
                    <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #BA68C8; font-weight: 400; text-align: center;">
                        Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                    </div>
                </div>
            </div>
        `;
    } else {
        // CASO 3: Empate - Diseño moderno gris/plateado
        container.innerHTML = `
            <div style="
                display: flex; 
                flex-direction: column; 
                justify-content: center; 
                align-items: center; 
                height: 100%; 
                color: white; 
                text-align: center;
                background: linear-gradient(135deg, #37474F 0%, #546E7A 50%, #37474F 100%);
                border-radius: 25px;
                position: relative;
                overflow: hidden;
                border: 2px solid #90A4AE;
            ">
                <div style="font-size: 4rem; margin-bottom: 25px; filter: drop-shadow(0 0 15px #90A4AE);">⚖️</div>
             
               
                <div style="
                    background: linear-gradient(135deg, rgba(55,71,79,0.95) 0%, rgba(84,110,122,0.95) 100%);
                    padding: 20px 30px;
                    border-radius: 18px;
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(144,164,174,0.3);
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    width: 280px;
                ">
                   <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡EMPATE PERFECTO!
                        </div>
                      <div id="correct-words-btn" style="
                        font-size: 1.1rem; 
                        margin-bottom: 12px;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(0,200,81,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                        font-weight: 500;
                        animation: alternatePulse 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                        ✅ Correctas: ${correctCount} (Ver)
                    </div>
                    <div id="incorrect-words-btn" style="
                        font-size: 1.1rem;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(255,87,34,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                        font-weight: 500;
                        animation: alternatePulseIncorrect 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                        ❌ Incorrectas: ${incorrectCount} (Ver)
                    </div>
                    <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #90A4AE; font-weight: 400; text-align: center;">
                        Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                    </div>
                </div>
            </div>
        `;
    }

    // DETENER SOLO las animaciones del fondo y elementos decorativos después de 3 segundos
    // PERO MANTENER la animación pulse del botón verde
    setTimeout(() => {
        const finalTrophy = document.getElementById('final-trophy');
        const celebrationEmoji = document.getElementById('celebration-emoji');
        const containerDiv = container.firstElementChild;
        
        if (finalTrophy) finalTrophy.style.animation = 'none';
        if (celebrationEmoji) celebrationEmoji.style.animation = 'none';
        if (containerDiv) containerDiv.style.animation = 'none';
        
        // ⭐ NO detener la animación pulse del botón verde
        // Línea eliminada: if (correctBtn) correctBtn.style.animation = 'none';
    }, 3000);

    // AÑADIR EVENT LISTENERS para los botones clicables
    setTimeout(() => {
        const correctBtn = document.getElementById('correct-words-btn');
        const incorrectBtn = document.getElementById('incorrect-words-btn');

        if (correctBtn) {
            correctBtn.addEventListener('click', function() {
                vibrar(50);
                playButtonSound();
                showCorrectWords();
            });
        }
        
        if (incorrectBtn) {
            incorrectBtn.addEventListener('click', function() {
                vibrar(50);
                playButtonSound();
                showIncorrectWords();
            });
        }
    }, 100);

}

// Función para mostrar palabras correctas
function showCorrectWords() {
    const overlay = document.createElement('div');
    overlay.id = 'correct-words-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;
    
    const wordsHtml = correctWords.length > 0 
        ? correctWords.map(word => `
            <div class="word-card correct-word" onclick="vibrar(50); playButtonSound(); showItemImage('${word}')">
                <span class="word-text">${word}</span>
                <div class="word-checkmark">✓</div>
            </div>
        `).join('')
        : '<div class="no-words-message"><span class="no-words-icon">🎯</span><p>No hay palabras acertadas</p></div>';
    
    overlay.innerHTML = `
        <div class="modal-container correct-modal">
            <div class="modal-header">
                <div class="modal-title-row">
                    <h2 class="modal-title">Palabras Acertadas</h2>
                </div>
                <div class="modal-stats">${correctWords.length} ${correctWords.length === 1 ? 'palabra' : 'palabras'}</div>
            </div>
            
            <div class="modal-content">
                <div class="words-container">
                    ${wordsHtml}
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="modal-close-btn correct-btn" onclick="vibrar(50); playButtonSound(); document.getElementById('correct-words-overlay').remove()">
                    <span>Cerrar</span>
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Cerrar modal al hacer clic en el fondo
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            vibrar(50);
            playButtonSound();
            overlay.remove();
        }
    });
}

// Función para mostrar palabras incorrectas
function showIncorrectWords() {
    const overlay = document.createElement('div');
    overlay.id = 'incorrect-words-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;
    
    const wordsHtml = incorrectWords.length > 0 
        ? incorrectWords.map(word => `
            <div class="word-card incorrect-word" onclick="vibrar(50); playButtonSound(); showItemImage('${word}')">
                <span class="word-text">${word}</span>
                <div class="word-checkmark">✗</div>
            </div>
        `).join('')
        : '<div class="no-words-message"><span class="no-words-icon">🎯</span><p>No hay palabras incorrectas</p></div>';
    
    overlay.innerHTML = `
        <div class="modal-container incorrect-modal">
            <div class="modal-header">
                <div class="modal-title-row">
                    <h2 class="modal-title">Palabras Incorrectas</h2>
                </div>
                <div class="modal-stats">${incorrectWords.length} ${incorrectWords.length === 1 ? 'palabra' : 'palabras'}</div>
            </div>
            
            <div class="modal-content">
                <div class="words-container">
                    ${wordsHtml}
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="modal-close-btn incorrect-btn" onclick="vibrar(50); playButtonSound(); document.getElementById('incorrect-words-overlay').remove()">
                    <span>Cerrar</span>
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Cerrar modal al hacer clic en el fondo
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            vibrar(50);
            playButtonSound();
            overlay.remove();
        }
    });
}

// Variables para rastrear palabras correctas e incorrectas
let correctWords = [];
let incorrectWords = [];

// ============ SISTEMA DE PERSISTENCIA DE PROGRESO ============
// Función para guardar el progreso actual en localStorage
function saveGameProgress() {
    const gameState = {
        currentCardIndex: currentCardIndex,
        completedCards: Array.from(completedCards),
        correctCount: correctCount,
        incorrectCount: incorrectCount,
        correctWords: [...correctWords],
        incorrectWords: [...incorrectWords],
        voiceAttempts: voiceAttempts,
        timestamp: Date.now(),
        cardOrder: flashcards.map(card => ({
            frontImg: card.querySelector('.front img').src,
            frontAlt: card.querySelector('.front img').alt,
            backText: card.dataset.answer
        }))
    };
    
    try {
        const stateString = JSON.stringify(gameState);
        localStorage.setItem('profesiones11_gameProgress', stateString); // ✅ Cambiado de profesiones11_gameProgress
        console.log(`✅ Progreso guardado automáticamente. voiceAttempts: ${voiceAttempts}`);
    } catch (error) {
        if (error.name === 'QuotaExceededError') {
            console.warn('⚠️ LocalStorage lleno, limpiando datos antiguos del tema actual...');
            clearOldThemeData();
            
            try {
                localStorage.setItem('profesiones11_gameProgress', JSON.stringify(gameState)); // ✅ Cambiado
                console.log('✅ Progreso guardado después de limpiar datos del tema');
            } catch (secondError) {
                console.error('❌ Error persistente al guardar progreso:', secondError);
                const minimalState = {
                    currentCardIndex: currentCardIndex,
                    completedCards: Array.from(completedCards),
                    correctCount: correctCount,
                    incorrectCount: incorrectCount,
                    voiceAttempts: voiceAttempts,
                    timestamp: Date.now()
                };
                try {
                    localStorage.setItem('profesiones11_gameProgress', JSON.stringify(minimalState)); // ✅ Cambiado
                    console.log('✅ Progreso mínimo guardado exitosamente');
                } catch (finalError) {
                    console.error('💥 No se pudo guardar ningún progreso:', finalError);
                }
            }
        } else {
            console.error('❌ Error inesperado al guardar progreso:', error);
        }
    }
}

// Nueva función que SOLO limpia datos del tema actual, respeta otros temas
function clearOldThemeData() {
    console.log('🧹 Limpiando datos antiguos SOLO del tema actual...');
    
    // ✅ Claves estandarizadas con profesiones11
    const currentThemeKeys = [
        'profesiones11_gameProgress',       // progreso actual del tema
        'profesiones11',                    // último resultado del tema (ya correcto)
        'profesiones11Date',                // fecha del último resultado (ya correcto)
    ];
    
    const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    
    currentThemeKeys.forEach(key => {
        const data = localStorage.getItem(key);
        if (data) {
            try {
                if (key.includes('gameProgress')) {
                    const parsed = JSON.parse(data);
                    if (parsed.timestamp && parsed.timestamp < weekAgo) {
                        localStorage.removeItem(key);
                        console.log(`🗓️ Eliminado progreso antiguo: ${key}`);
                    }
                }
                else if (key.includes('Date')) {
                    const date = new Date(data);
                    if (date.getTime() < weekAgo) {
                        const associatedKey = key.replace('Date', '');
                        localStorage.removeItem(key);
                        localStorage.removeItem(associatedKey);
                        console.log(`🗓️ Eliminados datos antiguos: ${key}, ${associatedKey}`);
                    }
                }
            } catch (e) {
                if (key === 'profesiones11_gameProgress') { // ✅ Cambiado
                    localStorage.removeItem(key);
                    console.log(`🔧 Eliminados datos corruptos: ${key}`);
                }
            }
        }
    });
    
    // Limpiar datos temporales/cache genéricos (seguros de eliminar)
    const safeToClearPatterns = [
        /^temp_/,
        /^cache_/,
        /^session_/,
        /^tmp_/,
    ];
    
    const allKeys = [];
    for (let i = 0; i < localStorage.length; i++) {
        allKeys.push(localStorage.key(i));
    }
    
    let clearedGeneric = 0;
    allKeys.forEach(key => {
        if (key && safeToClearPatterns.some(pattern => pattern.test(key))) {
            localStorage.removeItem(key);
            clearedGeneric++;
        }
    });
    
    if (clearedGeneric > 0) {
        console.log(`🗑️ Eliminadas ${clearedGeneric} entradas temporales genéricas`);
    }
    
    console.log('✅ Limpieza completada - otros temas preservados');
}

function clearOldStorageData() {
    console.log('🧹 Limpiando localStorage...');
    
    // Lista de claves a mantener (datos importantes) - actualizada con profesiones11
    const keepKeys = [
        'profesiones11_gameProgress',      // ✅ Cambiado
        'lastSuccessPercentage',
        'lastUpdateDate',
        'profesiones11',                   // ✅ Ya correcto
        'profesiones11Date',               // ✅ Ya correcto
        'microphonePermissionGranted'
    ];
    
    // Obtener todas las claves y eliminar las que no son esenciales
    const allKeys = [];
    for (let i = 0; i < localStorage.length; i++) {
        allKeys.push(localStorage.key(i));
    }
    
    let clearedItems = 0;
    allKeys.forEach(key => {
        if (key && !keepKeys.includes(key)) {
            localStorage.removeItem(key);
            clearedItems++;
        }
    });
    
    console.log(`🗑️ Eliminadas ${clearedItems} entradas antiguas de localStorage`);
    
    // Si todavía hay problemas, optimizar los datos que sí guardamos
    if (clearedItems === 0) {
        console.log('🔧 Optimizando datos existentes...');
        
        // Eliminar datos de progreso muy antiguos (más de 7 días)
        const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
        const savedProgress = localStorage.getItem('profesiones11_gameProgress'); // ✅ Cambiado
        
        if (savedProgress) {
            try {
                const data = JSON.parse(savedProgress);
                if (data.timestamp && data.timestamp < weekAgo) {
                    localStorage.removeItem('profesiones11_gameProgress'); // ✅ Cambiado
                    console.log('🗓️ Eliminado progreso muy antiguo');
                }
            } catch (e) {
                // Si hay datos corruptos, eliminarlos
                localStorage.removeItem('profesiones11_gameProgress'); // ✅ Cambiado
                console.log('🔧 Eliminados datos corruptos');
            }
        }
    }
}

// Función para cargar el progreso desde localStorage
function loadGameProgress() {
    const savedState = localStorage.getItem('profesiones11_gameProgress'); // ✅ Cambiado
    if (!savedState) return null;
    
    try {
        const parsedState = JSON.parse(savedState);
        const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
        if (parsedState.timestamp && parsedState.timestamp < weekAgo) {
            console.log('🗓️ Progreso guardado muy antiguo, ignorando...');
            localStorage.removeItem('profesiones11_gameProgress'); // ✅ Cambiado
            return null;
        }
        return parsedState;
    } catch (error) {
        console.error('❌ Error al cargar progreso guardado:', error);
        localStorage.removeItem('profesiones11_gameProgress'); // ✅ Cambiado
        return null;
    }
}

// Función para restaurar el estado del juego
function restoreGameState(gameState) {
    if (!gameState) return false;
    
    try {
        // Restaurar variables de estado
        currentCardIndex = gameState.currentCardIndex || 0;
        completedCards = new Set(gameState.completedCards || []);
        correctCount = gameState.correctCount || 0;
        incorrectCount = gameState.incorrectCount || 0;
        correctWords = [...(gameState.correctWords || [])];
        incorrectWords = [...(gameState.incorrectWords || [])];
        voiceAttempts = gameState.voiceAttempts || 0;
        
        // Restaurar orden de tarjetas si existe
        if (gameState.cardOrder && gameState.cardOrder.length === flashcards.length) {
            flashcards.forEach((card, index) => {
                const cardData = gameState.cardOrder[index];
                if (cardData) {
                    card.querySelector('.front img').src = cardData.frontImg;
                    card.querySelector('.front img').alt = cardData.frontAlt;
                    const back = card.querySelector('.back');
                    back.innerHTML = cardData.backText;
                    card.dataset.answer = cardData.backText;
                }
            });
        }
        
        // Reasignar audios a cada tarjeta según su respuesta (por si el orden se cambió)
        reassignAudiosToCards();

        // IMPORTANTE: Resetear el estado de las tarjetas al restaurar
        flashcards.forEach(card => {
            card.classList.remove('is-visible', 'flipped');
            const back = card.querySelector('.back');
            // Limpiar cualquier indicador de escucha previo
            back.querySelectorAll('.listening-indicator').forEach(el => el.remove());
            back.classList.remove('hidden-text');
        });
        
        // Si el índice actual apunta a una tarjeta ya completada, avanzar a la primera pendiente empezando desde la siguiente (circular)
        try {
            const total = flashcards.length;
            if (total > 0 && completedCards.has(currentCardIndex)) {
                for (let step = 1; step <= total; step++) {
                    const i = (currentCardIndex + step) % total;
                    if (!completedCards.has(i)) { currentCardIndex = i; break; }
                }
            }
        } catch (e) {}

        // Actualizar interfaz
        updateCounters();
        updateCardCounter();
        updateSuccessPercentage();
        
        // Mostrar tarjeta actual
        showCard(currentCardIndex);
        
        console.log('Estado del juego restaurado exitosamente');
        console.log(`Restaurado: voiceAttempts=${voiceAttempts}, currentCardIndex=${currentCardIndex}, correctCount=${correctCount}, incorrectCount=${incorrectCount}`);
        return true;
    } catch (error) {
        console.error('Error al restaurar estado del juego:', error);
        return false;
    }
}

// Función para limpiar solo el progreso actual (mantener avance anterior)
function clearCurrentProgress() {
    localStorage.removeItem('profesiones11_gameProgress');
    console.log('Progreso actual limpiado');
}

// Función para verificar si hay progreso guardado Y el juego NO está completado
function hasProgressSaved() {
    const savedState = loadGameProgress();
    if (!savedState) return false;
    
    // Verificar si el juego está completado
    const totalCards = flashcards.length;
    const completedCount = savedState.completedCards ? savedState.completedCards.length : 0;
    const isGameCompleted = completedCount >= totalCards;
    
    // Si el juego está completado, NO mostrar modal de continuación
    if (isGameCompleted) {
        console.log('Juego completado detectado, limpiando progreso y reiniciando');
        // Marcar que se permite usar "Reiniciar" solo en este momento/post-carga
        try { sessionStorage.setItem('resetAllowedCompletedSavedGame', 'true'); } catch (e) {}
        clearCurrentProgress();
        return false;
    }
    
    // Verificar si hay progreso significativo (al menos una tarjeta completada o un intento)
    const hasProgress = (savedState.completedCards && savedState.completedCards.length > 0) ||
                       (savedState.correctCount > 0) ||
                       (savedState.incorrectCount > 0) ||
                       (savedState.voiceAttempts > 0);
    
    return hasProgress;
}

// Función para mostrar el modal de continuación
function showContinueGameModal() {
    const savedState = loadGameProgress();
    if (!savedState) return;
    
    const totalCards = flashcards.length;
    const completedCount = savedState.completedCards ? savedState.completedCards.length : 0;
    const remaining = totalCards - completedCount;
    const correctCount = savedState.correctCount || 0;
    const incorrectCount = savedState.incorrectCount || 0;
    
    const overlay = document.createElement('div');
    overlay.className = 'continue-game-overlay';
    overlay.id = 'continue-game-overlay';
    
    overlay.innerHTML = `
        <div class="continue-game-modal">
            <div class="continue-modal-header">
                <span class="continue-modal-icon">🎯</span>
                <h2 class="continue-modal-title">¡Progreso Detectado!</h2>
                <p class="continue-modal-subtitle">Tienes un juego en progreso</p>
            </div>
            
            <div class="continue-modal-content">
                <div class="continue-progress-info">
                    <div class="continue-progress-title">Tu progreso actual:</div>
                    <div class="continue-progress-stats">
                        <div class="continue-stat-item">
                            <div class="continue-stat-number correct">${correctCount}</div>
                            <div class="continue-stat-label">Correctas</div>
                        </div>
                        <div class="continue-stat-item">
                            <div class="continue-stat-number incorrect">${incorrectCount}</div>
                            <div class="continue-stat-label">Incorrectas</div>
                        </div>
                        <div class="continue-stat-item">
                            <div class="continue-stat-number remaining">${remaining}</div>
                            <div class="continue-stat-label">Restantes</div>
                        </div>
                    </div>
                </div>
                
                <div class="continue-modal-buttons">
                    <button class="continue-btn continue-btn-primary" id="continue-game-btn">
                        <i class="fas fa-play"></i>
                        Continuar
                    </button>
                    <button class="continue-btn continue-btn-secondary" id="start-fresh-btn">
                        <i class="fas fa-sync-alt"></i>
                        Empezar de Cero
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Event listeners para los botones
    const continueBtn = overlay.querySelector('#continue-game-btn');
    const startFreshBtn = overlay.querySelector('#start-fresh-btn');
    
    continueBtn.addEventListener('click', function() {
        vibrar(60);
        playButtonSound();
        
        // Restaurar el estado del juego
        if (restoreGameState(savedState)) {
            overlay.remove();
            console.log('Juego continuado desde el progreso guardado');
        } else {
            console.error('Error al restaurar el juego, empezando de cero');
            clearCurrentProgress();
            overlay.remove();
            initializeNewGame();
        }
    });
    
    startFreshBtn.addEventListener('click', function() {
        vibrar(60);
        playButtonSound();
        
        // Limpiar progreso actual pero mantener avance anterior
        clearCurrentProgress();
        overlay.remove();
        initializeNewGame();
        console.log('Nuevo juego iniciado');
    });
    
    // Cerrar modal al hacer clic en el fondo (por defecto continúa)
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            vibrar(40);
            // Por defecto continuar el juego
            if (restoreGameState(savedState)) {
                overlay.remove();
            }
        }
    });
}

// Función para inicializar un nuevo juego
function initializeNewGame() {
    // Resetear todas las variables
    currentCardIndex = 0;
    voiceAttempts = 0;
    completedCards.clear();
    correctWords.length = 0;
    incorrectWords.length = 0;
    correctCount = 0;
    incorrectCount = 0;
    canFlipBack = true;
    canFlip = true;
    shuffleClickCount = 0; // Restablecer usos de Mezclar al iniciar partida
    try { localStorage.removeItem('profesiones11_shuffleCount'); } catch (e) {}
    
    // Mezclar tarjetas
    shuffleCards();
    
    // Actualizar interfaz
    updateCounters();
    updateCardCounter();
    
    // Mostrar primera tarjeta
    showCard(0);
}

// Mapeo de países a códigos de bandera
const countryFlags = {
    'España': 'es',
    'Marruecos': 'ma', 
    'México': 'mx',
    'Argentina': 'ar',
    'Francia': 'fr',
    'Italia': 'it',
    'Alemania': 'de',
    'Brasil': 'br',
    'Chile': 'cl',
    'Peru': 'pe',
    'Colombia': 'co',
    'Portugal': 'pt',
    'Grecia': 'gr',
    'Turquía': 'tr',
    'Japón': 'jp',
    'China': 'cn',
    'India': 'in',
    'Rusia': 'ru',
    'Canadá': 'ca',
    'Australia': 'au'
};

// Helper: normalizar nombre de país (minúsculas, sin tildes, trim)
function normalizeCountryKey(str) {
    return (str || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/\p{Diacritic}+/gu, '') // quitar acentos
        .trim();
}

// Índice normalizado para lookup robusto (soporta con/sin acentos)
const countryFlagsByKey = {};
Object.keys(countryFlags).forEach(name => {
    countryFlagsByKey[normalizeCountryKey(name)] = countryFlags[name];
});

// Variable global para el overlay de bandera
let currentFlagOverlay = null;

// Base opcional para imágenes genéricas (png/jpg/webp). Puedes cambiar esta URL.
const baseImagesUrl = 'https://fawzinoo.github.io/Fotos/';

// Mostrar imagen genérica o bandera si existe
function showItemImage(name) {
    const candidates = [];
    const key = normalizeAudioKey(name); // minúsculas, sin tildes, con guiones

    // 1) Preferir la imagen actual de la tarjeta (front) si existe
    try {
        const match = flashcards.find(card => {
            const ans = card.dataset.answer || (card.querySelector('.back')?.textContent?.trim() || '');
            return normalizeAudioKey(ans) === key;
        });
        const frontSrc = match?.querySelector('.front img')?.src;
        if (frontSrc) candidates.push(frontSrc);
    } catch (e) {}

    // 2) Intentar recursos locales/genéricos por nombre normalizado en varios formatos
    ['png','jpg','jpeg','webp'].forEach(ext => {
        candidates.push(`${baseImagesUrl}${key}.${ext}`);
    });

    // 3) Finalmente, bandera si hay código conocido
    const code = countryFlags[name] || countryFlagsByKey[normalizeCountryKey(name)];
    if (code) {
        candidates.push(`https://flagcdn.com/w640/${code}.png`);
    }
    
    // Función para probar en cadena hasta cargar una
    const tryNext = (idx) => {
        if (idx >= candidates.length) {
            // Fallback: imagen inline de no disponible
            openImageModal('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+');
            return;
        }
        const url = candidates[idx];
        const testImg = new Image();
        testImg.onload = () => openImageModal(url, name);
        testImg.onerror = () => tryNext(idx + 1);
        testImg.src = url;
    };
    tryNext(0);
}

function openImageModal(src, name = '') {
    // Cerrar anterior si existe
    if (currentFlagOverlay) { currentFlagOverlay.remove(); currentFlagOverlay = null; }
    const overlay = document.createElement('div');
    overlay.id = 'flag-modal-overlay';
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
        display: flex; justify-content: center; align-items: center;
        z-index: 15000; opacity: 0; animation: fadeInOverlay 0.3s ease-out forwards;`;
    currentFlagOverlay = overlay;
    overlay.innerHTML = `
        <div class="flag-card-container">
            <div class="flag-controls-floating">
                <button class="flag-control-btn fullscreen-btn" title="Pantalla completa"> 
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
                </button>
                <button class="flag-control-btn restore-btn" title="Restituir" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                </button>
                <button class="flag-control-btn close-btn" title="Cerrar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div class="flag-card-body-full">
                <img id="flag-image" src="${src}" alt="${name ? 'Imagen de '+name : 'Imagen'}" class="flag-display" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+'" />
            </div>
        </div>`;
    document.body.appendChild(overlay);
    const fullscreenBtn = overlay.querySelector('.fullscreen-btn');
    const restoreBtn = overlay.querySelector('.restore-btn');
    const closeBtn = overlay.querySelector('.close-btn');
    if (fullscreenBtn) fullscreenBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); toggleFullscreen(); });
    if (restoreBtn) restoreBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); exitFullscreen(); });
    if (closeBtn) closeBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); closeFlagModal(); });
    overlay.addEventListener('click', (e) => { if (e.target === overlay) { vibrar(50); playButtonSound(); closeFlagModal(); }});
}

// Función para mostrar la bandera del país
function showCountryFlag(countryName) {
    // Cerrar overlay anterior si existe
    if (currentFlagOverlay) {
        currentFlagOverlay.remove();
        currentFlagOverlay = null;
    }
    
    // Buscar por clave exacta o clave normalizada (para soportar tildes)
    const flagCode = countryFlags[countryName] || countryFlagsByKey[normalizeCountryKey(countryName)];
    if (!flagCode) {
        console.log(`No se encontró código de bandera para: ${countryName}`);
        return;
    }
    
    const flagUrl = `https://flagcdn.com/w640/${flagCode}.png`;
    
    const overlay = document.createElement('div');
    overlay.id = 'flag-modal-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 15000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;
    
    // Guardar referencia global
    currentFlagOverlay = overlay;
    
    overlay.innerHTML = `
        <div class="flag-card-container">
            <div class="flag-controls-floating">
                <button class="flag-control-btn fullscreen-btn" title="Pantalla completa">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                    </svg>
                </button>
                <button class="flag-control-btn restore-btn" title="Restituir" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <button class="flag-control-btn close-btn" title="Cerrar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="flag-card-body-full">
                <img id="flag-image" src="${flagUrl}" alt="Bandera de ${countryName}" class="flag-display" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+'" />
            </div>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Agregar event listeners después de crear el HTML
    const fullscreenBtn = overlay.querySelector('.fullscreen-btn');
    const restoreBtn = overlay.querySelector('.restore-btn');
    const closeBtn = overlay.querySelector('.close-btn');
    
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', function() {
            vibrar(50);
            playButtonSound();
            toggleFullscreen();
        });
    }
    
    if (restoreBtn) {
        restoreBtn.addEventListener('click', function() {
            vibrar(50);
            playButtonSound();
            exitFullscreen();
        });
    }
    
    if (closeBtn) {
        closeBtn.addEventListener('click', function() {
            vibrar(50);
            playButtonSound();
            closeFlagModal();
        });
    }
    
    // Cerrar modal al hacer clic en el fondo
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            vibrar(50);
            playButtonSound();
            closeFlagModal();
        }
    });
}

// Funciones para pantalla completa
function toggleFullscreen() {
    if (!currentFlagOverlay) return;
    
    const flagContainer = currentFlagOverlay.querySelector('.flag-card-container');
    const fullscreenBtn = currentFlagOverlay.querySelector('.fullscreen-btn');
    const restoreBtn = currentFlagOverlay.querySelector('.restore-btn');
    
    if (!flagContainer || !fullscreenBtn || !restoreBtn) return;
    
    // Añadir clase para pantalla completa
    flagContainer.classList.add('fullscreen-mode');
    
    // Cambiar visibilidad de botones
    fullscreenBtn.style.display = 'none';
    restoreBtn.style.display = 'flex';
    
    // Aplicar estilos de pantalla completa al contenedor
    flagContainer.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        max-width: none !important;
        max-height: none !important;
        z-index: 20000 !important;
        border-radius: 0 !important;
        border: none !important;
        background: linear-gradient(to right, #1f3658, #3558e3) !important;
        display: flex !important;
        flex-direction: column !important;
        overflow: hidden !important;
        animation: expandToFullscreen 0.3s ease-out !important;
    `;
    
    // Ocultar el overlay de fondo
    currentFlagOverlay.style.background = 'transparent';
}

function exitFullscreen() {
    if (!currentFlagOverlay) return;
    
    const flagContainer = currentFlagOverlay.querySelector('.flag-card-container');
    const fullscreenBtn = currentFlagOverlay.querySelector('.fullscreen-btn');
    const restoreBtn = currentFlagOverlay.querySelector('.restore-btn');
    
    if (!flagContainer || !fullscreenBtn || !restoreBtn) return;
    
    // Remover clase de pantalla completa
    flagContainer.classList.remove('fullscreen-mode');
    
    // Cambiar visibilidad de botones
    fullscreenBtn.style.display = 'flex';
    restoreBtn.style.display = 'none';
    
    // Restaurar estilos originales del contenedor
    flagContainer.style.cssText = `
        width: 100%;
        height: 500px;
        max-height: 500px;
        max-width: 400px;
        background: linear-gradient(to right, #1f3658, #3558e3);
        border-radius: 25px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        border: 3px solid #aab0b4;
        overflow: hidden;
        position: relative;
        animation: slideInModal 0.4s ease-out;
        display: flex;
        flex-direction: column;
    `;
    
    // Restaurar el overlay de fondo
    currentFlagOverlay.style.background = 'rgba(0, 0, 0, 0.9)';
}

// Función para cerrar el modal de bandera
function closeFlagModal() {
    if (currentFlagOverlay) {
        currentFlagOverlay.remove();
        currentFlagOverlay = null;
    }
}




const baseUrl = 'https://fawzinoo.github.io/audios/';
const audioFiles = [
  'medico.mp3',
    'dentista.mp3',
    'veterinario.mp3',
    'enfermero.mp3',
    'farmaceutico.mp3',
    'profesor.mp3',
    'estudiante.mp3',
    'bombero.mp3',
    'cocinero.mp3',
    'policia.mp3',
    'policia men.mp3',
    'camarero.mp3',
    'dependiente.mp3',
    'comerciante.mp3',
    'mecanico.mp3',
    'pintor.mp3',
    'actor.mp3',
    'cantante.mp3',
    'futbolista.mp3',
    'deportista.mp3',
    'fotografo.mp3',
    'peluquero.mp3',
    'conductor.mp3',
    'taxista.mp3',
    'piloto.mp3',
    'ingeniero.mp3',
    'fontanero.mp3',
    'carpintero.mp3',
    'periodista.mp3',
    'sastre.mp3',
    'pescadero.mp3',
    'agente de trafico.mp3',
    'conserje.mp3',
    'seguridad.mp3',
    'recepcionista.mp3',
    'albacero.mp3',
    'carnicero.mp3',
    'verdulero.mp3',
    'frutero.mp3',
    'comercial.mp3',
    'ama de casa.mp3',
    'ama de llaves.mp3',
    'notario.mp3',
    'presidente.mp3'
];

const audios = audioFiles.map(file => {
    const audio = new Audio();
    audio.preload = 'none';
    audio.src = baseUrl + file;
    return audio;
});

// Normalizador y mapa para resolver el audio correcto según el nombre del país
function normalizeAudioKey(str) {
    if (!str) return '';
    // Toma solo la primera parte antes de coma, punto y coma, barra o paréntesis
    let clean = str.split(/[,;/()]/)[0];
    // Quita artículos iniciales
    clean = clean.replace(/^\s*(el|la|los|las|un|una|unos|unas)\s+/i, '');
    // Quita palabras decorativas comunes (opcional, puedes ampliar la lista)
    clean = clean.replace(/^(idioma|profesion|gentilicio|frase|palabra)\s+/i, '');
    // Normaliza: minúsculas, sin acentos, solo letras/números/espacios
    clean = clean
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')  // quitar acentos
        .replace(/\s+/g, ' ')             // espacios múltiples a uno solo
        .replace(/[^a-z0-9ñ ]/g, '')      // solo letras, números y espacios
        .trim();
    return clean;
}

const audioFilenameByKey = {};
audioFiles.forEach(file => {
    // Normaliza el nombre del archivo igual que el reverso
    const base = file.replace(/\.mp3$/i, '');
    const key = base
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')  // quitar acentos
        .replace(/^\s*(el|la|los|las)\s+/i, '') // quitar artículo inicial
        .replace(/\s+/g, ' ')             // espacios múltiples a uno solo
        .replace(/[^a-z0-9ñ ]/g, '')      // solo letras, números y espacios
        .trim();
    audioFilenameByKey[key] = file;
});
function getAudioSrcForCountryName(textoBack) {
    const key = normalizeAudioKey(textoBack);
    const file = audioFilenameByKey[key];
    return file ? (baseUrl + file) : null;
}

// Alias para discrepancias de nombres entre el texto mostrado y el archivo de audio
// Evita que tarjetas como "Brasil" (archivo brazil.mp3) queden sin src y bloqueen el flujo
if (audioFilenameByKey['brazil'] && !audioFilenameByKey['brasil']) {
    audioFilenameByKey['brasil'] = audioFilenameByKey['brazil'];
}

// Reproducción segura por tarjeta: el audio se resuelve por contenido actual
function playCardAudio(card, onEnded) {
    try {
        if (!card) { if (onEnded) onEnded(); return; }
        const answer = (card.dataset?.answer || card.querySelector('.back')?.textContent || '').trim();
        const src = getAudioSrcForCountryName(answer);
        if (!src) { if (onEnded) onEnded(); return; }
        if (!card._audioEl) {
            card._audioEl = new Audio();
            card._audioEl.preload = 'auto';
        }
        const a = card._audioEl;
        try { a.pause(); } catch {}
        a.src = src;
        a.currentTime = 0;
        a.onended = null;
        if (typeof onEnded === 'function') a.onended = onEnded;
        a.play().catch(() => { if (onEnded) onEnded(); });
    } catch (e) { if (onEnded) onEnded(); }
}

// Detener audios por tarjeta
function stopAllAudios() {
    document.querySelectorAll('.flashcard').forEach(c => {
        if (c._audioEl) {
            try { c._audioEl.pause(); c._audioEl.currentTime = 0; } catch {}
        }
    });
}

// Copia del HTML original del contenedor de tarjetas para poder restaurar tras pantallas finales
let originalFlashcardsHTML = null;
const flashcards = Array.from(document.querySelectorAll('.flashcard'));

function shuffleCards() {
    stopAllAudios();
document.querySelectorAll('.countdown-overlay, .mensaje-error, .listening-indicator').forEach(el => el.remove());


    // 1. Obtener los datos de todas las tarjetas.
const allCardData = flashcards.map((card, index) => ({
    frontImg: card.querySelector('.front img').src,
    frontAlt: card.querySelector('.front img').alt,
    // CORRECTO: usar el texto del reverso real
    backText: card.querySelector('.back').textContent.trim()
}));

    // 2. Separar los datos de las tarjetas en pendientes y completadas.
    const remainingCardData = [];
    const completedCardData = [];
    allCardData.forEach((data, index) => {
        if (completedCards.has(index)) {
            completedCardData.push(data);
        } else {
            remainingCardData.push(data);
        }
    });

    // 3. Barajar solo las tarjetas pendientes.
    for (let i = remainingCardData.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [remainingCardData[i], remainingCardData[j]] = [remainingCardData[j], remainingCardData[i]];
    }

    // 4. Crear el nuevo mazo: pendientes barajadas primero, luego las completadas.
    const newCardOrder = [...remainingCardData, ...completedCardData];

    // 5. Actualizar el DOM según el nuevo orden (sin usar array global de audios por índice)
flashcards.forEach((card, index) => {
    const data = newCardOrder[index];
    card.classList.remove('is-visible', 'flipped');
    card.querySelector('.front img').src = data.frontImg;
    card.querySelector('.front img').alt = data.frontAlt;
    // Restaurar el texto original del reverso por si había cambiado a "Incorrecto"
    const back = card.querySelector('.back');
    back.querySelectorAll('.intentos-back').forEach(el => el.remove());
    back.innerHTML = data.backText;
    card.dataset.answer = data.backText;
    // --- AQUÍ VA EL AUDIO ---
    // Precalcular y guardar src como atributo si quieres usarlo luego
    const src = getAudioSrcForCountryName(data.backText);
    if (src) card.dataset.audioSrc = src; else delete card.dataset.audioSrc;
});

    // 6. Actualizar el estado para reflejar el nuevo orden.
    setTimeout(() => {
        // Las tarjetas completadas ahora están al final del mazo.
        // Sus nuevos índices van desde `remainingCardData.length` hasta el final.
        const newCompletedCards = new Set();
        for (let i = 0; i < completedCardData.length; i++) {
            newCompletedCards.add(remainingCardData.length + i);
        }
        
        completedCards = newCompletedCards; // Reemplazar el set antiguo por el nuevo.
        // Empezar desde la primera PENDIENTE real
        currentCardIndex = 0;
        for (let i = 0; i < flashcards.length; i++) {
            if (!completedCards.has(i)) { currentCardIndex = i; break; }
        }
        
        showCard(currentCardIndex);
        updateCounters(); // Actualizar los contadores en la UI sin reiniciarlos.
    }, 10);
    voiceAttempts = 0;
canFlipBack = true;
}

function getCountryText(backElement) {
    // Clonamos el nodo para no modificar el original
    const clone = backElement.cloneNode(true);
    // Buscamos y eliminamos el contador de intentos si existe
    const attemptsDiv = clone.querySelector('.intentos-back');
    if (attemptsDiv) {
        attemptsDiv.remove();
    }
    // Devolvemos el texto limpio
    return clone.textContent.trim();
}

function attachFlashcardHandlers() {
    flashcards.forEach((card) => {
        // Guardar la respuesta correcta original en un atributo data-answer SOLO una vez
        if (!card.dataset.answer) {
            const back = card.querySelector('.back');
            card.dataset.answer = back.textContent.trim();
        }

        card.addEventListener('click', (event) => {
            // No voltear si el clic ocurre dentro del cuadro de escritura
            try {
                if (event && event.target && event.target.closest('.type-dialog-container')) {
                    return;
                }
            } catch (e) {}
            console.log(`Click en tarjeta. canFlip: ${canFlip}, voiceAttempts: ${voiceAttempts}, flipped: ${card.classList.contains('flipped')}`);
            if (!canFlip) {
                console.log('Volteo bloqueado por canFlip');
                card.style.transform = 'scale(0.98)';
                setTimeout(() => { card.style.transform = ''; }, 150);
                return;
            }
            
            vibrar(80); 
            const backElement = card.querySelector('.back');
            if (card.classList.contains('flipped')) {
                // Ocultar teclado virtual y limpiar estado al volver al frente
                try {
                    const vkOverlay = document.getElementById('vk-overlay');
                    const vk = document.getElementById('vk');
                    if (vk && vkOverlay) {
                        vk.classList.remove('show');
                        vkOverlay.style.display = 'none';
                    }
                    document.body.classList.remove('keyboard-visible');
                    document.documentElement.classList.remove('keyboard-visible');
                    document.body.classList.add('keyboard-hidden');
                    document.documentElement.classList.add('keyboard-hidden');

                } catch (e) {}

                card.classList.remove('flipped');
                stopAllAudios();
                backElement.querySelectorAll('.intentos-back').forEach(el => el.remove());
                // removeListeningIndicator(backElement); // Eliminado para corregir error de referencia
                setBackAttempts(backElement, 2 - voiceAttempts);
                betweenAttempts = false;
                updateSkipButtonState();
            } else {
                card.classList.add('flipped');
                


                // Preparar back...
                if (card.dataset.answer) {
                    backElement.innerHTML = card.dataset.answer;
                }
                backElement.querySelectorAll('.listening-indicator, .mensaje-error').forEach(el => el.remove());
                backElement.classList.remove('hidden-text');
                setBackAttempts(backElement, 2 - voiceAttempts);
                
                // Sustituir sistema de voz por entrada escrita (mantener solo "No sé" por voz)
                // Plantilla UI del diálogo
                backElement.innerHTML = `
                    <div class="type-word-title" id="type-word-title" style="display:none;"></div>
                    <div class="type-dialog-container">
                        <div class="type-message" id="type-message" style="display:none;"></div>
                        <div class="type-input-row">
                            <div class="type-input-container">
                                <input id="type-input" class="type-input" type="text" autocomplete="off" placeholder="Escribe aquí..." inputmode="none" />
                                <button id="clear-button" class="clear-button-inside" title="Limpiar texto"><i class="fas fa-backspace"></i></button>
                            </div>
                        </div>
                        <!-- Botones sin contenedor, directamente debajo del input (solo PC por CSS) -->
                        <button class="char-btn" data-char="á">á</button>
                        <button class="char-btn" data-char="é">é</button>
                        <button class="char-btn" data-char="í">í</button>
                        <button class="char-btn" data-char="ó">ó</button>
                        <button class="char-btn" data-char="ú">ú</button>
                        <button class="char-btn" data-char="ñ">ñ</button>
                        <div class="check-button-row">
                            <button id="check-button" class="check-button">comprobar</button>
                            <button id="no-duplicate-button" class="no-duplicate-button"><i class="fas fa-forward"></i> No sé</button>
                        </div>
                    </div>
                `;
                // Mostrar contador de intentos/extra si aplica (reutilizamos API existente, sin mostrar contador real)
                setBackAttempts(backElement, 2 - voiceAttempts);

                // En este modo no ocultamos el texto del back (se reemplaza por el diálogo)
                backElement.classList.remove('hidden-text');

                // Preparar comprobación escrita
                const answerRaw = (card.dataset.answer || '').trim();
                // Normaliza ignorando solo mayúsculas y comas
                const normalize = (s) => (s || '')
                    .toLowerCase()
                    .replace(/,/g, '')
                    .trim();
                const answerNorm = normalize(answerRaw);

                const inputEl = backElement.querySelector('#type-input');
                const checkBtn = backElement.querySelector('#check-button');
                const clearBtn = backElement.querySelector('#clear-button');

                // Función para evitar teclado del sistema en móviles
                const preventSystemKeyboard = () => {
                    if (window.innerWidth <= 768) { // Solo en móviles
                        // No usar readonly para no bloquear el caret; bloquear solo el teclado nativo
                        inputEl.removeAttribute('readonly');
                        inputEl.setAttribute('inputmode', 'none');
                    } else {
                        // En PC, permitir input normal
                        inputEl.removeAttribute('readonly');
                        inputEl.setAttribute('inputmode', 'text');
                    }
                };
                
                // Aplicar prevención de teclado al inicio
                preventSystemKeyboard();

                const msgEl = backElement.querySelector('#type-message');
                const dialogContainer = backElement.querySelector('.type-dialog-container');
                const inputContainer = backElement.querySelector('.type-input-container');
                const titleEl = backElement.querySelector('#type-word-title');
                // Helper para obtener los elementos del teclado virtual en el momento de uso
                const getVK = () => ({
                    vk: document.getElementById('vk'),
                    vkOverlay: document.getElementById('vk-overlay')
                });
                const isVKShown = () => {
                    const { vk } = getVK();
                    return !!(vk && vk.classList.contains('show'));
                };
                // Restaurar el texto previamente escrito para esta tarjeta (si existe)
                try {
                    const savedValue = card.dataset.userInput || '';
                    if (savedValue) {
                        inputEl.value = savedValue;
                        // Colocar el cursor al final del texto restaurado
                        const end = inputEl.value.length;
                        try { inputEl.setSelectionRange(end, end); } catch {}
                    }
                } catch {}
                // Helper para sincronizar lo escrito con el dataset de la tarjeta
                const syncUserInput = () => {
                    try { card.dataset.userInput = inputEl.value; } catch {}
                };
                // Flag para evitar ocultar el teclado al interactuar con sus teclas
                let vkInteracting = false;
                let vkInteractTimer = null;
                
                // Detectar navegador Samsung para ajustes específicos
                const isSamsungBrowser = navigator.userAgent.includes('SamsungBrowser');
                
                // Función mejorada para detectar dispositivos de escritorio/PC
                const isDesktopDevice = () => {
                    // Detectar por ancho de pantalla (más conservador - solo pantallas muy grandes)
                    if (window.innerWidth >= 1200) return true;
                    
                    // Detectar por user agent (complementario) - solo si es claramente un PC
                    const userAgent = navigator.userAgent.toLowerCase();
                    const isDesktop = /windows|macintosh|linux/.test(userAgent) && 
                                     !/android|iphone|ipad|ipod|mobile|tablet/.test(userAgent) &&
                                     window.innerWidth >= 1024;
                    
                    return isDesktop;
                };



                // Función para mostrar el teclado virtual de forma segura
                const showVirtualKeyboard = () => {
                    console.log('showVirtualKeyboard: invoked');
                    // No mostrar el teclado virtual en dispositivos de escritorio/PC
                    if (isDesktopDevice()) {
                        console.log('showVirtualKeyboard: dispositivo de escritorio detectado, usando teclado físico');
                        // En PC, simplemente enfocar el input para usar el teclado físico
                        try { inputEl.focus(); } catch (e) {}
                        return;
                    }
                    const { vk, vkOverlay } = getVK();
                    if (!(vkOverlay && vk)) { console.log('showVirtualKeyboard: vk/vkOverlay not found'); return; }
                    vkOverlay.style.display = 'flex';
                    // Usar rAF para asegurar layout antes de la transición
                    requestAnimationFrame(() => vk.classList.add('show'));
                    // Bloquear teclado nativo manteniendo foco solo con inputmode y focus (sin readOnly)
                    inputEl.setAttribute('inputmode','none');
                    requestAnimationFrame(() => {
                        try { inputEl.focus({ preventScroll: true }); } catch (e) {}
                    });
                };
                const ensureVirtualKeyboardOpen = () => {
                    // No intentar abrir el teclado virtual en dispositivos de escritorio
                    if (isDesktopDevice()) {
                        console.log('ensureVirtualKeyboardOpen: dispositivo de escritorio, omitiendo teclado virtual');
                        return;
                    }
                    // Intenta abrir varias veces por si el DOM no está listo o hay animaciones en curso
                    [0, 60, 180].forEach(delay => {
                        setTimeout(() => { if (!isVKShown()) { showVirtualKeyboard(); } }, delay);
                    });
                };

                // Mostrar/ocultar con focus/blur
                const originalPlaceholder = (inputEl.getAttribute('placeholder') || '');
                const hidePlaceholder = () => { try { inputEl.setAttribute('placeholder', ''); } catch {} };
                const restorePlaceholder = () => { try { inputEl.setAttribute('placeholder', originalPlaceholder); } catch {} };

                const focusHandler = () => {
                    console.log('FOCUS - Detectando tipo de dispositivo');
                    if (isDesktopDevice()) {
                        console.log('FOCUS - Dispositivo de escritorio: usando teclado físico');
                        // En PC, comportamiento normal sin teclado virtual
                        hidePlaceholder();
                        document.body.classList.add('keyboard-visible');
                        document.documentElement.classList.add('keyboard-visible');
                        document.body.classList.remove('keyboard-hidden');
                        document.documentElement.classList.remove('keyboard-hidden');
                    } else if (window.innerWidth <= 768) {
                        console.log('FOCUS - Dispositivo móvil');
                        hidePlaceholder();
                        document.body.classList.add('keyboard-visible');
                        document.documentElement.classList.add('keyboard-visible');
                        document.body.classList.remove('keyboard-hidden');
                        document.documentElement.classList.remove('keyboard-hidden');
                    } else {
                        console.log('FOCUS - Tablet: comportamiento estándar');
                        hidePlaceholder();
                        document.body.classList.add('keyboard-visible');
                        document.documentElement.classList.add('keyboard-visible');
                        document.body.classList.remove('keyboard-hidden');
                        document.documentElement.classList.remove('keyboard-hidden');
                    }
                    
                    // Mostrar botón "No sé" duplicado solo en móviles cuando el input tiene focus
                    if (window.innerWidth <= 768) {
                        noDuplicateBtn.classList.add('show-on-focus');
                    }
                };
                
                // En blur: ocultar el botón si se oculta el teclado
                const blurHandler = (e) => {
                    console.log('BLUR - Ocultar botón móvil "No sé" y teclado virtual');
                    restorePlaceholder();
                    // Volver a estado oculto del caret cuando se pierde el foco
                    document.body.classList.remove('keyboard-visible');
                    document.documentElement.classList.remove('keyboard-visible');
                    document.body.classList.add('keyboard-hidden');
                    document.documentElement.classList.add('keyboard-hidden');
                    
                    // Ocultar botón "No sé" duplicado cuando se pierde el focus (con delay para permitir clicks)
                    setTimeout(() => {
                        noDuplicateBtn.classList.remove('show-on-focus');
                    }, 150);
                    if (window.innerWidth <= 768) {
                        const { vk, vkOverlay } = getVK();
                        // Si el foco se mueve a algún elemento dentro del teclado, no cerrar
                        try {
                            const rt = e && (e.relatedTarget || document.activeElement);
                            if (vk && rt && vk.contains(rt)) {
                                return;
                            }
                            // Si el foco se mueve a controles del diálogo (incluido el botón móvil), no cerrar
                            if (rt && (dialogContainer && dialogContainer.contains(rt))) {
                                return;
                            }

                            if (rt && (checkBtn && (rt === checkBtn))) {
                                return;
                            }
                            if (rt && (clearBtn && (rt === clearBtn))) {
                                return;
                            }
                            if (rt && (noDuplicateBtn && (rt === noDuplicateBtn))) {
                                console.log('🔥 Click en botón No sé, no ocultar');
                                return;
                            }
                        } catch {}
                        // Si el blur viene de interactuar con el teclado virtual, NO ocultar
                        if (vkInteracting) {
                            if (vk && vkOverlay && !vk.classList.contains('show')) {
                                vkOverlay.style.display = 'flex';
                                requestAnimationFrame(() => vk.classList.add('show'));
                            }
                            // Restaurar foco al input inmediatamente
                            setTimeout(() => inputEl.focus({ preventScroll: true }), 0);
                            return;
                        }

                        if (vk && vkOverlay) {
                            vk.classList.remove('show');
                            setTimeout(() => { vkOverlay.style.display = 'none'; }, 220);
                        }
                    }
                };
                
                // Método alternativo: detectar cambios de altura del viewport
                let lastViewportHeight = window.innerHeight;
                const handleResize = () => {
                    if (window.innerWidth > 768) return;
                    
                    const currentHeight = window.innerHeight;
                    const heightDiff = lastViewportHeight - currentHeight;
                    
                    console.log(`Altura anterior: ${lastViewportHeight}, actual: ${currentHeight}, diferencia: ${heightDiff}`);
                    
                    // En Samsung Internet nunca ocultamos por cambios de viewport para evitar parpadeos
                    if (isSamsungBrowser) {
                        showMobileSkipButton();
                        lastViewportHeight = currentHeight;
                        return;
                    }
                    
                    if (heightDiff > 100) {
                        // Altura se redujo significativamente = teclado apareció
                        showMobileSkipButton();
                    } else if (heightDiff < -30) {
                        // Altura aumentó = teclado desapareció (más sensible)
                        console.log('Detectado aumento de altura - ocultando botón');
                        hideMobileSkipButton(true);
                        // Múltiples intentos para asegurar que se oculte
                        setTimeout(() => hideMobileSkipButton(true), 100);
                        setTimeout(() => hideMobileSkipButton(true), 300);
                    }
                    
                    lastViewportHeight = currentHeight;
                };
                
                // No necesitamos event listeners adicionales - solo focus/blur

                // Solo los event listeners esenciales
                inputEl.addEventListener('focus', focusHandler);
                inputEl.addEventListener('blur', blurHandler);
                window.addEventListener('resize', handleResize);

                // Si el input ya tiene foco y el usuario toca para escribir, reabrir el teclado
                const ensureVKVisibleOnTap = () => {
                    // Solo asegurar foco; NO mover el caret (respeta click/selección del usuario)
                    try {
                        inputEl.focus({ preventScroll: true });
                        hidePlaceholder();
                    } catch {}
                    // Mostrar cursor parpadeante (clases keyboard-visible)
                    try { if (typeof setCursorState === 'function') setCursorState(true, 'Tap en input'); } catch {}
                    // Refuerzo de clases para caret visible
                    document.body.classList.add('keyboard-visible');
                    document.documentElement.classList.add('keyboard-visible');
                    document.body.classList.remove('keyboard-hidden');
                    document.documentElement.classList.remove('keyboard-hidden');
                    
                    // Solo activar teclado virtual y botones móviles en dispositivos NO-PC
                    if (isDesktopDevice()) {
                        console.log('ensureVKVisibleOnTap: dispositivo de escritorio, usando teclado físico');
                        return; // En PC, solo enfocar el input es suficiente
                    }
                    

                    if (!isVKShown()) { ensureVirtualKeyboardOpen(); }
                };
                inputEl.addEventListener('pointerdown', ensureVKVisibleOnTap, { passive: true });
                inputEl.addEventListener('click', ensureVKVisibleOnTap, { passive: true });
                // Permitir click en el área del contenedor para enfocar el input y mostrar el cursor
                const focusFromContainer = (e) => {
                    if (e && e.target === inputEl) return; // ya lo maneja el input
                    try {
                        e && e.preventDefault && e.preventDefault();
                        inputEl.focus({ preventScroll: true });
                        // NO mover el caret al final; respetar click posterior del usuario
                        if (typeof setCursorState === 'function') setCursorState(true, 'Tap en contenedor de input');
                        hidePlaceholder();
                        // Refuerzo de clases para caret visible
                        document.body.classList.add('keyboard-visible');
                        document.documentElement.classList.add('keyboard-visible');
                        document.body.classList.remove('keyboard-hidden');
                        document.documentElement.classList.remove('keyboard-hidden');
                    } catch {}
                };
                if (inputContainer) {
                    inputContainer.addEventListener('pointerdown', focusFromContainer);
                    inputContainer.addEventListener('click', focusFromContainer);
                }
                


                // No forzar apertura del teclado tras montar el UI en móvil: el usuario debe hacer clic en el input

                // ====== LÓGICA DEL TECLADO VIRTUAL ======
                // Soporte de idiomas (ES/FR) y layouts (QWERTY/AZERTY)
                const LAYOUTS = {
                    es: {
                        qwerty: [
                            ['q','w','e','r','t','y','u','i','o','p'],
                            ['a','s','d','f','g','h','j','k','l','ñ'],
                            ['shift','z','x','c','v','b','n','m']
                        ],
                        azerty: [
                            ['a','z','e','r','t','y','u','i','o','p'],
                            ['q','s','d','f','g','h','j','k','l','ñ'],
                            ['shift','w','x','c','v','b','n','m']
                        ]
                    },
                    fr: {
                        qwerty: [
                            ['q','w','e','r','t','y','u','i','o','p'],
                            ['a','s','d','f','g','h','j','k','l','ç'],
                            ['shift','z','x','c','v','b','n','m']
                        ],
                        azerty: [
                            ['a','z','e','r','t','y','u','i','o','p'],
                            ['q','s','d','f','g','h','j','k','l','ç'],
                            ['shift','w','x','c','v','b','n','m']
                        ]
                    }
                };
                const ACCENTS = {
                    es: ['á','é','í','ó','ú'],
                    fr: ['é','è','ê','à','ç']
                };
                // Cargar preferencias guardadas (fallback: AZERTY + ES)
                let VK_LANG = (localStorage.getItem('vk_lang') || 'es');
                let VK_LAYOUT = (localStorage.getItem('vk_layout') || 'azerty');
                let VK_SHIFT = false;

                function renderVirtualKeyboard() {
                    const vk = document.getElementById('vk');
                    if (!vk) return;
                    const rows = vk.querySelectorAll('.vk-row');
                    if (rows.length < 3) return;
                    rows.forEach((row, idx) => {
                        row.innerHTML = '';
                        const keys = LAYOUTS[VK_LANG][VK_LAYOUT][idx];
                        keys.forEach(k => {
                            const div = document.createElement('div');
                            div.className = 'vk-key';
                            let label = k;
                            if (k === 'shift') { label = '⇧'; div.classList.add('primary'); }
                            else { label = VK_SHIFT ? k.toUpperCase() : k; }
                            div.textContent = label;
                            div.dataset.key = k;
                            row.appendChild(div);
                        });
                    });
                }

                function insertAtCursor(text) {
                    // Asegurar foco antes de leer selección
                    if (document.activeElement !== inputEl) {
                        inputEl.focus({ preventScroll: true });
                    }
                    const start = typeof inputEl.selectionStart === 'number' ? inputEl.selectionStart : inputEl.value.length;
                    const end = typeof inputEl.selectionEnd === 'number' ? inputEl.selectionEnd : inputEl.value.length;
                    const current = inputEl.value;
                    const newVal = current.slice(0, start) + text + current.slice(end);
                    inputEl.value = newVal;
                    const caret = start + text.length;
                    try { inputEl.setSelectionRange(caret, caret); } catch {}
                    inputEl.focus({ preventScroll: true });
                    // Guardar valor tras inserción programática
                    syncUserInput();
                }

                function handleVirtualKey(key) {
                    if (key === 'shift') {
                        VK_SHIFT = !VK_SHIFT;
                        renderVirtualKeyboard();
                        return;
                    }
                    if (key === 'hide') {
                        // Ocultar teclado virtual sin perder el foco del input
                        const vk = document.getElementById('vk');
                        const vkOverlay = document.getElementById('vk-overlay');
                        if (vk && vkOverlay) {
                            vk.classList.remove('show');
                            // pequeño retardo para transición y evitar rebotes al tocar el input
                            setTimeout(() => { vkOverlay.style.display = 'none'; }, 220);
                        }

                        return;
                    }
                    if (key === 'backspace') {
                        const start = inputEl.selectionStart ?? inputEl.value.length;
                        const end = inputEl.selectionEnd ?? inputEl.value.length;
                        if (start === end && start > 0) {
                            // borrar carácter previo
                            inputEl.value = inputEl.value.slice(0, start - 1) + inputEl.value.slice(end);
                            const pos = start - 1;
                            inputEl.setSelectionRange(pos, pos);
                        } else {
                            // borrar selección
                            inputEl.value = inputEl.value.slice(0, start) + inputEl.value.slice(end);
                            inputEl.setSelectionRange(start, start);
                        }
                        inputEl.focus({ preventScroll: true });
                        // Guardar valor tras borrar programáticamente
                        syncUserInput();
                        return;
                    }
                    // sin tecla enter: el enter físico del teclado real sigue funcionando (keydown)
                    // letra, espacio o acentos (respetar mayúsculas con Shift)
                    let text = key;
                    if (key.length === 1) {
                        text = VK_SHIFT ? key.toUpperCase() : key;
                    }
                    insertAtCursor(text);
                    // sonido de tecla
                    try { playKeyboardSound(); } catch {}
                }

                function renderAccents() {
                    const vk = document.getElementById('vk');
                    const row = vk ? vk.querySelector('.vk-accents .row-accents') : null;
                    if (!row) return;
                    row.innerHTML = '';
                    const keys = ACCENTS[VK_LANG] || [];
                    keys.forEach(k => {
                        const div = document.createElement('div');
                        div.className = 'vk-key';
                        div.textContent = k;
                        div.dataset.key = k;
                        row.appendChild(div);
                    });
                    // Tecla borrar al final
                    const del = document.createElement('div');
                    del.className = 'vk-key danger';
                    del.dataset.key = 'backspace';
                    del.setAttribute('title', 'Borrar');
                    del.innerHTML = '<i class="fas fa-backspace"></i>';
                    row.appendChild(del);
                }

                // Construir el teclado la primera vez según preferencias
                // Ajustar radios al estado actual
                const syncRadiosToState = () => {
                    const vk = document.getElementById('vk');
                    if (!vk) return;
                    vk.querySelectorAll('input[name="vk-layout"]').forEach(el => { el.checked = (el.value === VK_LAYOUT); });
                    vk.querySelectorAll('input[name="vk-lang"]').forEach(el => { el.checked = (el.value === VK_LANG); });
                };
                renderVirtualKeyboard();
                renderAccents();
                syncRadiosToState();
                // Escuchar cambios de layout (radios)
                const layoutRadios = (document.getElementById('vk') || document).querySelectorAll('input[name="vk-layout"]');
                layoutRadios.forEach(r => {
                    r.addEventListener('change', () => {
                        if (r.checked) {
                            VK_LAYOUT = r.value === 'azerty' ? 'azerty' : 'qwerty';
                            localStorage.setItem('vk_layout', VK_LAYOUT);
                            renderVirtualKeyboard();
                        }
                    });
                });
                const langRadios = (document.getElementById('vk') || document).querySelectorAll('input[name="vk-lang"]');
                langRadios.forEach(r => {
                    r.addEventListener('change', () => {
                        if (r.checked) {
                            VK_LANG = r.value === 'fr' ? 'fr' : 'es';
                            localStorage.setItem('vk_lang', VK_LANG);
                            renderVirtualKeyboard();
                            renderAccents();
                        }
                    });
                });
                // Evitar que los radios provoquen blur del input; manejar el cambio manualmente
                const vkControls = (document.getElementById('vk') || document).querySelector('.vk-controls');
                if (vkControls) {
                    const applyLayout = (newLayout) => {
                        VK_LAYOUT = newLayout === 'azerty' ? 'azerty' : 'qwerty';
                        localStorage.setItem('vk_layout', VK_LAYOUT);
                        // actualizar estado visual de radios
                        try {
                            const vkEl = document.getElementById('vk');
                            if (vkEl) {
                                vkEl.querySelectorAll('input[name="vk-layout"]').forEach(el => {
                                    el.checked = (el.value === VK_LAYOUT);
                                });
                            }
                        } catch {}
                        renderVirtualKeyboard();
                        // asegurar foco y mantener teclado visible
                        inputEl.focus({ preventScroll: true });
                    };
                    const applyLang = (newLang) => {
                        VK_LANG = newLang === 'fr' ? 'fr' : 'es';
                        localStorage.setItem('vk_lang', VK_LANG);
                        try {
                            const vkEl = document.getElementById('vk');
                            if (vkEl) {
                                vkEl.querySelectorAll('input[name="vk-lang"]').forEach(el => {
                                    el.checked = (el.value === VK_LANG);
                                });
                            }
                        } catch {}
                        renderVirtualKeyboard();
                        renderAccents();
                        inputEl.focus({ preventScroll: true });
                    };
                    const startInteract = () => {
                        vkInteracting = true;
                        if (vkInteractTimer) { clearTimeout(vkInteractTimer); vkInteractTimer = null; }
                    };
                    const endInteractSoon = () => {
                        if (vkInteractTimer) clearTimeout(vkInteractTimer);
                        vkInteractTimer = setTimeout(() => { vkInteracting = false; }, 140);
                    };
                    vkControls.addEventListener('pointerdown', (e) => {
                        const label = e.target.closest('.vk-radio');
                        if (!label) return;
                        e.preventDefault();
                        e.stopPropagation();
                        startInteract();
                        const inputLayout = label.querySelector('input[name="vk-layout"]');
                        const inputLang = label.querySelector('input[name="vk-lang"]');
                        if (inputLayout) applyLayout(inputLayout.value);
                        if (inputLang) applyLang(inputLang.value);
                    }, { passive: false });
                    vkControls.addEventListener('pointerup', endInteractSoon);
                    vkControls.addEventListener('pointercancel', endInteractSoon);
                    // También manejar click por si algún navegador no dispara pointer events
                    vkControls.addEventListener('click', (e) => {
                        const label = e.target.closest('.vk-radio');
                        if (!label) return;
                        e.preventDefault();
                        e.stopPropagation();
                        startInteract();
                        const inputLayout = label.querySelector('input[name="vk-layout"]');
                        const inputLang = label.querySelector('input[name="vk-lang"]');
                        if (inputLayout) applyLayout(inputLayout.value);
                        if (inputLang) applyLang(inputLang.value);
                        endInteractSoon();
                    }, { passive: false });
                }
                // Wire de clicks del teclado (usar referencias dinámicas)
                {
                    const vkEl = document.getElementById('vk');
                    const vkOverlayEl = document.getElementById('vk-overlay');
                    if (vkEl) {
                        // Usar pointerdown para soportar móvil y desktop sin bloquear eventos subsiguientes
                        vkEl.addEventListener('pointerdown', (e) => {
                        const target = e.target.closest('.vk-key');
                        if (!target) return;
                        // Marcar interacción con el teclado para suprimir blur momentáneo
                        vkInteracting = true;
                        if (vkInteractTimer) { clearTimeout(vkInteractTimer); vkInteractTimer = null; }
                        const key = target.dataset.key;
                        if (!key) return;
                        e.preventDefault();
                        e.stopPropagation();
                        try { vibrar(80); } catch {}
                        // Efecto visual de hover temporal
                        try {
                            target.classList.add('press-glow');
                            setTimeout(() => target.classList.remove('press-glow'), 1000);
                        } catch {}
                        handleVirtualKey(key);
                        }, { passive: false });
                        // Limpiar la marca de interacción al soltar/cancelar
                        const clearVKInteract = () => {
                            if (vkInteractTimer) clearTimeout(vkInteractTimer);
                            vkInteractTimer = setTimeout(() => { vkInteracting = false; }, 120);
                        };
                        vkEl.addEventListener('pointerup', clearVKInteract);
                        vkEl.addEventListener('pointercancel', clearVKInteract);
                    }
                    // Evitar que los clics del overlay cierren la tarjeta o hagan flip
                    if (vkOverlayEl) {
                        let vkHideTimer = null;
                        vkOverlayEl.addEventListener('click', (e) => {
                            // Solo cerrar si se toca fuera del teclado y sin rebotes
                            if (e.target === vkOverlayEl) {
                                if (vkHideTimer) clearTimeout(vkHideTimer);
                                vkHideTimer = setTimeout(() => blurHandler(), 60);
                            }
                        });
                    }
                }
                // ====== FIN TECLADO VIRTUAL ======

                // Función de limpieza para remover event listeners
                const cleanupKeyboardDetection = () => {
                    inputEl.removeEventListener('focus', focusHandler);
                    inputEl.removeEventListener('blur', blurHandler);
                    window.removeEventListener('resize', handleResize);
                    try {
                        if (inputContainer) {
                            inputContainer.removeEventListener('pointerdown', focusFromContainer);
                            inputContainer.removeEventListener('click', focusFromContainer);
                        }
                        inputEl.removeEventListener('pointerdown', ensureVKVisibleOnTap);
                        inputEl.removeEventListener('click', ensureVKVisibleOnTap);
                        restorePlaceholder();
                    } catch {}
                    // En cleanup, ocultar botón móvil si helper existe
                        if (typeof hideMobileSkipButton === 'function') hideMobileSkipButton(true);
                    // Forzar ocultado del overlay del teclado virtual si está visible
                    try {
                        const vkEl = document.getElementById('vk');
                        const vkOverlayEl = document.getElementById('vk-overlay');
                        if (vkEl && vkOverlayEl) {
                            vkEl.classList.remove('show');
                            vkOverlayEl.style.display = 'none';
                        }
                    } catch {}
                    // También marcar estado global como teclado oculto
                    document.body.classList.add('keyboard-hidden');
                    document.documentElement.classList.add('keyboard-hidden');
                    document.body.classList.remove('keyboard-visible');
                    document.documentElement.classList.remove('keyboard-visible');
                    // Limpiar estado visual de todos los botones móviles "No sé" por seguridad
                    try { document.querySelectorAll('.mobile-skip-button').forEach(btn => btn.classList.remove('keyboard-visible')); } catch {}
                };

                // Guardar función de limpieza para uso posterior
                backElement._cleanupKeyboardDetection = cleanupKeyboardDetection;

                const showMsg = (text, type) => {
                    msgEl.textContent = text;
                    msgEl.className = 'type-message ' + type;
                    msgEl.style.display = 'block';
                };

                // Proceder tras acierto: éxito (inmediato) -> (al 80% del win) audio tarjeta -> (al terminar audio) countdown
                const proceedAfterCorrect = () => {
                    stopAllAudios();
                    // 1) Win inmediato
                    const winEl = playSuccessSound();
                    // 2) Disparar audio tarjeta cuando el win haya consumido el 80%
                    let triggered = false;
                    const triggerCardAudio = () => {
                        if (triggered) return; triggered = true;
                        // Limpiar listeners del win para evitar fugas/doble ejecución
                        try {
                            if (winEl) {
                                winEl.removeEventListener('timeupdate', onTimeUpdate);
                                winEl.removeEventListener('loadedmetadata', onMeta);
                                winEl.removeEventListener('ended', onEndedFallback);
                            }
                        } catch {}
                        // 3) Reproducir audio de la tarjeta y, al terminar, iniciar countdown
                        playCardAudio(card, () => showCountdown(card));
                    };

                    const onEndedFallback = () => triggerCardAudio();
                    let thresholdTime = null;

                    const computeThreshold = () => {
                        if (!winEl) return;
                        const d = Number.isFinite(winEl.duration) ? winEl.duration : NaN;
                        if (!isNaN(d) && d > 0) {
                            thresholdTime = d * 0.6;
                        }
                    };
                    const onMeta = () => {
                        computeThreshold();
                        // Si por cualquier razón ya estamos más allá del 80%, dispara ya
                        if (thresholdTime !== null && winEl.currentTime >= thresholdTime) triggerCardAudio();
                    };
                    const onTimeUpdate = () => {
                        if (thresholdTime === null) computeThreshold();
                        if (thresholdTime !== null && winEl.currentTime >= thresholdTime) triggerCardAudio();
                    };

                    if (winEl) {
                        // Si ya conocemos la duración, intentamos calcular inmediatamente
                        computeThreshold();
                        // Registramos listeners
                        winEl.addEventListener('loadedmetadata', onMeta);
                        winEl.addEventListener('timeupdate', onTimeUpdate);
                        winEl.addEventListener('ended', onEndedFallback);
                        // Fallback por si no llegan eventos (máximo 5s)
                        setTimeout(() => triggerCardAudio(), 5000);
                    } else {
                        // Si falló la reproducción del win, avanzamos directamente
                        triggerCardAudio();
                    }
                };

                const handleCheck = () => {
                    // Desactivar "comprobar" al iniciar para evitar reentradas y dobles clicks
                    if (checkBtn) {
                        if (checkBtn.disabled) return; // ya en curso
                        checkBtn.disabled = true;
                        checkBtn.style.pointerEvents = 'none';
                    }
                    const userRaw = inputEl.value.trim();
                    const userNorm = normalize(userRaw);
                    
                    // Si el input está vacío, mostrar animación roja y no procesar
                    if (!userNorm) {
                        inputEl.classList.add('input-error-empty');
                        vibrar(100); // Vibración más fuerte para indicar error
                        // Rehabilitar inmediatamente si estaba vacío
                        if (checkBtn) {
                            checkBtn.disabled = false;
                            checkBtn.style.pointerEvents = 'auto';
                        }
                        return;
                    }

                    // Si el usuario escribió exactamente la respuesta (ignorando mayúsculas y comas)
                    if (userNorm === answerNorm) {
                        // Bloquear skip durante el flujo de acierto
                        lockedAfterCorrect = true;
                        betweenAttempts = false;
                        showingErrorMessage = false;
                        lockedAfterSecondIncorrect = false;
                        try { updateSkipButtonState(); } catch {}
                        // Mantener desactivado "comprobar" hasta pasar a la siguiente tarjeta
                        if (checkBtn) {
                            checkBtn.disabled = true;
                            checkBtn.style.pointerEvents = 'none';
                        }

                        correctCount++;
                        correctWords.push(answerRaw);
                        updateCounters();
                        // Mostrar y animar la respuesta correcta encima del cuadro de texto
                        if (titleEl) {
                            titleEl.textContent = answerRaw;
                            titleEl.style.display = 'inline-block';
                            titleEl.style.top = '20%';
                            titleEl.classList.remove('success');
                            void titleEl.offsetWidth; // reinicia animación
                            titleEl.classList.add('success');
                        }
                        // Precalentar audio de la tarjeta para minimizar latencia tras el win
                        try {
                            if (card) {
                                if (!card._audioEl) card._audioEl = new Audio();
                                card._audioEl.preload = 'auto';
                                const nextSrc = getAudioSrcForCountryName(answerRaw);
                                if (nextSrc) {
                                    if (card._audioEl.src !== nextSrc) card._audioEl.src = nextSrc;
                                    try { card._audioEl.load(); } catch {}
                                }
                            }
                        } catch {}
                        // El sonido de éxito ya lo dispara proceedAfterCorrect con encadenamiento
                        // Ocultar mensaje de texto para no duplicar
                        if (msgEl) msgEl.style.display = 'none';
                        // Efecto eufórico ya definido en CSS
                        // Sumar y pasar a la siguiente en 3s
                        scheduleStatsBoxUpdate();
                        // Marcar tarjeta como completada y bloquear volteo hasta avance
                        if (!completedCards.has(currentCardIndex)) {
                            completedCards.add(currentCardIndex);
                            updateCardCounter();
                            saveGameProgress();
                        }
                        proceedAfterCorrect();
                    } else {
                        // Incorrecto
                        voiceAttempts++; // Incrementar intentos
                        playErrorSound();
                        // Mostrar mensaje de error y controlar estado de skip
                        showingErrorMessage = true;
                        betweenAttempts = false;
                        lockedAfterCorrect = false;
                        // Aún no bloquear definitivamente por segundo fallo hasta confirmarlo
                        lockedAfterSecondIncorrect = false;
                        try { updateSkipButtonState(); } catch {}
                        
                        // Mostrar "Incorrecto" en la misma posición que la respuesta correcta
                        if (titleEl) {
                            titleEl.textContent = 'Incorrecto';
                            titleEl.style.display = 'inline-block';
                            titleEl.style.top = '20%';
                            titleEl.classList.remove('success');
                            titleEl.classList.add('error-response');
                            void titleEl.offsetWidth; // reinicia cualquier animación
                        }
                        // Ocultar mensaje de texto para no duplicar
                        if (msgEl) msgEl.style.display = 'none';
                        
                        if (voiceAttempts >= 2) {
                            // Segundo intento fallido - mostrar respuesta correcta y proceder
                            incorrectCount++;
                            incorrectWords.push(answerRaw);
                            updateCounters();
                            // Bloquear skip hasta pasar de tarjeta
                            lockedAfterSecondIncorrect = true;
                            try { updateSkipButtonState(); } catch {}
                            // Mantener desactivado "comprobar" hasta pasar de tarjeta
                            if (checkBtn) {
                                checkBtn.disabled = true;
                                checkBtn.style.pointerEvents = 'none';
                            }
                            
                            // 1500ms: Ocultar "Incorrecto"
                            setTimeout(() => {
                                if (titleEl) {
                                    titleEl.style.display = 'none';
                                    titleEl.classList.remove('error-response');
                                }
                                // Ya no se está mostrando mensaje de error
                                showingErrorMessage = false;
                                try { updateSkipButtonState(); } catch {}
                            }, 1500);
                            
                            // 1600ms: Mostrar respuesta correcta con animación triste E iniciar audio
                            setTimeout(() => {
                                if (titleEl) {
                                    titleEl.textContent = answerRaw;
                                    titleEl.style.display = 'inline-block';
                                    titleEl.style.top = '20%';
                                    titleEl.classList.remove('success', 'error-response');
                                    titleEl.classList.add('sad-correct'); // Animación triste
                                }
                                
                                // Marcar como completada
                                if (!completedCards.has(currentCardIndex)) {
                                    completedCards.add(currentCardIndex);
                                    updateCardCounter();
                                    saveGameProgress();
                                }
                                
                                // Iniciar audio inmediatamente y luego countdown
                                stopAllAudios();
                                playCardAudio(card, () => showCountdown(card));
                            }, 1600);
                        } else {
                            // Primer intento fallido - solo mostrar error temporalmente
                            // Deshabilitar botón mezclar después del primer intento fallido
                            const shuffleBtn = document.getElementById('shuffle-button');
                            if (shuffleBtn) {
                                shuffleBtn.disabled = true;
                            }
                            
                            setTimeout(() => {
                                if (titleEl) {
                                    titleEl.style.display = 'none';
                                    titleEl.classList.remove('error-response');
                                }
                                // Termina el mensaje de error; habilitar ventana entre intentos
                                showingErrorMessage = false;
                                betweenAttempts = true;
                                try { updateSkipButtonState(); } catch {}
                                // Rehabilitar "comprobar" para el segundo intento y restaurar su estado visual (hover->normal)
                                if (checkBtn) {
                                    checkBtn.disabled = false;
                                    checkBtn.style.pointerEvents = 'auto';
                                    // Restablecer a estado normal
                                    checkBtn.classList.remove('button-pressed', 'button-disabled', 'hover');
                                    checkBtn.blur();
                                    checkBtn.style.opacity = '';
                                    checkBtn.style.filter = '';
                                }
                            }, 2000); // Desaparece después de 2s para permitir segundo intento
                        }
                    }
                };

                // Evitar que el click dentro del diálogo voltee la tarjeta por burbujeo
                const stopFlip = (e) => { e.stopPropagation(); };
                ['click','mousedown','touchstart'].forEach(evt => {
                    dialogContainer.addEventListener(evt, stopFlip);
                    inputEl.addEventListener(evt, stopFlip);
                    checkBtn.addEventListener(evt, stopFlip);
                    clearBtn.addEventListener(evt, stopFlip);
                    const noDuplicateBtn = backElement.querySelector('#no-duplicate-button');
                    if (noDuplicateBtn) noDuplicateBtn.addEventListener(evt, stopFlip);
                });

                // Click en comprobar (evitar flip y acción por defecto)
                checkBtn.addEventListener('click', (e) => { 
                    e.preventDefault(); 
                    e.stopPropagation(); 
                    vibrar(100); 
                    // Efecto visual de presionado (mantener hasta que el usuario escriba)
                    checkBtn.classList.add('button-pressed');
                    handleCheck(); 
                });

                // Click en "No sé" (hace la misma función que el botón principal "No sé")
                const noDuplicateBtn = backElement.querySelector('#no-duplicate-button');
                if (noDuplicateBtn) {
                    noDuplicateBtn.addEventListener('click', (e) => { 
                        console.log('🔥 Botón No sé duplicado clickeado');
                        e.preventDefault(); 
                        e.stopPropagation(); 
                        vibrar(60); 
                        playButtonSound();
                        console.log('🔥 Ejecutando skipCurrentCardAsUnknown...');
                        skipCurrentCardAsUnknown();
                        console.log('🔥 skipCurrentCardAsUnknown ejecutado');
                    });
                } else {
                    console.error('❌ No se encontró el botón no-duplicate-button');
                }
                
                // Click en limpiar (evitar flip y vaciar contenido)
                clearBtn.addEventListener('click', (e) => { 
                    e.preventDefault(); 
                    e.stopPropagation(); 
                    
                    // Si el input ya está vacío, mostrar animación roja
                    if (!inputEl.value.trim()) {
                        inputEl.classList.add('input-error-empty');
                        vibrar(80); // Vibración consistente para indicar que no hay nada que borrar
                        return;
                    }
                    
                    // Si hay contenido, proceder normalmente
                    vibrar(80); 
                    playTrashSound(); 
                    inputEl.value = ''; 
                    inputEl.focus(); 
                    // Limpiar el valor persistido solo si el usuario limpia
                    syncUserInput();
                    // Restablecer color del botón comprobar y quitar animación de error al limpiar el texto
                    checkBtn.classList.remove('button-pressed');
                    inputEl.classList.remove('input-error-empty');
                });

                // Usar la variable isSamsungBrowser ya declarada arriba
                const touchDelay = isSamsungBrowser ? 500 : 200;
                // Enter para comprobar
                inputEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); handleCheck(); }
                });
                
                // Restablecer color del botón comprobar y quitar animación de error cuando el usuario empiece a escribir
                inputEl.addEventListener('input', () => {
                    checkBtn.classList.remove('button-pressed');
                    inputEl.classList.remove('input-error-empty');
                    playKeyboardSound(); // Sonido de tecla al escribir
                    // Guardar valor al teclear normalmente
                    syncUserInput();
                });

                // Importante: no iniciar SpeechRecognition aquí a menos que haya permisos concedidos.

                // Listeners de caracteres especiales (para PC)
                const charBtns = backElement.querySelectorAll('.char-btn');
                charBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        vibrar(30);
                        playKeyboardSound();
                        const char = btn.getAttribute('data-char');
                        const currentPos = inputEl.selectionStart ?? inputEl.value.length;
                        const currentValue = inputEl.value;
                        const newValue = currentValue.slice(0, currentPos) + char + currentValue.slice(currentPos);
                        inputEl.value = newValue;
                        checkBtn.classList.remove('button-pressed');
                        inputEl.classList.remove('input-error-empty');
                        inputEl.focus();
                        inputEl.setSelectionRange(currentPos + 1, currentPos + 1);
                         // Guardar valor al insertar carácter especial
                         syncUserInput();
                    });
                });

                // Fin del modo escrito
                
                // Si no quedaran intentos (lógica antigua), mostramos respuesta; ya no aplicará, pero preservo comportamiento
                if (voiceAttempts >= 2) {
                    // No quedan intentos - mostrar respuesta directamente
                    console.log(`Sin intentos restantes (${voiceAttempts}), mostrando respuesta directamente`);
                    // Eliminar indicador cuando aparece la respuesta directa (no-op)
                    try { backElement.querySelectorAll('.listening-indicator').forEach(el => el.remove()); } catch (e) {}

                    // ANTI-TRUCO (refuerzo): marcar como completada al mostrar respuesta directa
                    if (!completedCards.has(currentCardIndex)) {
                        completedCards.add(currentCardIndex);
                        updateCardCounter();
                        saveGameProgress();
                    }
                    
                    // Mostrar la respuesta correcta con efecto de brillo
                    const respuestaCorrecta = document.createElement('div');
                    respuestaCorrecta.textContent = card.dataset.answer;
                    respuestaCorrecta.style.animation = 'respuestaGlow 1.5s infinite';
                    respuestaCorrecta.style.marginTop = '40px';
                    backElement.appendChild(respuestaCorrecta);
                    
                    // Reproducir audio si existe y después mostrar countdown
                    stopAllAudios();
                    playCardAudio(card, () => showCountdown(card));
                }
                // En back, por defecto el botón No sé queda deshabilitado (salvo ventana entre intentos)
                updateSkipButtonState();
            }
        });
    });
}

// Anclar manejadores de tarjetas al cargar
attachFlashcardHandlers();
window.addEventListener('DOMContentLoaded', () => {
    // Guardar HTML original del tablero de tarjetas por si luego se reemplaza
    const container = document.getElementById('flashcard-container');
    if (container && !originalFlashcardsHTML) {
        originalFlashcardsHTML = container.innerHTML;
    }



    // VERIFICAR SI HAY PROGRESO GUARDADO ANTES DE INICIALIZAR
    if (hasProgressSaved()) {
        // Asegurar que el "avance anterior" se pinte desde localStorage aunque mostremos el modal
        updateLastGamePillFromStorage();
        // Mostrar modal de continuación si hay progreso
        setTimeout(() => {
            showContinueGameModal();
        }, 500); // Pequeño delay para que la página termine de cargar
        return; // No ejecutar el resto de la inicialización
    }
    
    // Si no hay progreso guardado, continuar con la inicialización normal
    initializePage();
});

// Función para inicializar la página cuando no hay progreso guardado
function initializePage() {
    // Cargar último porcentaje de aciertos desde localStorage
    const savedPercentage = localStorage.getItem('lastSuccessPercentage');
    const porcentajeDiv = document.getElementById('porcentaje-guardado');
    const porcentajeSpan = document.getElementById('current-percentage');
    
    if (porcentajeDiv && porcentajeSpan) {
        const percentage = savedPercentage !== null ? parseInt(savedPercentage) : NaN;
        porcentajeSpan.textContent = `${!isNaN(percentage) ? percentage : 0}%`;
        // Fondo transparente como el cuadro; estilo neutro si 0 o no hay datos
        porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
        if (!isNaN(percentage) && percentage > 0) {
            if (percentage >= 80) {
                porcentajeDiv.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
            } else if (percentage >= 60) {
                porcentajeDiv.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
            } else {
                porcentajeDiv.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
            }
        } else {
            porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            porcentajeDiv.style.boxShadow = 'none';
        }
    }
    
    // Pintar el porcentaje del último partido (avance anterior)
    updateLastGamePillFromStorage();
    
    // Mezclar tarjetas automáticamente al cargar la página
    shuffleCards();
    
    // No es necesario re-mapear audios por índice; la reproducción es por tarjeta

    showCard(currentCardIndex);
    updateCounters();
    // Precargar audio correcto para la tarjeta visible tras primera mezcla
    const firstBack = document.querySelector('.flashcard.is-visible .back');
    const visibleAnswer = firstBack ? firstBack.textContent.trim() : null;
    const visibleSrc = visibleAnswer ? getAudioSrcForCountryName(visibleAnswer) : null;
    if (visibleSrc) {
        const card = flashcards[currentCardIndex];
        if (card) {
            if (!card._audioEl) card._audioEl = new Audio();
            card._audioEl.preload = 'auto';
            card._audioEl.src = visibleSrc;
            try { card._audioEl.load(); } catch {}
        }
    }
    // Mostrar hints secuenciales al cargar
    showPillHints();
}

// Helper: pintar el "avance anterior" desde localStorage en su pill
function updateLastGamePillFromStorage() {
    const lastGamePercentage = localStorage.getItem('profesiones11');
    const lastGameDiv = document.getElementById('last-game-percentage');
    const lastGamePill = document.getElementById('last-game-pill');
    if (lastGamePercentage !== null && lastGameDiv && lastGamePill) {
        const gamePercentage = parseInt(lastGamePercentage);
        lastGameDiv.textContent = `${isNaN(gamePercentage) ? 0 : gamePercentage}%`;
        // Estilo visual del pill según nivel
        lastGamePill.style.background = 'rgba(255,255,255,0.08)';
        if (!isNaN(gamePercentage)) {
            if (gamePercentage >= 80) {
                lastGamePill.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                lastGamePill.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
            } else if (gamePercentage >= 60) {
                lastGamePill.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
            } else {
                lastGamePill.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
            }
        } else {
            lastGamePill.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            lastGamePill.style.boxShadow = 'none';
        }
    }
}

// Reasignar audios a tarjetas según el texto del reverso (data-answer)
function reassignAudiosToCards() { /* no-op: audio se resuelve por tarjeta */ }

function updateCardCounter() {
    const pillFaltan = document.querySelector('.pill-faltan');
    const totalCardsElem = document.getElementById('total-cards');
    const prevValue = Number(pillFaltan.getAttribute('data-prev') || 0);

    const remaining = flashcards.length - completedCards.size;
    totalCardsElem.textContent = remaining;

    if (remaining !== prevValue) {
        pillFaltan.classList.remove('glow-faltan');
        void pillFaltan.offsetWidth; // Reinicia animación
        pillFaltan.classList.add('glow-faltan');
    }
    pillFaltan.setAttribute('data-prev', remaining);
    
    // Calcular y mostrar porcentaje de aciertos
    updateSuccessPercentage();
}

function updateSuccessPercentage() {
    const totalCards = flashcards.length;
    const percentage = totalCards > 0 ? Math.round((correctCount / totalCards) * 100) : 0;

    // Actualizar elemento visual inmediato (la visibilidad la controla el scheduler)
    const porcentajeDiv = document.getElementById('porcentaje-guardado');
    const porcentajeSpan = document.getElementById('current-percentage');
    if (porcentajeDiv && porcentajeSpan) {
        porcentajeSpan.textContent = `${percentage}%`;
        porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
        if (totalCards > 0) {
            if (percentage >= 80) {
                porcentajeDiv.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
            } else if (percentage >= 60) {
                porcentajeDiv.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
            } else {
                porcentajeDiv.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
            }
        } else {
            porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            porcentajeDiv.style.boxShadow = 'none';
        }
    }

    // Guardar en localStorage
    localStorage.setItem('lastSuccessPercentage', percentage.toString());
    localStorage.setItem('lastUpdateDate', new Date().toISOString());
}

function saveLastGamePercentage() {
    const totalCards = flashcards.length;
    const gamePercentage = totalCards > 0 ? Math.round((correctCount / totalCards) * 100) : 0;
    
    // Guardar porcentaje del último partido jugado
    localStorage.setItem('profesiones11', gamePercentage.toString());
    localStorage.setItem('profesiones11Date', new Date().toISOString());
    
    // Actualizar display inmediatamente
    const lastGameDiv = document.getElementById('last-game-percentage');
    const lastGamePill = document.getElementById('last-game-pill');
    
    if (lastGameDiv && lastGamePill) {
        lastGameDiv.textContent = `${gamePercentage}%`;
        
        // Cambiar color según el porcentaje del último partido
        // Fondo transparente como el cuadro; solo resaltar borde según nivel
        lastGamePill.style.background = 'rgba(255,255,255,0.08)';
        if (gamePercentage >= 80) {
            lastGamePill.style.borderColor = 'rgba(0, 200, 81, 0.6)';
            lastGamePill.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
        } else if (gamePercentage >= 60) {
            lastGamePill.style.borderColor = 'rgba(255, 215, 0, 0.6)';
            lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
        } else {
            lastGamePill.style.borderColor = 'rgba(255, 53, 71, 0.6)';
            lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
        }
    }
    
    console.log(`Partido terminado con ${gamePercentage}% de aciertos`);
}

window.addEventListener('load', () => {
    document.getElementById('soundResetButton').play().catch(e => console.log(e));
});

// (Eliminado) stopAllAudios anterior basado en array global de audios

// Muestra frases (hints) cerca de los pills al cargar la página
function showPillHints() {
    const lastGamePill = document.getElementById('last-game-pill');
    const currentPill = document.getElementById('porcentaje-guardado');
    const statsBox = document.getElementById('stats-box');
    if (!lastGamePill || !currentPill) return;

    // Helper para crear y mostrar un hint sobre un objetivo
    function createHint(target, text, delayMs = 0, onRemoved = null) {
        const hint = document.createElement('div');
        hint.className = 'pill-hint';
        hint.textContent = text;
        // Configurar animación de tipeo según longitud
        const chars = Math.max(8, text.length);
        hint.style.setProperty('--chars', chars);
        const typeDur = Math.min(1800, 60 * chars);
        hint.style.setProperty('--type-dur', `${typeDur}ms`);
        hint.style.setProperty('--delay', `${delayMs}ms`);
        // Mantener visible SOLO 4s en total (tipeo + lectura)
        // Si el tipeo tarda X ms, mantenemos (4000 - X) ms extra antes de iniciar el fade
        const holdAfterTyping = Math.max(0, 4000 - typeDur);
        const fadeDelay = delayMs + typeDur + holdAfterTyping;
        hint.style.setProperty('--fade-delay', `${fadeDelay}ms`);
        target.appendChild(hint);
        // Remover al terminar el fade
        setTimeout(() => {
            hint.remove();
            if (typeof onRemoved === 'function') onRemoved();
        }, fadeDelay + 600);
    }

    // Secuencia: primero el inferior; cuando se elimina, mostramos el superior
    const bottomText = 'Avance anterior';
    const topText = 'Avance actual';
    const bottomDelay = 200; // inicio del inferior

    createHint(lastGamePill, bottomText, bottomDelay, () => {
        // pequeño gap tras eliminar el inferior
        setTimeout(() => {
            // Crear el superior y, al eliminarse, programar esconder el cuadro 3s después
            createHint(currentPill, topText, 0, () => {
                if (statsBox) {
                    setTimeout(() => {
                        statsBox.classList.add('hidden');
                    }, 3000); // 3 segundos después de desaparecer el hint superior
                }
            });
        }, 150);
    });
}

function resetGame() {
    // Asegurar que cualquier UI/teclado/back quede limpio antes de reiniciar
    try { resetBackUI(); } catch (e) { console.warn('resetBackUI fallo:', e); }
    // Si el tablero fue reemplazado por una pantalla final, restaurarlo
    reinitFlashcardsDOMIfMissing();
    
    // Solo guardar el avance si hay un juego completado (no al reiniciar desde 0)
    const totalAttempts = correctCount + incorrectCount;
    if (totalAttempts > 0) {
        saveLastGamePercentage();
    }
    
    // LIMPIAR PROGRESO GUARDADO al reiniciar
    clearCurrentProgress();
    
    // Limpiar timeouts de stats box si estuvieran activos
    if (statsShowTimeoutId) { clearTimeout(statsShowTimeoutId); statsShowTimeoutId = null; }
    if (statsHideTimeoutId) { clearTimeout(statsHideTimeoutId); statsHideTimeoutId = null; }
    if (percentageUpdateTimeoutId) { clearTimeout(percentageUpdateTimeoutId); percentageUpdateTimeoutId = null; }
    
    // Resetear todas las variables del juego
    currentCardIndex = 0;
    voiceAttempts = 0;
    completedCards.clear();
    correctWords.length = 0;
    incorrectWords.length = 0;
    correctCount = 0;
    incorrectCount = 0;
    shuffleClickCount = 0; // Restablecer usos de Mezclar
    try { localStorage.removeItem('profesiones11_shuffleCount'); } catch (e) {}
    
    // Limpiar timeouts activos
    if (typeof autoFlipTimer !== 'undefined') {
        clearTimeout(autoFlipTimer);
    }
    
    // Resetear todas las tarjetas al estado inicial
    const allCards = document.querySelectorAll('.flashcard');
    allCards.forEach(card => {
        card.classList.remove('flipped');
        
        // Limpiar indicadores de respuesta
        const backElement = card.querySelector('.back');
        if (backElement) {
            backElement.classList.remove('correct-answer', 'incorrect-answer', 'hidden-text');
            
            // Resetear intentos mostrados
            const attemptsDiv = backElement.querySelector('.attempts');
            if (attemptsDiv) {
                attemptsDiv.remove();
            }
        }
    });
    
    // Habilitar botón de mezclar
    document.getElementById('shuffle-button').disabled = false;
    
    // Limpiar cualquier modal o overlay existente, excepto el teclado virtual global
    const overlays = document.querySelectorAll('[id$="-overlay"]:not(#vk-overlay)');
    overlays.forEach(overlay => overlay.remove());
    
    // Resetear botones de palabras correctas/incorrectas (si existen)
    const correctBtn = document.getElementById('correct-words-btn');
    const incorrectBtn = document.getElementById('incorrect-words-btn');
    if (correctBtn) correctBtn.style.display = 'none';
    if (incorrectBtn) incorrectBtn.style.display = 'none';
    
    // Resetear atributos data-prev de las píldoras
    const correctasPill = document.querySelector('.pill-correctas');
    const incorrectasPill = document.querySelector('.pill-incorrectas');
    if (correctasPill) correctasPill.setAttribute('data-prev', '0');
    if (incorrectasPill) incorrectasPill.setAttribute('data-prev', '0');
    
    // Actualizar porcentaje actual (pero NO el "avance anterior" que ya se guardó)
    const totalCards = flashcards.length;
    const percentage = 0; // Siempre 0 al reiniciar
    const porcentajeDiv = document.getElementById('porcentaje-guardado');
    const porcentajeSpan = document.getElementById('current-percentage');
    if (porcentajeDiv && porcentajeSpan) {
        porcentajeSpan.textContent = `${percentage}%`;
        porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
        porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
        porcentajeDiv.style.boxShadow = 'none';
    }
    
    // Mezclar tarjetas sin sonido (el sonido es solo para el botón mezclar)
    shuffleCards();
    
    // Actualizar contadores
    updateCounters();
    updateCardCounter();
    
    // Mostrar la primera tarjeta
    showCard(0);
}

// Limpia la UI de la parte trasera: teclado virtual, inputs, botones y listeners
function resetBackUI() {
    // 1) Ejecutar limpieza específica de cada tarjeta si fue registrada
    document.querySelectorAll('.flashcard .back').forEach(back => {
        try {
            if (back._cleanupKeyboardDetection) {
                back._cleanupKeyboardDetection();
                delete back._cleanupKeyboardDetection;
            }
        } catch (e) { console.warn('cleanupKeyboardDetection error:', e); }

        // Limpiar input y mensajes visibles del modo escritura
        const input = back.querySelector('.type-input');
        if (input) { input.value = ''; input.blur && input.blur(); }
        const msg = back.querySelector('.type-message');
        if (msg) { msg.textContent = ''; msg.style.display = 'none'; }
    });

    // 2) Ocultar y resetear estado del teclado virtual global
    try {
        const vk = document.getElementById('vk');
        const vkOverlay = document.getElementById('vk-overlay');
        if (vk && vkOverlay) {
            vk.classList.remove('show');
            vkOverlay.style.display = 'none';
        }
    } catch {}

    // 3) Resetear flags/clases globales de teclado
    try {
        document.body.classList.add('keyboard-hidden');
        document.documentElement.classList.add('keyboard-hidden');
        document.body.classList.remove('keyboard-visible');
        document.documentElement.classList.remove('keyboard-visible');
    } catch {}

    // 4) Ocultar estado visual del botón móvil "No sé"
    try { document.querySelectorAll('.mobile-skip-button').forEach(btn => btn.classList.remove('keyboard-visible')); } catch {}

    // 5) Limpiar ventana de protección de clic fantasma del botón móvil
    try { if (window.ignoreClickAfterButton) window.ignoreClickAfterButton = null; } catch {}
}

// Restaura el DOM de tarjetas si fue reemplazado por pantallas de fin de juego
function reinitFlashcardsDOMIfMissing() {
    const container = document.getElementById('flashcard-container');
    if (!container) return;
    const hasCards = container.querySelectorAll('.flashcard').length > 0;
    if (!hasCards && originalFlashcardsHTML) {
        container.innerHTML = originalFlashcardsHTML;
        // Volver a poblar el arreglo global (const) sin reasignar
        const newCards = Array.from(container.querySelectorAll('.flashcard'));
        flashcards.length = 0;
        newCards.forEach(c => flashcards.push(c));
        // Reanclar manejadores de clic
        attachFlashcardHandlers();
    }
}

document.getElementById('reset-button').addEventListener('click', () => {
    vibrar(80);
    const soundResetButton = document.getElementById('soundResetButton');
    soundResetButton.play().catch(e => console.log(e));

    // Si el juego YA está finalizado (overlay de fin o pantalla final), reiniciar sin mostrar el toast
    try {
        const overlaysPresent = (
            document.getElementById('euforia-maxima-overlay') ||
            document.getElementById('euforia-overlay') ||
            document.getElementById('perdida-overlay') ||
            document.getElementById('empate-overlay')
        );
        const container = document.getElementById('flashcard-container');
        const hasCompletionScreen = container && !container.querySelector('.flashcard');
        const totalCardsNow = document.querySelectorAll('.flashcard').length;
        const finishedNow = overlaysPresent || hasCompletionScreen || (totalCardsNow > 0 && completedCards.size >= totalCardsNow);
        if (finishedNow) {
            const existing = document.getElementById('reset-guard-toast');
            if (existing) existing.remove();
            resetGame();
            return;
        }
    } catch (e) { /* si algo falla, continuar con la lógica normal */ }

    // Permitir reiniciar SOLO si, al cargar, se detectó progreso guardado COMPLETADO
    try {
        const allowResetNow = sessionStorage.getItem('resetAllowedCompletedSavedGame') === 'true';
        if (!allowResetNow) {
            const existing = document.getElementById('reset-guard-toast');
            if (existing) existing.remove();
            const toast = document.createElement('div');
            toast.id = 'reset-guard-toast';
            toast.innerHTML = `
                <div style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 12px;
                    font-size: 16px;
                    font-weight: 600;
                ">
                    <div style="
                        font-size: 24px;
                        filter: drop-shadow(0 0 8px rgba(255,152,0,0.6));
                    ">⏳</div>
                    <span>Finaliza el juego primero</span>
                </div>
            `;
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30,30,30,0.95) 0%, rgba(50,50,50,0.95) 100%);
                color: #fff;
                padding: 20px 28px;
                border-radius: 16px;
                font-weight: 600;
                font-size: 16px;
                letter-spacing: 0.3px;
                z-index: 10000;
                backdrop-filter: blur(12px);
                border: 1px solid rgba(255,152,0,0.3);
                box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 20px rgba(255,152,0,0.1);
                animation: modernFadeInOut 2.2s ease;
                min-width: 280px;
                text-align: center;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2200);
            return;
        }
        // Consumir la bandera y reiniciar
        sessionStorage.removeItem('resetAllowedCompletedSavedGame');
        resetGame();
        return;
    } catch (e) { /* si falla sessionStorage, continuar con lógica anterior */ }

    // Calcular estado de juego para mensaje en juego no finalizado
    const started = ((correctCount + incorrectCount) > 0) || (voiceAttempts > 0);

    if (true) { // bloque anterior reordenado; aquí solo protegemos el caso de juego NO finalizado
        if (started) {
            const existing = document.getElementById('reset-guard-toast');
            if (existing) existing.remove();
            const toast = document.createElement('div');
            toast.id = 'reset-guard-toast';
            toast.innerHTML = `
                <div style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 12px;
                    font-size: 16px;
                    font-weight: 600;
                ">
                    <div style="
                        font-size: 24px;
                        filter: drop-shadow(0 0 8px rgba(255,152,0,0.6));
                    ">⏳</div>
                    <span>Finaliza el juego primero</span>
                </div>
            `;
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30,30,30,0.95) 0%, rgba(50,50,50,0.95) 100%);
                color: #fff;
                padding: 20px 28px;
                border-radius: 16px;
                font-weight: 600;
                font-size: 16px;
                letter-spacing: 0.3px;
                z-index: 10000;
                backdrop-filter: blur(12px);
                border: 1px solid rgba(255,152,0,0.3);
                box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 20px rgba(255,152,0,0.1);
                animation: modernFadeInOut 2.2s ease;
                min-width: 280px;
                text-align: center;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2200);
            return; // bloquear si empezó
        }
        return;
    }

    // Resetear el juego sin recargar la página (solo al finalizar)
    resetGame();
});


function setBackAttempts(backElement, attemptsLeft, mensajeExtra = "") {
    // Elimina TODOS los contadores de intentos antes de crear uno nuevo
    backElement.querySelectorAll('.intentos-back').forEach(el => el.remove());

    // Ya no mostramos ningún contador visual de intentos.
    // Si quieres mostrar un mensaje extra, puedes hacerlo aquí:
    if (mensajeExtra) {
        const extraDiv = document.createElement('div');
        extraDiv.className = 'mensaje-extra';
        extraDiv.style.marginTop = '10px';
        extraDiv.innerHTML = mensajeExtra;
        backElement.prepend(extraDiv);
    }
}

// Agregar sonido a todos los elementos clickeables excepto reiniciar y mezclar
document.addEventListener('DOMContentLoaded', function() {
    // Función para agregar sonido a elementos clickeables
    function addClickSound(element) {
        if (element && !element.hasAttribute('data-sound-added')) {
            element.addEventListener('click', function(e) {
                // Excluir botones de reiniciar y mezclar (ya tienen su propia vibración)
                if (this.id !== 'reset-button' && this.id !== 'shuffle-button') {
                    vibrar(50); // Vibración leve para elementos clickeables
                    playButtonSound();
                }
            });
            element.setAttribute('data-sound-added', 'true');
        }
    }
    
    // Agregar sonido a elementos específicos
    const clickableElements = [
        // Botones de control de bandera
        '.flag-control-btn',
        '.flag-close-btn',
        // Botones de modal
        '.modal-close-btn',
        // Tarjetas de palabras
        '.word-card',
        // Pills de estadísticas clickeables
        '.pill-correctas',
        '.pill-incorrectas',
        '.pill-progreso'
    ];
    
    clickableElements.forEach(selector => {
        document.querySelectorAll(selector).forEach(addClickSound);
    });
    
    // Observer para elementos que se crean dinámicamente
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1) { // Element node
                    // Buscar elementos clickeables en el nodo agregado
                    clickableElements.forEach(selector => {
                        if (node.matches && node.matches(selector)) {
                            addClickSound(node);
                        }
                        node.querySelectorAll && node.querySelectorAll(selector).forEach(addClickSound);
                    });
                    
                    // Manejar elementos con onclick dinámicos
                    if (node.onclick || node.getAttribute('onclick')) {
                        addClickSound(node);
                    }
                    node.querySelectorAll && node.querySelectorAll('[onclick]').forEach(addClickSound);
                }
            });
        });
    });
    
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
});

// Prevenir menú contextual (clic derecho y presión larga)
document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    e.stopPropagation();
    return false;
}, true);

// Prevenir arrastrar imágenes
document.addEventListener('dragstart', function(e) {
    if (e.target.tagName === 'IMG') {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
}, true);

// Prevenir presión larga en dispositivos móviles
document.addEventListener('touchstart', function(e) {
    if (e.target.tagName === 'IMG') {
        // Solo permitir un toque, prevenir presión larga
        setTimeout(() => {
            e.target.style.pointerEvents = 'none';
            setTimeout(() => {
                e.target.style.pointerEvents = '';
            }, 50);
        }, 10);
    }
}, {passive: false});

// Prevenir selección con teclado
document.addEventListener('keydown', function(e) {
    // Prevenir Ctrl+A, Ctrl+C, Ctrl+S, F12, etc.
    if ((e.ctrlKey || e.metaKey) && (e.key === 'a' || e.key === 'A' || 
        e.key === 'c' || e.key === 'C' || e.key === 's' || e.key === 'S')) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
    // Prevenir F12 (DevTools)
    if (e.key === 'F12') {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
}, true);

// ============ GUARDADO AUTOMÁTICO EN EVENTOS DE PÁGINA ============
// Guardar progreso cuando el usuario cambie de pestaña, minimice la ventana o cierre la página
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'hidden') {
        // Solo guardar si hay progreso actual
        const totalAttempts = correctCount + incorrectCount;
        const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;
        
        if (hasCurrentProgress) {
            saveGameProgress();
            console.log('Progreso guardado al cambiar de pestaña');
        }
    }
});

// Guardar progreso antes de que se cierre la página
window.addEventListener('beforeunload', function() {
    // Solo guardar si hay progreso actual
    const totalAttempts = correctCount + incorrectCount;
    const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;
    
    if (hasCurrentProgress) {
        saveGameProgress();
        console.log('Progreso guardado antes de cerrar página');
    }
});

// Guardar progreso periódicamente cada 30 segundos si hay actividad
let autoSaveInterval = null;

function startAutoSave() {
    if (autoSaveInterval) return; // Ya está corriendo
    
    autoSaveInterval = setInterval(() => {
        const totalAttempts = correctCount + incorrectCount;
        const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;
        
        if (hasCurrentProgress) {
            saveGameProgress();
            console.log('Guardado automático periódico');
        }
    }, 30000); // Cada 30 segundos
}

function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

// Iniciar guardado automático cuando el usuario comience a jugar
document.addEventListener('DOMContentLoaded', function() {
    // Esperar un poco antes de iniciar el auto-guardado
    setTimeout(() => {
        startAutoSave();
    }, 5000); // Empezar después de 5 segundos
    
    // Inicializar sistema de conectividad
    initConnectivityMonitor();
});

// === SISTEMA DE MONITOREO DE CONECTIVIDAD ===
let connectivityCheckInterval = null;
let isConnectivityOverlayVisible = false;
let connectivityCheckInProgress = false;
let lastConnectionStatus = true;

// Inicializar el monitor de conectividad
function initConnectivityMonitor() {
    console.log('🌐 Iniciando monitor de conectividad...');
    
    // Verificar conexión inicial
    setTimeout(() => {
        checkInternetConnection();
    }, 2000);
    
    // Escuchar eventos de online/offline del navegador
    window.addEventListener('online', handleOnlineEvent);
    window.addEventListener('offline', handleOfflineEvent);
    
    // Configurar el botón de reintentar
    const retryBtn = document.getElementById('connectivity-retry-btn');
    if (retryBtn) {
        retryBtn.addEventListener('click', handleRetryConnection);
    }
    
    // Iniciar verificación periódica cada 10 segundos
    startPeriodicConnectivityCheck();
}

// Manejar evento de conexión online
function handleOnlineEvent() {
    console.log('🟢 Evento online detectado');
    setTimeout(() => {
        checkInternetConnection();
    }, 1000); // Dar tiempo para que la conexión se estabilice
}

// Manejar evento de desconexión offline
function handleOfflineEvent() {
    console.log('🔴 Evento offline detectado');
    updateConnectivityStatus(false, 'Sin conexión a Internet');
}

// Verificar conectividad real haciendo fetch a recursos externos
async function checkInternetConnection() {
    if (connectivityCheckInProgress) return;
    
    connectivityCheckInProgress = true;
    updateConnectivityStatusText('Verificando conexión...');
    
    console.log('🔍 Verificando conectividad real...');
    
    const testUrls = [
        'https://www.google.com/favicon.ico',
        'https://httpbin.org/status/200',
        'https://jsonplaceholder.typicode.com/posts/1',
        'https://api.github.com'
    ];
    
    let connectionSuccessful = false;
    
    for (const url of testUrls) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 segundos timeout
            
            const response = await fetch(url, {
                method: 'HEAD',
                mode: 'no-cors',
                cache: 'no-cache',
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            console.log(`✅ Conexión exitosa a: ${url}`);
            connectionSuccessful = true;
            break;
            
        } catch (error) {
            console.log(`❌ Fallo al conectar a: ${url}`, error.message);
            continue;
        }
    }
    
    // Si todas las pruebas fallan, intentar con navigator.onLine como respaldo
    if (!connectionSuccessful && navigator.onLine) {
        try {
            // Prueba simple con fetch a la misma página
            const response = await fetch(window.location.href, {
                method: 'HEAD',
                cache: 'no-cache'
            });
            
            if (response.ok) {
                connectionSuccessful = true;
                console.log('✅ Conectividad confirmada con fetch local');
            }
        } catch (error) {
            console.log('❌ Fallo en fetch local:', error.message);
        }
    }
    
    const statusMessage = connectionSuccessful ? 
        'Conexión estable' : 
        'Sin conexión o muy lenta';
        
    updateConnectivityStatus(connectionSuccessful, statusMessage);
    connectivityCheckInProgress = false;
}

// Actualizar el estado de conectividad
function updateConnectivityStatus(isConnected, message = '') {
    lastConnectionStatus = isConnected;
    
    console.log(`📊 Estado de conectividad: ${isConnected ? 'CONECTADO' : 'DESCONECTADO'} - ${message}`);
    
    if (isConnected) {
        hideConnectivityOverlay();
    } else {
        showConnectivityOverlay(message);
    }
}

// Mostrar overlay de conectividad
function showConnectivityOverlay(message = 'Sin conexión a Internet') {
    if (isConnectivityOverlayVisible) return;
    
    console.log('🚫 Mostrando overlay de conectividad');
    
    const overlay = document.getElementById('connectivity-overlay');
    const statusText = document.getElementById('connectivity-status-text');
    const retryBtn = document.getElementById('connectivity-retry-btn');
    
    if (overlay) {
        // Actualizar mensaje
        updateConnectivityStatusText(message);
        
        // Mostrar overlay
        overlay.classList.remove('reconnected');
        overlay.classList.add('show');
        isConnectivityOverlayVisible = true;
        
        // Desabilitar interacciones con el juego
        disableGameInteractions();
        
        // Reset del botón de retry
        if (retryBtn) {
            retryBtn.classList.remove('checking');
        }
    }
}

// Ocultar overlay de conectividad
function hideConnectivityOverlay() {
    if (!isConnectivityOverlayVisible) return;
    
    console.log('✅ Ocultando overlay de conectividad');
    
    const overlay = document.getElementById('connectivity-overlay');
    const retryBtn = document.getElementById('connectivity-retry-btn');
    
    if (overlay) {
        // Mostrar efecto de reconexión exitosa
        overlay.classList.add('reconnected');
        
        // Actualizar contenido para reconexión
        updateConnectivityContent(true);
        
        // Ocultar después de mostrar el éxito
        setTimeout(() => {
            overlay.classList.remove('show', 'reconnected');
            isConnectivityOverlayVisible = false;
            
            // Reabilitar interacciones con el juego
            enableGameInteractions();
            
            // Reset del contenido del overlay
            setTimeout(() => {
                updateConnectivityContent(false);
            }, 500);
            
        }, 2500); // Mostrar éxito por 2.5 segundos
        
        // Reset del botón
        if (retryBtn) {
            retryBtn.classList.remove('checking');
        }
    }
}

// Actualizar contenido del overlay
function updateConnectivityContent(isReconnected) {
    const icon = document.querySelector('.connectivity-icon');
    const title = document.querySelector('.connectivity-title');
    const message = document.querySelector('.connectivity-message');
    
    if (isReconnected) {
        if (icon) icon.textContent = '✅';
        if (title) title.textContent = '¡Reconectado!';
        if (message) message.innerHTML = 'Tu conexión ha sido restablecida.<br>Ya puedes continuar jugando.';
        updateConnectivityStatusText('Conexión restablecida');
    } else {
        if (icon) icon.textContent = '📡';
        if (title) title.textContent = 'Sin Conexión';
        if (message) message.innerHTML = 'Parece que tu conexión a Internet es débil o se ha perdido.<br>Esta aplicación necesita conexión para funcionar correctamente.';
    }
}

// Actualizar texto de estado
function updateConnectivityStatusText(text) {
    const statusText = document.getElementById('connectivity-status-text');
    if (statusText) {
        statusText.textContent = text;
    }
}

// Manejar clic en botón de reintentar
async function handleRetryConnection() {
    const retryBtn = document.getElementById('connectivity-retry-btn');
    
    if (retryBtn) {
        retryBtn.classList.add('checking');
        retryBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Verificando...</span>';
    }
    
    updateConnectivityStatusText('Reintentando conexión...');
    
    // Esperar un poco antes de verificar
    setTimeout(async () => {
        await checkInternetConnection();
        
        // Restaurar botón después de un tiempo
        setTimeout(() => {
            if (retryBtn && !lastConnectionStatus) {
                retryBtn.classList.remove('checking');
                retryBtn.innerHTML = '<i class="fas fa-redo"></i><span>Intentar de nuevo</span>';
            }
        }, 2000);
    }, 1500);
}

// Desabilitar interacciones del juego
function disableGameInteractions() {
    console.log('🚫 Deshabilitando interacciones del juego');
    
    // Pausar el juego si está en progreso
    if (typeof stopAutoSave === 'function') {
        stopAutoSave();
    }
    
    // Desabilitar botones principales
    const gameButtons = document.querySelectorAll('.button, .pill, .back-arrow');
    gameButtons.forEach(button => {
        button.style.pointerEvents = 'none';
        button.style.opacity = '0.5';
    });
    
    // Desabilitar flashcards
    const flashcards = document.querySelectorAll('.flashcard');
    flashcards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.7';
    });
    
    // Pausar reconocimiento de voz si está activo
    if (typeof stopListening === 'function') {
        stopListening();
    }
}

// Reabilitar interacciones del juego
function enableGameInteractions() {
    console.log('✅ Rehabilitando interacciones del juego');
    
    // Reanudar auto-guardado
    if (typeof startAutoSave === 'function') {
        startAutoSave();
    }
    
    // Rehabilitar botones
    const gameButtons = document.querySelectorAll('.button, .pill, .back-arrow');
    gameButtons.forEach(button => {
        button.style.pointerEvents = 'auto';
        button.style.opacity = '1';
    });
    
    // Rehabilitar flashcards
    const flashcards = document.querySelectorAll('.flashcard');
    flashcards.forEach(card => {
        card.style.pointerEvents = 'auto';
        card.style.opacity = '1';
    });
}

// Iniciar verificación periódica
function startPeriodicConnectivityCheck() {
    // Limpiar intervalo previo si existe
    if (connectivityCheckInterval) {
        clearInterval(connectivityCheckInterval);
    }
    
    // Verificar cada 15 segundos
    connectivityCheckInterval = setInterval(() => {
        // Solo verificar si no hay una verificación en progreso
        if (!connectivityCheckInProgress) {
            checkInternetConnection();
        }
    }, 15000);
    
    console.log('⏰ Verificación periódica de conectividad iniciada (cada 15 segundos)');
}

// Detener verificación periódica
function stopPeriodicConnectivityCheck() {
    if (connectivityCheckInterval) {
        clearInterval(connectivityCheckInterval);
        connectivityCheckInterval = null;
        console.log('⏹️ Verificación periódica de conectividad detenida');
    }
}

// Limpiar al salir de la página
window.addEventListener('beforeunload', () => {
    stopPeriodicConnectivityCheck();
});

// === SISTEMA MEJORADO DE OCULTACIÓN DE CURSOR EN MÓVILES ===
let keyboardState = {
    isVisible: false,
    lastHeight: window.innerHeight,
    detectionTimer: null,
    blurTimer: null
};

function isMobileDevice() {
    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                    (window.innerWidth <= 768 && 'ontouchstart' in window);
    return isMobile;
}

function setCursorState(visible, reason = '') {
    if (!isMobileDevice()) return;
    
    const body = document.body;
    const html = document.documentElement;
    
    // Limpiar todas las clases previas
    body.classList.remove('keyboard-visible', 'keyboard-hidden');
    html.classList.remove('keyboard-visible', 'keyboard-hidden');
    
    if (visible) {
        body.classList.add('keyboard-visible');
        html.classList.add('keyboard-visible');
        console.log('👁️ Cursor MOSTRADO:', reason);
    } else {
        body.classList.add('keyboard-hidden');
        html.classList.add('keyboard-hidden');
        console.log('🚫 Cursor OCULTO:', reason);
        
        // Forzar blur en todos los inputs para eliminar el cursor parpadeante
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
            activeElement.blur();
        }

        // Ocultar también el botón móvil "No sé" si está presente
        document.querySelectorAll('.mobile-skip-button').forEach(btn => {
            btn.classList.remove('keyboard-visible');
        });
    }
    
    keyboardState.isVisible = visible;
}

function detectKeyboardByViewport() {
    if (!isMobileDevice()) return;
    
    const currentHeight = window.innerHeight;
    const heightDiff = keyboardState.lastHeight - currentHeight;
    
    console.log(`📏 Viewport: ${keyboardState.lastHeight} → ${currentHeight} (diff: ${heightDiff})`);
    
    // Teclado apareció (viewport se redujo significativamente)
    if (heightDiff > 120 && !keyboardState.isVisible) {
        setCursorState(true, `Viewport reducido ${heightDiff}px`);
    }
    // Teclado desapareció (viewport aumentó)
    else if (heightDiff < -50 && keyboardState.isVisible) {
        setCursorState(false, `Viewport aumentado ${Math.abs(heightDiff)}px`);
    }
    
    keyboardState.lastHeight = currentHeight;
}

function handleInputFocus(event) {
    if (!isMobileDevice()) return;
    
    console.log('🎯 INPUT FOCUS - Mostrando cursor inmediatamente');
    
    // Limpiar timer de blur previo
    if (keyboardState.blurTimer) {
        clearTimeout(keyboardState.blurTimer);
        keyboardState.blurTimer = null;
    }
    
    // Mostrar cursor inmediatamente
    setCursorState(true, 'Input enfocado');
    
    // Detectar teclado después de un delay
    if (keyboardState.detectionTimer) {
        clearTimeout(keyboardState.detectionTimer);
    }
    
    keyboardState.detectionTimer = setTimeout(() => {
        detectKeyboardByViewport();
    }, 300);
}

function handleInputBlur(event) {
    if (!isMobileDevice()) return;
    
    console.log('� INPUT BLUR - Preparando ocultar cursor');
    
    // Limpiar timer previo
    if (keyboardState.blurTimer) {
        clearTimeout(keyboardState.blurTimer);
    }
    
    // Esperar antes de ocultar por si hay otro input que toma el foco
    keyboardState.blurTimer = setTimeout(() => {
        const activeEl = document.activeElement;
        const hasActiveFocus = activeEl && (
            activeEl.tagName === 'INPUT' || 
            activeEl.tagName === 'TEXTAREA' ||
            activeEl.contentEditable === 'true'
        );
        
        if (!hasActiveFocus) {
            console.log('⏰ Timer blur - Ocultando cursor');
            setCursorState(false, 'Sin inputs activos');
        } else {
            console.log('⏰ Timer blur - Manteniendo cursor (otro input activo)');
        }
    }, 150);
}

function forceHideCursor() {
    if (!isMobileDevice()) return;
    
    console.log('🔨 FORZAR OCULTAR CURSOR');
    setCursorState(false, 'Forzado');
    
    // Forzar blur en todos los elementos
    document.querySelectorAll('input, textarea, [contenteditable]').forEach(el => {
        if (el === document.activeElement) {
            el.blur();
        }
    });
}

function initCursorHiding() {
    if (!isMobileDevice()) {
        console.log('💻 Desktop - Cursor siempre visible');
        return;
    }
    
    console.log('📱 Móvil detectado - Inicializando ocultación de cursor');
    
    // Estado inicial: cursor oculto
    setCursorState(false, 'Estado inicial');
    
    // Eventos de focus/blur
    document.addEventListener('focusin', handleInputFocus, true);
    document.addEventListener('focusout', handleInputBlur, true);
    
    // Detectar cambios de viewport
    window.addEventListener('resize', () => {
        if (keyboardState.detectionTimer) {
            clearTimeout(keyboardState.detectionTimer);
        }
        keyboardState.detectionTimer = setTimeout(() => {
            detectKeyboardByViewport();
            if (!keyboardState.isVisible) {
                // Ocultar cualquier botón móvil "No sé"
                document.querySelectorAll('.mobile-skip-button').forEach(btn => btn.classList.remove('keyboard-visible'));
            }
        }, 100);
    });
    
    // Detectar cambios de orientación
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            keyboardState.lastHeight = window.innerHeight;
            detectKeyboardByViewport();
        }, 600);
    });
    
    // Forzar ocultar cursor al hacer clic fuera de inputs
    document.addEventListener('touchstart', (e) => {
        const target = e.target;
        if (target && target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA' && 
            target.contentEditable !== 'true') {
            setTimeout(() => {
                if (document.activeElement.tagName === 'BODY') {
                    forceHideCursor();
                }
            }, 100);
        }
    });
    
    // Observer para nuevos elementos de entrada
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
                if (node.nodeType === 1) {
                    const inputs = node.querySelectorAll ? node.querySelectorAll('input, textarea, [contenteditable]') : [];
                    if (inputs.length > 0) {
                        console.log(`🆕 ${inputs.length} nuevos inputs detectados`);
                    }
                }
            });
        });
    });
    
    observer.observe(document.body, { childList: true, subtree: true });
    
    console.log('✅ Sistema de ocultación de cursor inicializado');
}

// Inicializar cuando esté listo
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initCursorHiding, 200);
    });
} else {
    setTimeout(initCursorHiding, 200);
}

// También en load como respaldo
window.addEventListener('load', () => {
    setTimeout(initCursorHiding, 100);
});

function debugGameState() {
    console.log('=== DEBUG GAME STATE ===');
    console.log('currentCardIndex:', currentCardIndex);
    console.log('Total flashcards:', flashcards.length);
    console.log('completedCards:', Array.from(completedCards));
    console.log('correctCount:', correctCount);
    console.log('incorrectCount:', incorrectCount);
    console.log('voiceAttempts:', voiceAttempts);
    console.log('========================');
}

// Modificar la función goToNextCard para añadir debug
function goToNextCardWithDebug() {
    console.log('🔄 goToNextCard called');
    debugGameState();
    
    // Reactivar el botón de mezclar al pasar a la siguiente tarjeta
    document.getElementById('shuffle-button').disabled = false;

    // REPRODUCIR SONIDO DE NAIPE al cambiar de tarjeta
    document.getElementById('shuffleSound').play().catch(() => {});

    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
    console.log('📊 Flashcards encontradas:', flashcards.length);
    
    completedCards.add(currentCardIndex);
    console.log('✅ Tarjeta marcada como completada:', currentCardIndex);
    console.log('📈 Total completadas:', completedCards.size);
    
    updateCardCounter();
    
    // GUARDAR PROGRESO AUTOMÁTICAMENTE al completar una tarjeta
    saveGameProgress();
    
    canFlipBack = true;
    canFlip = true;
    updateCounters();
    voiceAttempts = 0;
    
    // Limpiar timeouts
    if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
    if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }
    showingErrorMessage = false;
    lockedAfterSecondIncorrect = false;
    lockedAfterCorrect = false;

    // Buscar la siguiente tarjeta pendiente
    const total = flashcards.length;
    let nextIndex = -1;
    console.log('🔍 Buscando siguiente tarjeta...');
    
    for (let step = 1; step <= total; step++) {
        const i = (currentCardIndex + step) % total;
        console.log(`   Checking index ${i}, completed: ${completedCards.has(i)}`);
        if (!completedCards.has(i)) {
            nextIndex = i;
            console.log(`✨ Found next card at index: ${nextIndex}`);
            break;
        }
    }
    
    if (nextIndex !== -1) {
        console.log('➡️ Moving to next card:', nextIndex);
        currentCardIndex = nextIndex;
        showCard(currentCardIndex);
    } else {
        console.log('🏁 No more cards - showing completion');
        // Resto del código de finalización...
        saveLastGamePercentage();
        
        if (correctCount > incorrectCount) {
            if (incorrectCount === 0) {
                showCompletionEuforiaMaxima();
            } else {
                showCompletioneuforia();
            }
        } else if (incorrectCount > correctCount) {
            showCompletionPerdida();
        } else {
            showCompletionEmpate();
        }
    }
    
    console.log('🔄 goToNextCard finished');
}
    </script>
    
        <!-- Teclado virtual global -->
        <div id="vk-overlay" class="virtual-keyboard-overlay">
            <div id="vk" class="virtual-keyboard">
                <div class="vk-row" data-row="1"></div>
                <div class="vk-row" data-row="2"></div>
                <div class="vk-row shifted" data-row="3"></div>
                <div class="vk-accents">
                    <div class="row-accents">
                        <div class="vk-key warn" data-key="á">á</div>
                        <div class="vk-key warn" data-key="é">é</div>
                        <div class="vk-key warn" data-key="í">í</div>
                        <div class="vk-key warn" data-key="ó">ó</div>
                        <div class="vk-key warn" data-key="ú">ú</div>
                    </div>
                </div>
                <div class="vk-footer">
                    <div class="vk-controls">
                        <div class="vk-group" role="radiogroup" aria-label="Distribución del teclado">
                            <label class="vk-radio"><input type="radio" name="vk-layout" value="qwerty"><span>QW</span></label>
                            <label class="vk-radio"><input type="radio" name="vk-layout" value="azerty"><span>AZ</span></label>
                        </div>
                        <div class="vk-group" role="radiogroup" aria-label="Idioma del teclado">
                            <label class="vk-radio"><input type="radio" name="vk-lang" value="es"><span>Es</span></label>
                            <label class="vk-radio"><input type="radio" name="vk-lang" value="fr"><span>Fr</span></label>
                        </div>
                    </div>
                    <div class="vk-key space" data-key=" ">ESPACIO</div>
                    <div class="vk-key hide small" data-key="hide" title="Ocultar teclado"><i class="fas fa-chevron-down"></i></div>
                </div>
                </div>
            </div>
        </div>
    
</body>
</html>
