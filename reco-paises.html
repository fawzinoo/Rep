<!DOCTYPE html>
<html lang="es">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <title>Países del mundo</title>
    <style>
        /* Estilos de la barra superior */
        .top-status-bar {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 6px auto 5px auto;
            gap: 2px;
            position: relative;
            z-index: 10;
        }

        .pill {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 1.0em;
            font-weight: 600;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            background: #fff;
            min-width: 60px;
            justify-content: center;
            letter-spacing: 0.3px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .back-arrow {
            background: #fff;
            color: #333;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            gap: 8px;
            border: 1px solid rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .back-arrow:hover {
            background-color: #f5f5f5;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .back-arrow i {
            color: #333;
        }        .pill-faltan {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(255,107,53,0.15);
            gap: 8px;
            border: none;
        }

        .pill-correctas {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(40, 167, 69, 0.15);
            gap: 8px;
            border: none;
        }

        .pill-incorrectas {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(220, 53, 69, 0.15);
            gap: 8px;
            border: none;
        }

        .pill-progreso {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: #fff;
            box-shadow: 0 2px 6px rgba(78,205,196,0.15);
            font-weight: 600;
            font-size: 1.0em;
            min-width: 60px;
            text-align: center;
            transition: all 0.3s ease;
            border: none;
        }

        .pill-progreso:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(78,205,196,0.2);
        }

        /* Estilos básicos */
        body, html {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #505255, #00020a);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            
            /* Eliminar cualquier selección en toda la página */
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-tap-highlight-color: transparent !important;
            -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
            -moz-tap-highlight-color: transparent !important;
        }
        
        /* Eliminar cualquier selección en todos los elementos */
        *, *::before, *::after {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-tap-highlight-color: transparent !important;
            -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
            -moz-tap-highlight-color: transparent !important;
            outline: none !important;
            -webkit-touch-callout: none !important;
            
            /* Prevenir menú contextual en todos los elementos */
            -webkit-context-menu: none !important;
            -moz-context-menu: none !important;
        }
        
        /* Reglas específicas para imágenes */
        img {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-drag: none !important;
            -moz-user-drag: none !important;
            pointer-events: none !important;
            
            /* Prevenir menú contextual específicamente en imágenes */
            -webkit-context-menu: none !important;
            -moz-context-menu: none !important;
        }
        
        /* Reglas específicas para elementos de texto */
        div, span, p, h1, h2, h3, h4, h5, h6 {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-highlight: none !important;
            -moz-highlight: none !important;
        }
        
        /* Eliminar el cursor de texto en elementos clickeables */
        .flashcard, .back, .front {
            cursor: pointer !important;
        }
        
        /* Prevenir selección con pseudo-elementos */
        .back::selection, .back *::selection {
            background: transparent !important;
        }
        
        .back::-moz-selection, .back *::-moz-selection {
            background: transparent !important;
        }
        #flashcard-container-wrapper {
            position: relative;
            width: calc(100% - 20px);
            max-width: 600px;
        }
        #flashcard-container {
            width: 100%;
            height: 500px;
            max-height: 500px;
            perspective: 1000px; /* Para el efecto 3D */
            border-radius: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            position: relative;
            background: linear-gradient(to right, #1f3658, #3558e3);
            border: 3px solid #aab0b4;
            margin: 0;
        }
        .flashcard, .results-card {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.4, 0.2, 0.2, 1);
            border-radius: 15px;
            cursor: pointer;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            
            /* Prevenir selección de texto en toda la tarjeta */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .flashcard.is-visible { display: flex; }
        
        /* Parte frontal y trasera de la tarjeta */
        .front, .back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Oculta la cara trasera al girar */
            border-radius: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            
            /* Mantener eventos de clic en las caras de la tarjeta */
            pointer-events: auto !important;
        }
    
        .card-back {
            transform: rotateY(180deg); /* Gira la parte trasera */
        }
    
        /* Estilo de la parte frontal */
        .front img, .back img { 
            width: 100%; 
            height: 100%;
            
            /* Prevenir menú contextual y arrastrar en imágenes */
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-drag: none !important;
            -moz-user-drag: none !important;
            pointer-events: none !important;
        }
    
        /* Estilo de la parte trasera */
        .back {
    width: 100%;
    background: linear-gradient(to bottom, rgba(73, 115, 189, 0.95), rgba(14, 40, 92, 0.9)); /* Fondo azul oscuro */
    color: #ffffff; /* Color del texto */
    transform: rotateY(180deg); /* Rotación para el efecto */
    padding: 20px; /* Margen interno */
    text-align: center; /* Centrado horizontal */
    font-size: 3rem; /* Tamaño del texto */
    font-family: 'Playfair Display', serif; /* Fuente elegante */
    border-radius: 10px; /* Bordes redondeados */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Sombra más pronunciada */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); /* Sombra del texto más fuerte */
    display: flex; /* Flexbox para el centrado */
    justify-content: center; /* Centrar horizontalmente */
    align-items: center; /* Centrar verticalmente */
    flex-direction: column; /* Asegura que el texto fluya en columnas */
    height: 100%; /* Usa toda la altura disponible */
    max-width: 100%; /* Limita el ancho máximo */
    margin: 0 auto; /* Centra dentro del contenedor */
    line-height: 1.4; /* Espaciado entre líneas */
    
    /* Prevenir selección de texto - Completo */
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
    -webkit-touch-callout: none !important;
    -webkit-tap-highlight-color: transparent !important;
    -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
    -moz-tap-highlight-color: transparent !important;
    outline: none !important;
    
    /* Prevenir arrastrar */
    -webkit-user-drag: none !important;
    -moz-user-drag: none !important;
    
    /* Eliminar cualquier outline o focus */
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    appearance: none !important;
}

        /* Ocultar texto cuando está en modo escucha */
        .back.hidden-text {
            color: transparent;
            text-shadow: none;
        }
        
        /* Asegurar que el indicador NUNCA se oculte ni herede color transparente */
        .back.hidden-text .super-pulse-indicator {
            color: #fff !important; /* Forzar color visible */
            -webkit-text-fill-color: #fff !important; /* Safari/iOS */
            opacity: 1 !important;
            display: block !important;
            visibility: visible !important;
        }
        /* Permitir que las letras usen su propio color aunque el contenedor fuerce el fill a blanco */
        .back.hidden-text .super-pulse-indicator .floating-emoji {
            -webkit-text-fill-color: currentColor !important; /* usa el color de .e1..e7 */
        }
        /* Asegurar que el emoji del micrófono no herede color transparente */
        .back.hidden-text .mic-emoji {
            color: #fff !important;
            -webkit-text-fill-color: #fff !important;
        }

        /* Indicador de escucha de voz */
        .listening-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 1.5rem;
            text-align: center;
            animation: pulse 1s infinite;
            z-index: 10;
        }

        @keyframes pulse {
            0% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
        }

        /* Contador moderno y elegante */
        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 25px;
        }

        .countdown-number {
            font-size: 8rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            animation: countdownPulse 1s ease-in-out;
            z-index: 1001;
        }

        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .countdown-circle {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: countdownRotate 1s linear;
        }

        @keyframes countdownRotate {
            0% { transform: rotate(0deg) scale(0.8); border-color: rgba(255, 255, 255, 0.3); }
            50% { transform: rotate(180deg) scale(1.1); border-color: rgba(255, 255, 255, 0.8); }
            100% { transform: rotate(360deg) scale(1); border-color: rgba(255, 255, 255, 0.5); }
        }

.back::before, .back::after {
    content: '';
    position: absolute;
    width: 150px; /* Ajusta el tamaño de la forma */
    height: 150px; /* Ajusta el tamaño de la forma */
    background: rgba(255, 255, 255, 0.3); /* Círculos más claros y visibles */
    border-radius: 50%; /* Forma circular */
    z-index: 0; /* Coloca detrás del texto */
}

.back::before {
    top: -30px; /* Ajusta la posición */
    left: -30px; /* Ajusta la posición */
}

.back::after {
    bottom: -30px; /* Ajusta la posición */
    right: -30px; /* Ajusta la posición */
}

    
        /* El efecto de voltear */
        .flashcard.flipped {
            transform: rotateY(180deg); /* Al hacer clic, se voltea la tarjeta */
        }
    
/* Contenedor de botones */
.button-container {
    width: 100%;
    max-width: 370px;
    display: flex;
    justify-content: space-evenly; /* Espacio uniforme entre todos los botones */
    align-items: center;
    padding: 10px 0px;
    background-color: #ffffff;
    border-radius: 15px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    margin-top: 10px;
}



/* Botones individuales */
.button {
    padding: 10px 15px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 50px;
    background-color: #3498db;
    color: #fff;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}
     
        .button:hover { transform: translateY(-3px); }





.overlay-text {
    position: absolute;
    z-index: 1; /* Colocar por encima del contenido */
    color: white; /* Color del texto */
    font-size: 2rem; /* Tamaño del texto */
    font-weight: bold; /* Texto en negrita */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Sombra del texto */
    text-align: left; /* Alineación a la izquierda */
    pointer-events: none; /* No interferir con los clics */
    margin: 5%; /* Margen relativo */
    line-height: 1.5; /* Espaciado entre líneas */
    top: 40%; /* Posición específica desde arriba */
    left: 0%; /* Posición específica desde la izquierda */
}

/* Estilos para .overlay-text1 */
.overlay-text1 {
    position: absolute;
    top: 5px;
    z-index: 1;
    color: rgb(185, 232, 203); /* Color específico */
    font-size: 2rem; /* Tamaño del texto */
    font-weight: bold; /* Texto en negrita */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Sombra del texto */
    text-align: center; /* Centrado */
    pointer-events: none; /* No interferir con clics */
    display: inline-block; /* Comportamiento inline */
    animation: pulse 1.5s infinite; /* Animación pulsante */
}

/* Estilos para .overlay-text2 */
.overlay-text2 {
    position: absolute;
    z-index: 1;
    color: white; /* Color del texto */
    font-size: 2rem; /* Tamaño del texto */
    font-weight: bold; /* Negrita */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Sombra del texto */
    text-align: left; /* Alineación a la izquierda */
    pointer-events: none; /* No interferir con clics */
    margin: 30px; /* Márgenes específicos */
    top: 40%; /* Posición específica desde arriba */
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.1);
    opacity: 0.8;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes moveLeftToRight {
  0% {
    transform: translateX(0); /* Posición inicial */
  }
  50% {
    transform: translateX(10px); /* Mueve hacia la derecha */
  }
  100% {
    transform: translateX(0); /* Vuelve a la posición original */
  }
}



.back-arrow {
    background: #fff;
    color: #333;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    gap: 8px;
    border: 1px solid rgba(0,0,0,0.05);
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
}

.back-arrow:hover {
    background-color: #f5f5f5;
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.back-arrow i {
    color: #333;
}

.intentos-back {
    position: absolute;
    top: 18px;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 0.9rem;
    font-weight: bold;
    color: #f0e49c;
    z-index: 2;
    pointer-events: none;
}

.pill-intentos {
    background: linear-gradient(135deg, #ebac6d 0%, #a88f07 100%);
    color: #fff;
    box-shadow: 0 2px 6px rgba(255, 78, 80, 0.15);
    border-radius: 20px;
    padding: 2px 2px;
    font-size: 0.9em;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    border: none;
    margin-bottom: 4px;
}
.pill-intentos i {
    font-size: 0.9em;
}


@keyframes intentosFlash {
  0% { box-shadow: 0 0 0 0 #fff700, 0 2px 6px rgba(255, 78, 80, 0.15); }
  50% { box-shadow: 0 0 16px 8px #fff700, 0 2px 6px rgba(255, 78, 80, 0.15); }
  100% { box-shadow: 0 0 0 0 #fff700, 0 2px 6px rgba(255, 78, 80, 0.15); }
}
.pill-intentos.flash {
  animation: intentosFlash 0.7s;
}

/* --- NUEVO EFECTO DE ADVERTENCIA --- */
@keyframes intentosWarningFlash {
  0% { box-shadow: 0 0 0 0 #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15); }
  50% { box-shadow: 0 0 16px 8px #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15); }
  100% { box-shadow: 0 0 0 0 #ffae00, 0 2px 6px rgba(255, 120, 80, 0.15); }
}
.pill-intentos.flash-warning {
  animation: intentosWarningFlash 0.7s;
}
.super-pulse-indicator {
    position: absolute !important; /* Dentro del lado back */
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    text-align: center;
    z-index: 9999 !important; /* Z-index muy alto para estar por encima de todo */
    width: auto;
    pointer-events: none; /* Para que no interfiera con los clics */
    display: block !important; /* Forzar visibilidad */
    opacity: 1 !important; /* Forzar opacidad */
    visibility: visible !important; /* Forzar visibilidad */
}

.super-pulse-container {
    position: relative;
    width: 140px;   /* más espacio para una órbita segura */
    height: 140px;  /* más espacio para una órbita segura */
    margin: 0 auto 30px; /* separar de mensajes inferiores */
    /* Variables para controlar una órbita estable (tipo luna-tierra) */
    --center-size: 70px;           /* Tamaño del círculo blanco (pulse-center) */
    --center-scale-max: 1.1;       /* Escala máxima por animación centerBounce */
    --letter-size: 1.1rem;         /* Igual que .floating-emoji font-size para cálculo preciso */
    --safety-gap: 16px;            /* Más separación para asegurar que no invada el círculo */
    /* Radio real de la órbita: mitad del centro (con su escala máxima) + semi ancho de letra + gap */
    --orbit-radius: calc((var(--center-size) * var(--center-scale-max) / 2) + (var(--letter-size) / 2) + var(--safety-gap));
}

.pulse-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    border: 3px solid rgba(255, 255, 255, 0.8);
}

.pulse-ring-1 {
    width: 60px;
    height: 60px;
    animation: superPulseRing 2s infinite ease-out;
    border-color: rgba(255, 215, 0, 0.9);
}

.pulse-ring-2 {
    width: 80px;
    height: 80px;
    animation: superPulseRing 2s infinite ease-out;
    animation-delay: 0.5s;
    border-color: rgba(0, 255, 127, 0.7);
}

.pulse-ring-3 {
    width: 100px;
    height: 100px;
    animation: superPulseRing 2s infinite ease-out;
    animation-delay: 1s;
    border-color: rgba(255, 69, 0, 0.6);
}

.pulse-ring-4 {
    width: 120px;
    height: 120px;
    animation: superPulseRing 2s infinite ease-out;
    animation-delay: 1.5s;
    border-color: rgba(138, 43, 226, 0.5);
}

@keyframes superPulseRing {
    0% {
        transform: translate(-50%, -50%) scale(0.3);
        opacity: 1;
        border-width: 4px;
    }
    50% {
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0.8;
        border-width: 2px;
    }
    100% {
        transform: translate(-50%, -50%) scale(1.5);
        opacity: 0;
        border-width: 1px;
    }
}

.pulse-center {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #f8fafc 0%, #e0e7ef 100%);
    background-size: 400% 400%;
    animation: centerGradient 3s ease infinite, centerBounce 1.5s ease-in-out infinite;
    border-radius: 50%;
    width: 70px;
    height: 70px;
    z-index: 10; /* Asegura que el mic y el centro estén por encima de la órbita */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 20px rgba(120, 180, 255, 0.25);
}

@keyframes centerGradient {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

@keyframes centerBounce {
    0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    50% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
}

.mic-emoji {
    font-size: 2rem;
    margin-bottom: 0.5px;
    margin-top: 0;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
    animation: micWiggle 2s ease-in-out infinite;
    display: flex;
    align-items: center;
    justify-content: center;
}

@keyframes micWiggle {
    0%, 100% { transform: rotate(-3deg); }
    50% { transform: rotate(3deg); }
}

.sound-waves {
    display: flex;
    gap: 6px;
    margin-top: 0;
    margin-bottom: 0;
    justify-content: center;
    align-items: center;
}

.wave-dot {
    width: 4px;
    height: 4px;
    background: #e0c605;
    border-radius: 50%;
    animation: waveUp 1s ease-in-out infinite;
    box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
}

.wave-dot:nth-child(1) { animation-delay: 0s; }
.wave-dot:nth-child(2) { animation-delay: 0.2s; }
.wave-dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes waveUp {
    0%, 100% { transform: translateY(0px) scale(1); opacity: 0.7; }
    50% { transform: translateY(-8px) scale(1.3); opacity: 1; }
}

.floating-emojis {
    position: absolute;
    inset: 0;
    pointer-events: none;
    /* El radio de la órbita se calcula para NO entrar en el círculo central en ningún momento */
    --radius: var(--orbit-radius);
    transform-origin: 50% 50%;
    /* NO hay animación aquí - cada letra orbita individualmente */
    z-index: 4; /* por debajo del centro para no tapar el micrófono */
}

.floating-emoji {
    position: absolute;
    top: 50%;
    left: 50%;
    font-size: 1.1rem; /* ligeramente menor para mayor claridad */
    opacity: 0.9;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    transform-origin: 50% 50%; /* rota desde el centro del contenedor */
    -webkit-text-fill-color: currentColor !important; /* asegurar que el color de texto real sea el propio */
    /* Cada letra orbita individualmente para mantener el centro fijo */
    animation: letterOrbit 24s linear infinite;
    pointer-events: none;
}
 
/* Distribución equidistante de E-S-P-A-Ñ-O-L (360/7 ≈ 51.4286°) */
/* Colores elegantes desde el primer intento */
.e1 { color: #8B5CF6 !important; font-weight: 700; animation-delay: -6s; text-shadow: 0 0 8px rgba(139, 92, 246, 0.4); }     /* E - Púrpura elegante */
.e2 { color: #06B6D4 !important; font-weight: 700; animation-delay: -9.43s; text-shadow: 0 0 8px rgba(6, 182, 212, 0.4); }  /* S - Cian vibrante */
.e3 { color: #F59E0B !important; font-weight: 700; animation-delay: -12.86s; text-shadow: 0 0 8px rgba(245, 158, 11, 0.4); } /* P - Ámbar dorado */
.e4 { color: #EF4444 !important; font-weight: 700; animation-delay: -16.29s; text-shadow: 0 0 8px rgba(239, 68, 68, 0.4); } /* A - Rojo coral */
.e5 { color: #10B981 !important; font-weight: 700; animation-delay: -19.71s; text-shadow: 0 0 8px rgba(16, 185, 129, 0.4); } /* Ñ - Esmeralda */
.e6 { color: #3B82F6 !important; font-weight: 700; animation-delay: -23.14s; text-shadow: 0 0 8px rgba(59, 130, 246, 0.4); } /* O - Azul real */
.e7 { color: #EC4899 !important; font-weight: 700; animation-delay: -2.57s; text-shadow: 0 0 8px rgba(236, 72, 153, 0.4); }  /* L - Rosa magenta */

/* Se eliminan bailes individuales para que todos giren en la misma órbita */

/* Órbita individual de cada letra manteniendo el centro fijo */
@keyframes letterOrbit {
    0%   { transform: translate(-50%, -50%) rotate(0deg) translateX(var(--radius)) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg) translateX(var(--radius)) rotate(-360deg); }
}

/* Animación anterior mantenida por compatibilidad */
@keyframes slowOrbit {
    0%   { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes floatAround {
    0%, 100% { 
        transform: translateY(0px) translateX(0px) rotate(0deg) scale(1); 
        opacity: 0.6;
    }
    25% { 
        transform: translateY(-15px) translateX(10px) rotate(90deg) scale(1.2); 
        opacity: 1;
    }
    50% { 
        transform: translateY(-10px) translateX(-5px) rotate(180deg) scale(0.9); 
        opacity: 0.8;
    }
    75% { 
        transform: translateY(-20px) translateX(15px) rotate(270deg) scale(1.1); 
        opacity: 1;
    }
}

@keyframes floatAroundE3 {
    0%, 100% {
        transform: translateY(0px) translateX(0px) rotate(0deg) scale(1);
        opacity: 0.7;
    }
    25% {
        transform: translateY(-1px) translateX(20px) rotate(20deg) scale(1.1);
        opacity: 1;
    }
    50% {
        transform: translateY(1px) translateX(15px) rotate(40deg) scale(1.05);
        opacity: 0.9;
    }
    75% {
        transform: translateY(0px) translateX(-10px) rotate(10deg) scale(1.1);
        opacity: 1;
    }
}

.super-pulse-text {
    color: #fff;
    font-size: 1.4rem;
    font-weight: bold;
    margin-bottom: 8px;
    text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 2px 4px rgba(0,0,0,0.5);
    animation: textGlow 2s ease-in-out infinite;
}

@keyframes textGlow {
    0%, 100% { 
        text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 2px 4px rgba(0,0,0,0.5);
        transform: scale(1);
    }
    50% { 
        text-shadow: 0 0 20px rgba(255,215,0,1), 0 0 30px rgba(255,215,0,0.8), 0 2px 4px rgba(0,0,0,0.5);
        transform: scale(1.02);
    }
}

.super-pulse-subtitle {
    color: #ffeb3b;
    font-size: 1.1rem;
    font-weight: 600;
    animation: subtitleSlide 4s ease-in-out infinite;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

.super-pulse-subtitle {
    color: #ffeb3b;
    font-size: 1.05rem;
    font-weight: 600; /* mismo peso visual que el segundo intento */
    animation: subtitleSlide 4s ease-in-out infinite;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    margin-top: 6px;
}

/* Forzar que el subtítulo mantenga su color amarillo en cualquier intento */
.super-pulse-indicator .super-pulse-subtitle {
    color: #ffeb3b !important;
    -webkit-text-fill-color: #ffeb3b !important; /* Safari/iOS */
}

/* Si el back está en hidden-text, mantener el color del subtítulo */
.back.hidden-text .super-pulse-indicator .super-pulse-subtitle {
    color: #ffeb3b !important;
    -webkit-text-fill-color: #ffeb3b !important;
}

@keyframes subtitleSlide {
    0%, 100% { 
        transform: translateX(0px); 
        opacity: 0.8; 
    }
    25% { 
        transform: translateX(5px); 
        opacity: 1; 
    }
    50% { 
        transform: translateX(-5px); 
        opacity: 0.9; 
    }
    75% { 
        transform: translateX(3px); 
        opacity: 1; 
    }
}

.back .super-pulse-indicator {
    position: absolute !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    z-index: 999 !important;
    width: auto !important;
    height: auto !important;
}

.super-pulse-container {
    position: relative;
    width: 120px;
    height: 120px;
    margin: 0 auto 25px;
    z-index: 1000;
}

/* Añade esto en tu sección de estilos */
@keyframes fadeInOut {
    0% { 
        opacity: 0;
        transform: scale(0.8) translateY(20px);
    }
    20% { 
        opacity: 1;
        transform: scale(1.1) translateY(0);
    }
    80% { 
        opacity: 1;
        transform: scale(1) translateY(0);
    }
    100% { 
        opacity: 0;
        transform: scale(0.8) translateY(-20px);
    }
}

@keyframes modernFadeInOut {
    0% { 
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
        filter: blur(2px);
    }
    15% { 
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.05);
        filter: blur(0px);
    }
    85% { 
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        filter: blur(0px);
    }
    100% { 
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
        filter: blur(1px);
    }
}

.mensaje-error {
    position: absolute;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    font-size: 2rem;
    font-weight: bold;
    color: #ff6b6b;
    text-align: center;
    text-shadow: 0 0 10px rgba(255, 107, 107, 0.5),
                 0 0 20px rgba(255, 107, 107, 0.3),
                 0 0 30px rgba(255, 107, 107, 0.2);
    z-index: 1000;
    background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 107, 107, 0.05) 100%);
    padding: 20px 40px;
    border-radius: 15px;
    backdrop-filter: blur(5px);
    border: 2px solid rgba(255, 107, 107, 0.2);
    animation: errorAppearNew 0.5s ease-out, errorDisappearNew 0.5s ease-in 1.5s forwards;
}

@keyframes errorAppearNew {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) perspective(500px) rotateX(-45deg);
        filter: brightness(2);
    }
    50% {
        transform: translate(-50%, -50%) perspective(500px) rotateX(5deg);
        filter: brightness(1.5);
    }
    100% {
        opacity: 1;
        transform: translate(-50%, -50%) perspective(500px) rotateX(0);
        filter: brightness(1);
    }
}

@keyframes errorDisappearNew {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        filter: brightness(1);
    }
    50% {
        transform: translate(-50%, -50%) scale(1.1);
        filter: brightness(1.2);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
        filter: brightness(0);
    }
}

@keyframes respuestaGlow {
    0%, 100% { 
        text-shadow: 0 0 10px rgba(255,255,255,0.5),
                     0 0 20px rgba(255,255,255,0.3);
        transform: scale(1);
    }
    50% { 
        text-shadow: 0 0 15px rgba(255,255,255,0.8),
                     0 0 25px rgba(255,255,255,0.5),
                     0 0 35px rgba(255,255,255,0.3);
        transform: scale(1.05);
    }
}

        .button:hover { transform: translateY(-3px); }

        .button:disabled {
            background-color: #bdc3c7;
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

.overlay-text {
    position: absolute;
    }

    @keyframes errorGlow {
  0% {
    box-shadow: 0 0 0 0 #ff3b3b, 0 2px 6px rgba(220,53,69,0.15);
    background: linear-gradient(135deg, #ff3b3b 0%, #c82333 100%);
    transform: scale(1);
  }
  50% {
    box-shadow: 0 0 24px 12px #ff3b3b, 0 2px 16px rgba(220,53,69,0.25);
    background: linear-gradient(135deg, #ff3b3b 40%, #ffb3b3 100%);
    transform: scale(1.08);
  }
  100% {
    box-shadow: 0 0 0 0 #ff3b3b, 0 2px 6px rgba(220,53,69,0.15);
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    transform: scale(1);
  }
}
.pill-incorrectas.glow-error {
  animation: errorGlow 0.7s;
}

@keyframes correctGlow {
  0% {
    box-shadow: 0 0 0 0 #00e676, 0 2px 6px rgba(40,167,69,0.15);
    background: linear-gradient(135deg, #00e676 0%, #218838 100%);
    transform: scale(1);
  }
  50% {
    box-shadow: 0 0 24px 12px #00e676, 0 2px 16px rgba(40,167,69,0.25);
    background: linear-gradient(135deg, #00e676 40%, #b9f6ca 100%);
    transform: scale(1.08);
  }
  100% {
    box-shadow: 0 0 0 0 #00e676, 0 2px 6px rgba(40,167,69,0.15);
    background: linear-gradient(135deg, #28a745 0%, #218838 100%);
    transform: scale(1);
  }
}
.pill-correctas.glow-correct {
  animation: correctGlow 0.7s;
}

@keyframes faltanGlow {
  0% {
    box-shadow: 0 0 0 0 #ffb347, 0 2px 6px rgba(255,107,53,0.15);
    background: linear-gradient(135deg, #ffb347 0%, #f7931e 100%);
    transform: scale(1);
  }
  50% {
    box-shadow: 0 0 24px 12px #ffb347, 0 2px 16px rgba(255,107,53,0.25);
    background: linear-gradient(135deg, #ffb347 40%, #fff3cd 100%);
    transform: scale(1.08);
  }
  100% {
    box-shadow: 0 0 0 0 #ffb347, 0 2px 6px rgba(255,107,53,0.15);
    background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
    transform: scale(1);
  }
}
.pill-faltan.glow-faltan {
  animation: faltanGlow 0.7s;
}

.flashcard.transition-out {
    animation: cardSlideUp 0.5s forwards;
    z-index: 2;
}
.flashcard.transition-in {
    animation: cardSlideIn 0.5s forwards;
    z-index: 3;
}
@keyframes cardSlideUp {
    0% { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(-120%) scale(0.95); opacity: 0; }
}
@keyframes cardSlideIn {
    0% { transform: translateY(120%) scale(0.95); opacity: 0; }
    100% { transform: translateY(0) scale(1); opacity: 1; }
}

.countdown-inline {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 32px;
    animation: fadeInOut 4s;
    z-index: 10;
    position: relative;
}

.countdown-inline-circle {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    background: linear-gradient(135deg, #4ecdc4 0%, #3558e3 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 8px;
    box-shadow: 0 4px 16px rgba(78,205,196,0.18);
    border: 3px solid #fff;
}

.countdown-inline-number {
    font-size: 2.5rem;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 2px 8px rgba(0,0,0,0.18);
    letter-spacing: 1px;
}

.countdown-inline-text {
    font-size: 1.1rem;
    color: #e0e7ef;
    margin-top: 2px;
    font-weight: 500;
    text-shadow: 0 1px 3px rgba(0,0,0,0.12);
}

.pulse-timer {
    animation: pulse 1s;
}

.flashcard.transition-out {
    animation: cardSlideLeft 0.5s forwards;
    z-index: 2;
}
.flashcard.transition-in {
    animation: cardSlideFromRight 0.5s forwards;
    z-index: 3;
}
@keyframes cardSlideLeft {
    0% { transform: translateX(0) scale(1); opacity: 1; }
    100% { transform: translateX(-120%) scale(0.95); opacity: 0; }
}
@keyframes cardSlideFromRight {
    0% { transform: translateX(120%) scale(0.95); opacity: 0; }
    100% { transform: translateX(0) scale(1); opacity: 1; }
}

@keyframes bounce {
    0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
    }
    40% {
        transform: translateY(-20px);
    }
    60% {
        transform: translateY(-10px);
    }
}

/* === ANIMACIONES DE EUFORIA (Alegres y eufóricas) === */
@keyframes euforiaEntrance {
    0% { 
        opacity: 0; 
        transform: scale(0.3) rotate(-180deg); 
        background: linear-gradient(135deg, #ff7675 0%, #fd79a8 50%, #fdcb6e 100%);
    }
    50% { 
        transform: scale(1.2) rotate(0deg); 
        background: linear-gradient(135deg, #00b894 0%, #00cec9 50%, #0984e3 100%);
    }
    100% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg); 
        background: linear-gradient(135deg, #28a745 0%, #20c997 50%, #17a2b8 100%);
    }
}

@keyframes celebrationBounce {
    0%, 20%, 50%, 80%, 100% { transform: translateY(0) rotate(0deg) scale(1); }
    10% { transform: translateY(-30px) rotate(15deg) scale(1.2); }
    30% { transform: translateY(-15px) rotate(-10deg) scale(1.1); }
    60% { transform: translateY(-25px) rotate(12deg) scale(1.15); }
    90% { transform: translateY(-10px) rotate(-8deg) scale(1.05); }
}

@keyframes euforiaWiggle {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(5deg) scale(1.05); }
    50% { transform: rotate(0deg) scale(1.1); }
    75% { transform: rotate(-5deg) scale(1.05); }
}

@keyframes happyFloat {
    0%, 100% { transform: translateY(0px) scale(1); opacity: 0.9; }
    50% { transform: translateY(-15px) scale(1.02); opacity: 1; }
}

@keyframes sparkle {
    0%, 100% { opacity: 0.8; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.05); }
}

/* === ANIMACIONES DE PÉRDIDA (Tristes y desanimadas) === */
@keyframes sadFadeIn {
    0% { 
        opacity: 0; 
        transform: scale(1.2); 
        filter: brightness(0.3);
    }
    100% { 
        opacity: 1; 
        transform: scale(1); 
        filter: brightness(1);
    }
}

@keyframes sadDrop {
    0% { transform: translateY(0px) rotate(0deg); }
    20% { transform: translateY(10px) rotate(-2deg); }
    40% { transform: translateY(5px) rotate(1deg); }
    60% { transform: translateY(8px) rotate(-1deg); }
    80% { transform: translateY(3px) rotate(0.5deg); }
    100% { transform: translateY(0px) rotate(0deg); }
}

@keyframes disappointedSway {
    0%, 100% { transform: rotate(0deg) translateX(0px); }
    33% { transform: rotate(-2deg) translateX(-5px); }
    66% { transform: rotate(2deg) translateX(5px); }
}

@keyframes gentleFloat {
    0%, 100% { transform: translateY(0px); opacity: 0.9; }
    50% { transform: translateY(-8px); opacity: 0.7; }
}

@keyframes fadingHope {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 0.5; }
}

/* === ANIMACIONES DE EMPATE (Neutrales y equilibradas) === */
@keyframes neutralZoom {
    0% { 
        opacity: 0; 
        transform: scale(0.8); 
    }
    50% { 
        transform: scale(1.05); 
    }
    100% { 
        opacity: 1; 
        transform: scale(1); 
    }
}

@keyframes balanceSway {
    0%, 100% { transform: rotate(-8deg); }
    50% { transform: rotate(8deg); }
}

@keyframes steadyPulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.03); opacity: 0.95; }
}

@keyframes calmWave {
    0%, 100% { transform: translateY(0px) translateX(0px); }
    33% { transform: translateY(-5px) translateX(3px); }
    66% { transform: translateY(0px) translateX(-3px); }
}

@keyframes steadyGlow {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
}

/* === ANIMACIONES DE EUFORIA MÁXIMA (Perfecto) === */
@keyframes rainbowBackground {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

@keyframes perfectEntrance {
    0% { 
        opacity: 0; 
        transform: scale(0.1) rotate(720deg); 
        filter: brightness(3);
    }
    50% { 
        transform: scale(1.3) rotate(360deg); 
        filter: brightness(2);
    }
    100% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg); 
        filter: brightness(1);
    }
}

@keyframes perfectExplosion {
    0%, 100% { 
        transform: translateY(0) rotate(0deg) scale(1); 
        filter: drop-shadow(0 0 20px gold);
    }
    25% { 
        transform: translateY(-40px) rotate(90deg) scale(1.4); 
        filter: drop-shadow(0 0 40px gold);
    }
    50% { 
        transform: translateY(-20px) rotate(180deg) scale(1.2); 
        filter: drop-shadow(0 0 60px gold);
    }
    75% { 
        transform: translateY(-30px) rotate(270deg) scale(1.3); 
        filter: drop-shadow(0 0 40px gold);
    }
}

@keyframes perfectShine {
    0%, 100% { 
        text-shadow: 0 0 20px rgba(255,255,255,1), 0 0 40px gold, 0 0 60px gold;
        transform: scale(1);
    }
    50% { 
        text-shadow: 0 0 30px rgba(255,255,255,1), 0 0 60px gold, 0 0 80px gold, 0 0 100px gold;
        transform: scale(1.1);
    }
}

@keyframes goldenGlow {
    0%, 100% { 
        transform: translateY(0px) scale(1); 
        opacity: 0.95; 
        color: #FFD700;
    }
    50% { 
        transform: translateY(-10px) scale(1.05); 
        opacity: 1; 
        color: #FFA500;
    }
}

@keyframes diamondSpark {
    0%, 100% { 
        opacity: 0.9; 
        transform: scale(1) rotate(0deg);
        color: #E6E6FA;
    }
    25% { 
        opacity: 1; 
        transform: scale(1.1) rotate(5deg);
        color: #FFD700;
    }
    50% { 
        opacity: 1; 
        transform: scale(1.05) rotate(-5deg);
        color: #FF69B4;
    }
    75% { 
        opacity: 1; 
        transform: scale(1.1) rotate(3deg);
        color: #00CED1;
    }
}

/* Animación alternante para botones */
@keyframes alternatePulse {
    0%, 50% {
        transform: scale(1);
        box-shadow: 0 4px 15px rgba(0,200,81,0.2);
    }
    25% {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0,200,81,0.4);
    }
}

@keyframes alternatePulseIncorrect {
    0%, 50% {
        transform: scale(1);
        box-shadow: 0 4px 15px rgba(255,87,34,0.2);
    }
    75% {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(255,87,34,0.4);
    }
}

/* === ESTILOS PARA MODALES MODERNOS DE PALABRAS === */
@keyframes fadeInOverlay {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes expandToFullscreen {
    from { 
        width: 400px;
        height: 500px;
        border-radius: 25px;
    }
    to { 
        width: 100vw;
        height: 100vh;
        border-radius: 0;
    }
}

@keyframes slideInModal {
    from { 
        transform: translateY(-30px) scale(0.95);
        opacity: 0;
    }
    to { 
        transform: translateY(0) scale(1);
        opacity: 1;
    }
}

@keyframes wordCardFadeIn {
    from { 
        transform: translateY(10px);
        opacity: 0;
    }
    to { 
        transform: translateY(0);
        opacity: 1;
    }
}

.modal-container {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(20px);
    border-radius: 24px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    max-width: 500px;
    width: 90%;
    max-height: 85vh;
    overflow: hidden;
    animation: slideInModal 0.4s ease-out;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.modal-header {
    padding: 30px 30px 20px;
    text-align: center;
    position: relative;
}

.modal-title-row {
    margin-bottom: 8px;
}

.modal-title {
    font-size: 1.8rem;
    font-weight: 700;
    margin: 0;
    color: #1f2937;
    letter-spacing: -0.5px;
    text-decoration: underline;
    text-decoration-thickness: 2px;
    text-underline-offset: 4px;
}

.correct-modal .modal-title {
    text-decoration-color: #10b981;
}

.incorrect-modal .modal-title {
    text-decoration-color: #ef4444;
}

.modal-stats {
    font-size: 0.95rem;
    color: #6b7280;
    font-weight: 500;
}

.modal-content {
    padding: 0 30px 20px;
    max-height: 50vh;
    overflow-y: auto;
}

.words-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
}

.word-card {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 12px;
    padding: 16px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border: 1px solid rgba(0, 0, 0, 0.05);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    transition: all 0.2s ease;
    animation: wordCardFadeIn 0.3s ease-out;
    animation-fill-mode: both;
}

.word-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.correct-word {
    border-left: 4px solid #10b981;
}

.incorrect-word {
    border-left: 4px solid #ef4444;
}

.word-text {
    font-size: 1.1rem;
    font-weight: 600;
    color: #374151;
    flex: 1;
}

.word-checkmark {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.9rem;
    margin-left: 12px;
}

.correct-word .word-checkmark {
    background: #10b981;
    color: white;
}

.incorrect-word .word-checkmark {
    background: #ef4444;
    color: white;
}

.no-words-message {
    text-align: center;
    padding: 40px 20px;
    color: #6b7280;
}

.no-words-icon {
    font-size: 3rem;
    display: block;
    margin-bottom: 16px;
}

.no-words-message p {
    font-size: 1.1rem;
    font-weight: 500;
    margin: 0;
}

.modal-footer {
    padding: 20px 30px 30px;
    text-align: center;
}

.modal-close-btn {
    background: linear-gradient(135deg, #6366f1, #4f46e5);
    border: none;
    color: white;
    padding: 14px 32px;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    min-width: 120px;
}

.modal-close-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(99, 102, 241, 0.4);
}

.modal-close-btn:active {
    transform: translateY(0);
}

.correct-btn {
    background: linear-gradient(135deg, #10b981, #059669);
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
}

.correct-btn:hover {
    box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
}

.incorrect-btn {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
}

.incorrect-btn:hover {
    box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
}

/* Animación escalonada para las tarjetas de palabras */
.word-card:nth-child(1) { animation-delay: 0s; }
.word-card:nth-child(2) { animation-delay: 0.05s; }
.word-card:nth-child(3) { animation-delay: 0.1s; }
.word-card:nth-child(4) { animation-delay: 0.15s; }
.word-card:nth-child(5) { animation-delay: 0.2s; }
.word-card:nth-child(6) { animation-delay: 0.25s; }
.word-card:nth-child(7) { animation-delay: 0.3s; }
.word-card:nth-child(8) { animation-delay: 0.35s; }

/* === ESTILOS PARA MODAL DE BANDERA === */
.flag-card-container {
    width: 100%;
    height: 500px;
    max-height: 500px;
    max-width: 400px;
    background: linear-gradient(to right, #1f3658, #3558e3);
    border-radius: 25px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    border: 3px solid #aab0b4;
    overflow: hidden;
    position: relative;
    animation: slideInModal 0.4s ease-out;
    display: flex;
    flex-direction: column;
}

.flag-controls-floating {
    position: absolute;
    top: 15px;
    right: 15px;
    display: flex;
    gap: 8px;
    z-index: 10;
}

.flag-control-btn {
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.1);
    color: #374151;
    width: 40px;
    height: 40px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(10px);
}

.flag-control-btn:hover {
    background: #ffffff;
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
}

.flag-control-btn.close-btn {
    background: rgba(239, 68, 68, 0.9);
    color: white;
    border-color: rgba(239, 68, 68, 0.3);
}

.flag-control-btn.close-btn:hover {
    background: rgba(239, 68, 68, 1);
    transform: translateY(-2px) scale(1.05);
}

.flag-card-body-full {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
    overflow: hidden;
    position: relative;
    border-radius: 0 0 22px 22px;
}

.flag-display {
    width: 100%;
    height: 100%;
    border-radius: 0 0 22px 22px;
    box-shadow: none;
    border: none;
    transition: all 0.3s ease;
    display: block;
}

/* Responsive design para modal de bandera */
@media (max-width: 480px) {
    .flag-card-container {
        width: 100%;
        height: 550px;
        max-height: 550px;
        max-width: 400px;
        margin: 10px;
        border-radius: 25px;
        border: 3px solid #aab0b4;
        background: linear-gradient(to right, #1f3658, #3558e3);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .flag-controls-floating {
        top: 10px;
        right: 10px;
        gap: 6px;
    }
    
    .flag-card-body-full {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
        overflow: hidden;
        position: relative;
        border-radius: 0 0 22px 22px;
    }
    
    .flag-display {
        width: 100%;
        height: 100%;
        border-radius: 0 0 22px 22px;
        box-shadow: none;
        border: none;
        transition: all 0.3s ease;
        display: block;
    }
    
    .flag-control-btn {
        width: 36px;
        height: 36px;
        border-radius: 10px;
    }
    
    /* Ocultar el botón de pantalla completa en móviles */
    .fullscreen-btn {
        display: none !important;
    }
}

.flag-modal {
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(20px);
    border-radius: 20px;
    box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    overflow: hidden;
    animation: slideInModal 0.4s ease-out;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.flag-header {
    padding: 20px 30px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.9));
}

.flag-title {
    font-size: 1.5rem;
    font-weight: 700;
    margin: 0;
    color: #1f2937;
    letter-spacing: -0.3px;
}

.flag-close-btn {
    background: rgba(239, 68, 68, 0.1);
    border: none;
    color: #ef4444;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.flag-close-btn:hover {
    background: rgba(239, 68, 68, 0.2);
    transform: scale(1.1);
}

.flag-content {
    padding: 30px;
    text-align: center;
    background: linear-gradient(135deg, #f8fafc, #f1f5f9);
}

.flag-image {
    max-width: 100%;
    height: auto;
    max-height: 300px;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    transition: transform 0.3s ease;
    border: 2px solid rgba(255, 255, 255, 0.8);
}

.flag-image:hover {
    transform: scale(1.02);
}

/* Cursor pointer para las tarjetas clickeables */
.word-card {
    cursor: pointer;
}

.word-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
}

/* Responsive design para modal de bandera */
@media (max-width: 480px) {
    .flag-modal {
        width: 95%;
        margin: 10px;
    }
    
    .flag-header {
        padding: 15px 20px;
    }
    
    .flag-content {
        padding: 20px;
    }
    
    .flag-title {
        font-size: 1.3rem;
    }
    
    .flag-image {
        max-height: 200px;
    }
}

/* === ESTILOS PARA OVERLAY DE CONECTIVIDAD === */
.connectivity-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(135deg, rgba(220, 38, 51, 0.95) 0%, rgba(153, 27, 39, 0.98) 100%);
    backdrop-filter: blur(20px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    opacity: 0;
    visibility: hidden;
    transition: all 0.5s ease-in-out;
    color: white;
    font-family: Arial, sans-serif;
    padding: 20px;
    box-sizing: border-box;
}

.connectivity-overlay.show {
    opacity: 1;
    visibility: visible;
}

.connectivity-content {
    text-align: center;
    max-width: 600px;
    animation: connectivityPulse 2s ease-in-out infinite;
}

.connectivity-icon {
    font-size: 4rem;
    margin-bottom: 20px;
    display: block;
    color: #fff;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    animation: disconnectedBlink 1.5s ease-in-out infinite;
}

.connectivity-title {
    font-size: 2rem;
    font-weight: bold;
    margin: 0 0 15px 0;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    letter-spacing: -0.5px;
}

.connectivity-message {
    font-size: 1.2rem;
    margin: 0 0 30px 0;
    line-height: 1.5;
    opacity: 0.9;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.connectivity-status {
    background: rgba(0, 0, 0, 0.3);
    padding: 12px 20px;
    border-radius: 50px;
    display: inline-flex;
    align-items: center;
    gap: 10px;
    font-size: 1rem;
    font-weight: 600;
    border: 2px solid rgba(255, 255, 255, 0.2);
    margin-bottom: 25px;
    animation: statusPulse 2s ease-in-out infinite;
}

.connectivity-loading-dots {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-top: 20px;
}

.connectivity-dot {
    width: 10px;
    height: 10px;
    background: #fff;
    border-radius: 50%;
    animation: dotBounce 1.5s ease-in-out infinite;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
}

.connectivity-dot:nth-child(1) { animation-delay: 0s; }
.connectivity-dot:nth-child(2) { animation-delay: 0.3s; }
.connectivity-dot:nth-child(3) { animation-delay: 0.6s; }

.connectivity-retry-section {
    margin-top: 25px;
}

.connectivity-retry-btn {
    background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);
    color: #dc3545;
    border: 2px solid rgba(255, 255, 255, 0.3);
    padding: 12px 25px;
    font-size: 1rem;
    font-weight: 600;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin-top: 15px;
}

.connectivity-retry-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 35px rgba(0, 0, 0, 0.3);
    background: linear-gradient(135deg, #ffffff 0%, #f1f3f4 100%);
}

.connectivity-retry-btn:active {
    transform: translateY(0);
}

.connectivity-retry-btn.checking {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none;
}

/* Animaciones para el overlay de conectividad */
@keyframes connectivityPulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.02);
    }
}

@keyframes disconnectedBlink {
    0%, 50%, 100% {
        opacity: 1;
        transform: rotate(0deg);
    }
    25% {
        opacity: 0.5;
        transform: rotate(-5deg);
    }
    75% {
        opacity: 0.7;
        transform: rotate(5deg);
    }
}

@keyframes statusPulse {
    0%, 100% {
        border-color: rgba(255, 255, 255, 0.2);
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
    }
    50% {
        border-color: rgba(255, 255, 255, 0.5);
        box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
    }
}

@keyframes dotBounce {
    0%, 100% {
        transform: translateY(0px);
        opacity: 0.7;
    }
    50% {
        transform: translateY(-15px);
        opacity: 1;
    }
}

/* Efectos de reconexión exitosa */
.connectivity-overlay.reconnected {
    background: linear-gradient(135deg, rgba(40, 167, 69, 0.95) 0%, rgba(32, 134, 56, 0.98) 100%);
}

.connectivity-overlay.reconnected .connectivity-icon {
    animation: successSpin 1s ease-in-out;
}

.connectivity-overlay.reconnected .connectivity-title {
    color: #d4edda;
}

.connectivity-overlay.reconnected .connectivity-message {
    color: #d4edda;
}

@keyframes successSpin {
    0% {
        transform: rotate(0deg) scale(1);
        opacity: 0.5;
    }
    50% {
        transform: rotate(180deg) scale(1.2);
        opacity: 1;
    }
    100% {
        transform: rotate(360deg) scale(1);
        opacity: 1;
    }
}

/* Responsive design para overlay de conectividad */
@media (max-width: 768px) {
    .connectivity-icon {
        font-size: 3.5rem;
    }
    
    .connectivity-title {
        font-size: 1.8rem;
    }
    
    .connectivity-message {
        font-size: 1.1rem;
    }
    
    .connectivity-status {
        font-size: 0.95rem;
        padding: 10px 18px;
    }
    
    .connectivity-retry-btn {
        font-size: 0.95rem;
        padding: 10px 20px;
    }
}

@media (max-width: 480px) {
    .connectivity-title {
        font-size: 1.6rem;
    }
    
    .connectivity-message {
        font-size: 1rem;
    }
    
    .connectivity-icon {
        font-size: 3rem;
    }
    
    .connectivity-status {
        font-size: 0.9rem;
        padding: 8px 15px;
    }
    
    .connectivity-retry-btn {
        font-size: 0.9rem;
        padding: 8px 18px;
    }
    
    .connectivity-dot {
        width: 8px;
        height: 8px;
    }
}

/* Estilos específicos para PC/Desktop (pantallas grandes) */
@media (min-width: 1024px) {
    .connectivity-content {
        max-width: 700px;
        padding: 40px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 25px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .connectivity-icon {
        font-size: 4.5rem;
        margin-bottom: 25px;
    }
    
    .connectivity-title {
        font-size: 2.2rem;
        margin-bottom: 20px;
    }
    
    .connectivity-message {
        font-size: 1.3rem;
        margin-bottom: 35px;
        max-width: 500px;
        margin-left: auto;
        margin-right: auto;
    }
    
    .connectivity-status {
        padding: 15px 30px;
        font-size: 1.1rem;
        margin-bottom: 30px;
    }
    
    .connectivity-retry-btn {
        padding: 15px 35px;
        font-size: 1.1rem;
        gap: 10px;
    }
    
    .connectivity-retry-btn:hover {
        transform: translateY(-3px);
    }
    
    .connectivity-dot {
        width: 12px;
        height: 12px;
    }
}

/* === ESTILOS PARA MODAL DE PERMISOS DE MICRÓFONO === */
.microphone-permission-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999999 !important;
    opacity: 0;
    visibility: hidden;
    transition: all 0.4s ease-in-out;
    font-family: Arial, sans-serif;
    padding: 20px;
    box-sizing: border-box;
    /* Forzar comportamiento en móviles */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
}

.microphone-permission-overlay.show {
    opacity: 1;
    visibility: visible;
}

.microphone-permission-modal {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.98) 100%);
    backdrop-filter: blur(25px);
    border-radius: 25px;
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);
    max-width: 550px;
    width: 90%;
    overflow: hidden;
    animation: slideInModal 0.5s ease-out;
    border: 2px solid rgba(255, 255, 255, 0.3);
    position: relative;
}

.microphone-permission-header {
    padding: 35px 35px 25px;
    text-align: center;
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    color: white;
    position: relative;
    overflow: hidden;
}

.microphone-permission-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><defs><pattern id="micstars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.5" fill="white" opacity="0.2"/><circle cx="12" cy="8" r="0.3" fill="white" opacity="0.15"/><circle cx="8" cy="15" r="0.4" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="20" fill="url(%23micstars)"/></svg>') repeat;
    animation: sparkle 25s linear infinite;
    opacity: 0.3;
}

.microphone-permission-icon {
    font-size: 4rem;
    margin-bottom: 15px;
    display: block;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    animation: micBounce 2s infinite;
    position: relative;
    z-index: 2;
}

.microphone-permission-title {
    font-size: 1.8rem;
    font-weight: 700;
    margin: 0 0 8px 0;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
}

.microphone-permission-subtitle {
    font-size: 1.1rem;
    opacity: 0.9;
    margin: 0;
    font-weight: 400;
    position: relative;
    z-index: 2;
}

.microphone-permission-content {
    padding: 30px 35px;
    text-align: center;
}

.microphone-permission-description {
    font-size: 1.1rem;
    color: #374151;
    margin-bottom: 25px;
    line-height: 1.6;
}

.microphone-permission-features {
    background: linear-gradient(135deg, rgba(79, 70, 229, 0.05) 0%, rgba(124, 58, 237, 0.05) 100%);
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 30px;
    border: 1px solid rgba(79, 70, 229, 0.1);
}

.microphone-permission-feature {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    font-size: 0.95rem;
    color: #4b5563;
}

.microphone-permission-feature:last-child {
    margin-bottom: 0;
}

.microphone-permission-feature-icon {
    font-size: 1.2rem;
    color: #4f46e5;
    margin-right: 12px;
    width: 20px;
    flex-shrink: 0;
}

.microphone-permission-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.microphone-permission-btn {
    padding: 14px 30px;
    font-size: 1.1rem;
    font-weight: 600;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: none;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 140px;
    justify-content: center;
}

.microphone-permission-allow {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
    box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
}

.microphone-permission-allow:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 35px rgba(16, 185, 129, 0.4);
}

.microphone-permission-deny {
    background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
    color: white;
    box-shadow: 0 8px 25px rgba(107, 114, 128, 0.3);
}

.microphone-permission-deny:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 35px rgba(107, 114, 128, 0.4);
}

.microphone-permission-btn:active {
    transform: translateY(0);
}

/* Animaciones para modal de micrófono */
@keyframes micBounce {
    0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
    }
    40% {
        transform: translateY(-8px);
    }
    60% {
        transform: translateY(-4px);
    }
}

/* Responsive design para modal de permisos */
@media (max-width: 768px) {
    .microphone-permission-modal {
        margin: 20px;
        width: calc(100% - 40px);
    }
    
    .microphone-permission-header {
        padding: 25px 25px 20px;
    }
    
    .microphone-permission-content {
        padding: 25px;
    }
    
    .microphone-permission-title {
        font-size: 1.6rem;
    }
    
    .microphone-permission-subtitle {
        font-size: 1rem;
    }
    
    .microphone-permission-icon {
        font-size: 3.5rem;
    }
    
    .microphone-permission-buttons {
        flex-direction: column;
        gap: 12px;
    }
    
    .microphone-permission-btn {
        width: 100%;
        padding: 12px 20px;
        font-size: 1rem;
    }
}

@media (max-width: 480px) {
    .microphone-permission-modal {
        margin: 15px;
        width: calc(100% - 30px);
    }
    
    .microphone-permission-header {
        padding: 20px 20px 15px;
    }
    
    .microphone-permission-content {
        padding: 20px;
    }
    
    .microphone-permission-title {
        font-size: 1.4rem;
    }
    
    .microphone-permission-icon {
        font-size: 3rem;
    }
    
    .microphone-permission-description {
        font-size: 1rem;
    }
    
    .microphone-permission-feature {
        font-size: 0.9rem;
    }
}

/* Estilos específicos para dispositivos táctiles */
@media (hover: none) and (pointer: coarse) {
    .microphone-permission-overlay {
        z-index: 999999 !important;
        background: rgba(0, 0, 0, 0.95) !important;
        -webkit-backdrop-filter: blur(15px);
        backdrop-filter: blur(15px);
        /* Forzar para iOS */
        -webkit-overflow-scrolling: touch;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
    }
    
    .microphone-permission-overlay.show {
        opacity: 1 !important;
        visibility: visible !important;
        display: flex !important;
    }
    
    .microphone-permission-modal {
        z-index: 999999 !important;
        transform: none !important;
        -webkit-transform: none !important;
        max-width: 85% !important;
        width: 85% !important;
    }
    
    .microphone-permission-btn {
        -webkit-appearance: none !important;
        appearance: none !important;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        font-size: 18px !important;
        padding: 15px 25px !important;
        min-height: 50px !important;
    }
}

/* Específico para iOS Safari */
@supports (-webkit-touch-callout: none) {
    .microphone-permission-overlay {
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-perspective: 1000;
        perspective: 1000;
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
    }
    
    .microphone-permission-overlay.show {
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
    }
}

/* Estilos específicos para dispositivos táctiles */
@media (hover: none) and (pointer: coarse) {
    .microphone-permission-overlay {
        z-index: 999999 !important;
        background: rgba(0, 0, 0, 0.95) !important;
        -webkit-backdrop-filter: blur(15px);
        backdrop-filter: blur(15px);
        /* Forzar para iOS */
        -webkit-overflow-scrolling: touch;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
    }
    
    .microphone-permission-overlay.show {
        opacity: 1 !important;
        visibility: visible !important;
        display: flex !important;
    }
    
    .microphone-permission-modal {
        z-index: 999999 !important;
        transform: none !important;
        -webkit-transform: none !important;
        max-width: 85% !important;
        width: 85% !important;
    }
    
    .microphone-permission-btn {
        -webkit-appearance: none !important;
        appearance: none !important;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        font-size: 18px !important;
        padding: 15px 25px !important;
        min-height: 50px !important;
    }
}

/* === ESTILOS PARA MODAL DE CONTINUACIÓN === */
.continue-game-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20000;
    opacity: 0;
    animation: fadeInOverlay 0.4s ease-out forwards;
}

.continue-game-modal {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.95) 100%);
    backdrop-filter: blur(25px);
    border-radius: 25px;
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);
    max-width: 500px;
    width: 90%;
    overflow: hidden;
    animation: slideInModal 0.5s ease-out;
    border: 2px solid rgba(255, 255, 255, 0.3);
    position: relative;
}

.continue-modal-header {
    padding: 35px 35px 25px;
    text-align: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    position: relative;
    overflow: hidden;
}

.continue-modal-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><defs><pattern id="stars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.5" fill="white" opacity="0.2"/><circle cx="12" cy="8" r="0.3" fill="white" opacity="0.15"/><circle cx="8" cy="15" r="0.4" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="20" fill="url(%23stars)"/></svg>') repeat;
    animation: sparkle 25s linear infinite;
    opacity: 0.3;
}

.continue-modal-icon {
    font-size: 3.5rem;
    margin-bottom: 15px;
    display: block;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    animation: bounce 2s infinite;
    position: relative;
    z-index: 2;
}

.continue-modal-title {
    font-size: 1.8rem;
    font-weight: 700;
    margin: 0 0 8px 0;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 2;
}

.continue-modal-subtitle {
    font-size: 1.1rem;
    opacity: 0.9;
    margin: 0;
    font-weight: 400;
    position: relative;
    z-index: 2;
}

.continue-modal-content {
    padding: 30px 35px;
}

.continue-progress-info {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 25px;
    border: 1px solid rgba(102, 126, 234, 0.2);
    text-align: center;
}

.continue-progress-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #374151;
    margin-bottom: 15px;
}

.continue-progress-stats {
    display: flex;
    justify-content: space-around;
    gap: 15px;
}

.continue-stat-item {
    flex: 1;
    text-align: center;
}

.continue-stat-number {
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: 5px;
}

.continue-stat-number.correct {
    color: #10b981;
}

.continue-stat-number.incorrect {
    color: #ef4444;
}

.continue-stat-number.remaining {
    color: #f59e0b;
}

.continue-stat-label {
    font-size: 0.9rem;
    color: #6b7280;
    font-weight: 500;
}

.continue-modal-buttons {
    display: flex;
    gap: 15px;
    margin-top: 20px;
}

.continue-btn {
    flex: 1;
    padding: 16px 24px;
    border: none;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
}

.continue-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.continue-btn:hover::before {
    left: 100%;
}

.continue-btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
}

.continue-btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
}

.continue-btn-secondary {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    color: #374151;
    border: 2px solid rgba(102, 126, 234, 0.2);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
}

.continue-btn-secondary:hover {
    transform: translateY(-2px);
    background: linear-gradient(135deg, #ffffff 0%, #f1f5f9 100%);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    border-color: rgba(102, 126, 234, 0.3);
}

.continue-btn:active {
    transform: translateY(0);
}

@media (max-width: 480px) {
    .continue-game-modal {
        width: 95%;
        margin: 20px;
    }
    
    .continue-modal-header {
        padding: 25px 20px 20px;
    }
    
    .continue-modal-content {
        padding: 20px;
    }
    
    .continue-modal-buttons {
        flex-direction: column;
        gap: 12px;
    }
    
    .continue-modal-title {
        font-size: 1.5rem;
    }
    
    .continue-modal-icon {
        font-size: 3rem;
    }
}

        /* Estilos para el título creativo */
        .creative-title-container {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667eea 100%);
            padding: 1px 10px 1px 10px;
            position: relative;
            overflow: hidden;
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }
        
        .title-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><defs><pattern id="stars" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="0.5" fill="white" opacity="0.3"/><circle cx="12" cy="8" r="0.3" fill="white" opacity="0.2"/><circle cx="8" cy="15" r="0.4" fill="white" opacity="0.25"/></pattern></defs><rect width="100" height="20" fill="url(%23stars)"/></svg>') repeat;
            animation: sparkle 20s linear infinite;
        }
        
        .creative-title {
            margin: 0;
            text-align: center;
            color: white;
            font-size: 22px;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
            position: relative;
            z-index: 2;
            text-shadow: 0 2px 8px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        
        .globe-icon {
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 28px;
            animation: rotate 4s ease-in-out infinite;
        }
        
        .title-text {
            background: linear-gradient(45deg, #FFD700, #FFF, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes sparkle {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }
        @keyframes rotate {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(10deg) scale(1.1); }
        }
        @keyframes glow {
            0% { filter: drop-shadow(0 0 5px rgba(255,215,0,0.3)); }
            100% { filter: drop-shadow(0 0 15px rgba(255,215,0,0.6)); }
        }

    </style></head>
<body>

<!-- Overlay de Conectividad -->
<div id="connectivity-overlay" class="connectivity-overlay">
    <div class="connectivity-content">
        <span class="connectivity-icon">📡</span>
        <h1 class="connectivity-title">Sin Conexión</h1>
        <p class="connectivity-message">
            Parece que tu conexión a Internet es débil o se ha perdido.<br>
            Esta aplicación necesita conexión para funcionar correctamente.
        </p>
        
        <div class="connectivity-status">
            <i class="fas fa-wifi"></i>
            <span id="connectivity-status-text">Verificando conexión...</span>
        </div>
        
        <div class="connectivity-loading-dots">
            <div class="connectivity-dot"></div>
            <div class="connectivity-dot"></div>
            <div class="connectivity-dot"></div>
        </div>
        
        <div class="connectivity-retry-section">
            <button id="connectivity-retry-btn" class="connectivity-retry-btn">
                <i class="fas fa-redo"></i>
                <span>Intentar de nuevo</span>
            </button>
        </div>
    </div>
</div>

<!-- Modal de Permisos de Micrófono -->
<div id="microphone-permission-overlay" class="microphone-permission-overlay">
    <div class="microphone-permission-modal">
        <div class="microphone-permission-header">
            <span class="microphone-permission-icon">🎤</span>
            <h1 class="microphone-permission-title">Permiso de Micrófono</h1>
            <p class="microphone-permission-subtitle">Para usar el reconocimiento de voz</p>
        </div>
        
        <div class="microphone-permission-content">
            <div class="microphone-permission-buttons">
                <button id="microphone-permission-allow" class="microphone-permission-btn microphone-permission-allow">
                    <i class="fas fa-microphone"></i>
                    <span>Activar Micrófono</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Título creativo -->
<div class="creative-title-container">
    <div class="title-background"></div>
    <h1 class="creative-title">
        <i class="fas fa-globe-americas globe-icon"></i>
        <span class="title-text">Países del Mundo</span>
    </h1>
</div>

<div class="top-status-bar">

    <div class="pill back-arrow" onclick="goBack()">
        <span><i class="fas fa-arrow-left"></i></span>
    </div>
  <div class="pill pill-faltan">
    <span>T: <span id="total-cards"></span></span>
  </div>
    <div class="pill pill-correctas">
        <span><i class="fas fa-check"></i> <span id="correctas-count">0</span></span>
    </div>
    <div class="pill pill-incorrectas">
        <span><i class="fas fa-times"></i> <span id="incorrectas-count">0</span></span>
    </div>
    
   
</div>


    <div id="flashcard-container-wrapper">

<!--------------------------------------------------------------------->

<div id="flashcard-container">
    <div class="editor-name">@Faouzi ElHilali</div>
       <div class="flashcard">
        <div class="front">                 
            <img src="https://flagcdn.com/w640/es.png" alt="España" loading="lazy">
        </div>
        <div class="back">España</div>
    </div>

    <!-- 2. Marruecos -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ma.png" alt="Marruecos" loading="lazy">
        </div>
        <div class="back">Marruecos</div>
    </div>

    <!-- 3. México -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/mx.png" alt="México" loading="lazy">
        </div>
        <div class="back">México</div>
    </div>

    <!-- 4. Argentina -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ar.png" alt="Argentina" loading="lazy">
        </div>
        <div class="back">Argentina</div>
    </div>

    <!-- 5. Colombia -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/co.png" alt="Colombia" loading="lazy">
        </div>
        <div class="back">Colombia</div>
    </div>

    <!-- 6. Perú -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/pe.png" alt="Perú" loading="lazy">
        </div>
        <div class="back">Perú</div>
    </div>

    <!-- 7. Chile -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/cl.png" alt="Chile" loading="lazy">
        </div>
        <div class="back">Chile</div>
    </div>

    <!-- 8. Venezuela -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ve.png" alt="Venezuela" loading="lazy">
        </div>
        <div class="back">Venezuela</div>
    </div>

    <!-- 9. Ecuador -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ec.png" alt="Ecuador" loading="lazy">
        </div>
        <div class="back">Ecuador</div>
    </div>

    <!-- 10. Bolivia -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/bo.png" alt="Bolivia" loading="lazy">
        </div>
        <div class="back">Bolivia</div>
    </div>

    <!-- 11. Paraguay -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/py.png" alt="Paraguay" loading="lazy">
        </div>
        <div class="back">Paraguay</div>
    </div>

    <!-- 12. Uruguay -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/uy.png" alt="Uruguay" loading="lazy">
        </div>
        <div class="back">Uruguay</div>
    </div>

    <!-- 13. Guatemala -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/gt.png" alt="Guatemala" loading="lazy">
        </div>
        <div class="back">Guatemala</div>
    </div>

    <!-- 14. Cuba -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/cu.png" alt="Cuba" loading="lazy">
        </div>
        <div class="back">Cuba</div>
    </div>

    <!-- 15. República Dominicana -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/do.png" alt="República Dominicana" loading="lazy">
        </div>
        <div class="back">República Dominicana</div>
    </div>

    <!-- 16. Honduras -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/hn.png" alt="Honduras" loading="lazy">
        </div>
        <div class="back">Honduras</div>
    </div>

    <!-- 17. Nicaragua -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ni.png" alt="Nicaragua" loading="lazy">
        </div>
        <div class="back">Nicaragua</div>
    </div>

    <!-- 18. Costa Rica -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/cr.png" alt="Costa Rica" loading="lazy">
        </div>
        <div class="back">Costa Rica</div>
    </div>

    <!-- 19. Panamá -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/pa.png" alt="Panamá" loading="lazy">
        </div>
        <div class="back">Panamá</div>
    </div>

    <!-- 20. El Salvador -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/sv.png" alt="El Salvador" loading="lazy">
        </div>
        <div class="back">El Salvador</div>
    </div>

    <!-- 21. Guinea Ecuatorial -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/gq.png" alt="Guinea Ecuatorial" loading="lazy">
        </div>
        <div class="back">Guinea Ecuatorial</div>
    </div>

    <!-- 22. Estados Unidos -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/us.png" alt="Estados Unidos" loading="lazy">
        </div>
        <div class="back">Estados Unidos</div>
    </div>

    <!-- 23. Canadá -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ca.png" alt="Canadá" loading="lazy">
        </div>
        <div class="back">Canadá</div>
    </div>

    <!-- 24. Brasil -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/br.png" alt="Brasil" loading="lazy">
        </div>
        <div class="back">Brasil</div>
    </div>

    <!-- 25. Francia -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/fr.png" alt="Francia" loading="lazy">
        </div>
        <div class="back">Francia</div>
    </div>

    <!-- 26. Alemania -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/de.png" alt="Alemania" loading="lazy">
        </div>
        <div class="back">Alemania</div>
    </div>

    <!-- 27. Holanda -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/nl.png" alt="Holanda" loading="lazy">
        </div>
        <div class="back">Holanda</div>
    </div>

    <!-- 28. Bélgica -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/be.png" alt="Bélgica" loading="lazy">
        </div>
        <div class="back">Bélgica</div>
    </div>

    <!-- 29. Dinamarca -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/dk.png" alt="Dinamarca" loading="lazy">
        </div>
        <div class="back">Dinamarca</div>
    </div>

    <!-- 30. Italia -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/it.png" alt="Italia" loading="lazy">
        </div>
        <div class="back">Italia</div>
    </div>

    <!-- 31. Reino Unido -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/gb.png" alt="Reino Unido" loading="lazy">
        </div>
        <div class="back">Reino Unido</div>
    </div>

    <!-- 32. Rusia -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ru.png" alt="Rusia" loading="lazy">
        </div>
        <div class="back">Rusia</div>
    </div>

    <!-- 33. China -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/cn.png" alt="China" loading="lazy">
        </div>
        <div class="back">China</div>
    </div>

    <!-- 34. Japón -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/jp.png" alt="Japón" loading="lazy">
        </div>
        <div class="back">Japón</div>
    </div>

    <!-- 35. Corea del Sur -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/kr.png" alt="Corea del Sur" loading="lazy">
        </div>
        <div class="back">Corea del Sur</div>
    </div>

    <!-- 36. India -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/in.png" alt="India" loading="lazy">
        </div>
        <div class="back">India</div>
    </div>

    <!-- 37. Australia -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/au.png" alt="Australia" loading="lazy">
        </div>
        <div class="back">Australia</div>
    </div>

    <!-- 38. Sudáfrica -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/za.png" alt="Sudáfrica" loading="lazy">
        </div>
        <div class="back">Sudáfrica</div>
    </div>

    <!-- 39. Egipto -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/eg.png" alt="Egipto" loading="lazy">
        </div>
        <div class="back">Egipto</div>
    </div>

    <!-- 40. Nigeria -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ng.png" alt="Nigeria" loading="lazy">
        </div>
        <div class="back">Nigeria</div>
    </div>

    <!-- 41. Turquía -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/tr.png" alt="Turquía" loading="lazy">
        </div>
        <div class="back">Turquía</div>
    </div>

    <!-- 42. Arabia Saudí -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/sa.png" alt="Arabia Saudí" loading="lazy">
        </div>
        <div class="back">Arabia Saudí</div>
    </div>

    <!-- 43. Irán -->
    <div class="flashcard">
        <div class="front">
            <img src="https://flagcdn.com/w640/ir.png" alt="Irán" loading="lazy">
        </div>
        <div class="back">Irán</div>
    </div>

    
    <style>
        /* Icono solo para el de arriba; no rompe el texto que actualiza el JS */
        #porcentaje-guardado {
            display: inline-flex;
            align-items: center;
            position: relative; /* Para hints posicionados */
            overflow: visible;
        }
        #porcentaje-guardado::before {
            content: "\f295"; /* fa-percent */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            font-size: 16px;
            margin-right: 6px;
        }
    </style>

    <!-- Override: cambiar icono del porcentaje de aciertos -->
    <style>
        #porcentaje-guardado::before {
            content: "\f091"; /* fa-trophy */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            font-size: 16px;
            margin-right: 6px;
        }
        /* Transición para ocultar/mostrar el cuadro de stats */
        #stats-box {
            transition: opacity 320ms ease, transform 320ms ease, filter 320ms ease;
        }
        #stats-box.hidden {
            opacity: 0;
            transform: scale(0.75);
            filter: blur(2px);
            pointer-events: none;
        }
        /* Hints: texto limpio sin brillos/luces, en amarillo sólido */
        .pill-hint {
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 14px;
            white-space: nowrap;
            z-index: 100;
            overflow: hidden; /* para el tipeo */
            pointer-events: none; /* no bloquea clics */
            /* Tipografía y color moderno */
            font-weight: 900;
            font-size: 18px;
            letter-spacing: 0.3px;
            line-height: 1.1;
            color: #ffeb3b; /* amarillo sólido */
            text-shadow: none; /* sin efecto de luz */
            -webkit-text-stroke: 1.25px #000; /* contorno negro para "revistido de negro" */
            paint-order: stroke fill;
            /* Efectos */
            opacity: 0;
            width: 0ch; /* arranca sin ancho y “tipea” */
            will-change: transform, opacity;
            animation:
                typing var(--type-dur, 1200ms) steps(var(--chars, 12)) var(--delay, 0ms) both,
                hintEnter 640ms cubic-bezier(0.22, 1, 0.36, 1) calc(var(--delay, 0ms) + var(--intro-delay, 180ms)) both,
                hintFadeOut 480ms ease-in var(--fade-delay, 2200ms) forwards;
        }
        .pill-hint::before {
            /* Quitar aura/halo */
            content: none !important;
            display: none !important;
        }
        .pill-hint::after { display: none; }
        @keyframes typing {
            from { width: 0ch; }
            to { width: calc(var(--chars, 12) * 1ch); }
        }
        @keyframes hintEnter {
            0%   { opacity: 0; transform: translateY(-50%) translateX(14px) scale(0.96) rotate(-1.5deg); filter: blur(3px); }
            60%  { opacity: 1; transform: translateY(-50%) translateX(-2px) scale(1.02) rotate(0.3deg); filter: blur(0.5px); }
            100% { opacity: 1; transform: translateY(-50%) translateX(0) scale(1) rotate(0); filter: blur(0); }
        }
        /* caretBlink eliminado: sin cursor parpadeante */
        @keyframes hintFadeOut {
            0%   { opacity: 1; transform: translateY(-50%) translateX(0); filter: blur(0); }
            100% { opacity: 0; transform: translateY(-50%) translateX(-6px); filter: blur(2px); }
        }
    </style>

    <!-- Firma del editor dentro del contenedor de tarjetas -->
    <style>
        .editor-name {
            position: absolute;
            bottom: 5px;
            left: 15px; /* abajo izquierda del contenedor */
            font-size: 9px;
            animation: colorTintineo 3s infinite;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            z-index: 21; /* sobre el contenido base */
            pointer-events: none; /* no bloquea clics */
        }
        @keyframes colorTintineo {
            0% { color: #ff0000; }
            20% { color: #ffff00; }
            40% { color: #0000ff; }
            60% { color: #ffffff; }
            80% { color: #000000; }
            100% { color: #ff0000; }
        }
    </style>

    <!-- Cuadro unificado para ambos porcentajes (misma talla de pills, separados por línea) -->
    <div id="stats-box" style="
        position: absolute;
        bottom: 6px;
        right: 8px;
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        /* Caja elegante sin alterar el tamaño de los pills */
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 14px;
        padding: 6px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.18);
        border: 1px solid rgba(255,255,255,0.14);
        transform: scale(0.8);
        transform-origin: bottom right;
    ">
    <!-- Porcentaje de aciertos (sin cambiar su tamaño) -->
    <div class="pill" id="porcentaje-guardado" style="
        background: rgba(255, 255, 255, 0.08);
        color: white;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.2);
        min-width: 65px;
        text-align: center;
    "><span id="current-percentage">0%</span></div>

    <!-- Separador fino entre ambos -->
    <div style="
        width: 100%;
        height: 1px;
        background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.35), rgba(255,255,255,0));
    "></div>

    <!-- Porcentaje del último partido (sin cambiar su tamaño) -->
    <div class="pill" id="last-game-pill" style="
        background: rgba(255, 255, 255, 0.08);
        color: white;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.2);
        min-width: 65px;
        position: relative; /* Para hints posicionados */
        overflow: visible;
    ">
        <span><i class="fas fa-chart-line"></i> <span id="last-game-percentage">0%</span></span>
    </div>
    </div>

</div>
    </div>
    
    <audio id="soundResetButton" src="https://fawzinoo.github.io/audios/bellding-254774.mp3" preload="auto"></audio>
    <audio id="shuffleSound" src="https://fawzinoo.github.io/audios/naipe.mp3" preload="auto"></audio>
    <audio id="buttonClickSound" src="https://fawzinoo.github.io/audios/botonn.mp3" preload="auto"></audio>

    <div class="button-container">
        <button class="button" id="reset-button">Reiniciar</button>
        <button class="button" id="skip-button" style="background-color: #e67e22;">
            <i class="fas fa-forward"></i> No sé
        </button>
        <button class="button" id="shuffle-button" style="background-color: #9b59b6;">
            <i class="fas fa-random"></i> Mezclar
        </button>
    </div>
    

    <!-- Análisis de audio para verificación fonética -->
    <script src="https://unpkg.com/meyda/dist/web/meyda.min.js"></script>

    <!-- Agregar la librería de confeti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

    <script>

        

        function vibrar(ms = 80) {
    if (window.navigator && window.navigator.vibrate) {
        window.navigator.vibrate(ms);
    }
}

        function playErrorSound() {
    const errorAudio = new Audio('https://fawzinoo.github.io/audios/error.mp3');
    errorAudio.volume = 0.5;
    errorAudio.play().catch(() => {});
}

function playButtonSound() {
    // Agregar vibración leve a todos los botones
    vibrar(50); // Vibración más suave que los botones principales
    
    const buttonAudio = document.getElementById('buttonClickSound');
    if (buttonAudio) {
        buttonAudio.currentTime = 0; // Reiniciar el audio
        buttonAudio.volume = 0.7;
        buttonAudio.play().catch(() => {});
    }
}

function goBack() {
    // Reproducir sonido de botón
    playButtonSound();
    
    // Verificar si hay historial de navegación
    if (window.history.length > 1) {
        // Usar history.back() para regresar a la página anterior
        window.history.back();
    } else if (document.referrer && document.referrer !== window.location.href) {
        // Si no hay historial pero sí hay referrer, ir al referrer
        window.location.href = document.referrer;
    } else {
        // Como último recurso, redirigir a la página principal
        window.location.href = 'https://fawzinoo.github.io/Rep/Vocabulario.html';
    }
}

// --- NUEVO SISTEMA DE RECONOCIMIENTO DE VOZ (CLIENTE) ---

let mediaRecorder;
let audioChunks = [];
let isRecording = false;

// Sistema de tarjetas completadas
let completedCards = new Set();
let correctCount = 0;
let incorrectCount = 0;
let currentCardIndex = 0;
let voiceAttempts = 0; // Contador para los intentos de voz
let canFlipBack = true;
let canFlip = true; // Controla si se puede voltear la tarjeta
// Timer para programar la actualización del porcentaje tras re-aparecer el cuadro
let percentageUpdateTimeoutId = null;
let statsShowTimeoutId = null;
let statsHideTimeoutId = null;

// Estado: ventana entre 1er y 2º intento
let betweenAttempts = false;
// Timeouts para gestionar ventana entre intentos
let errorDelayTimeoutId = null;       // 2s de mensaje Incorrecto tras primer fallo
let resumeRecognitionTimeoutId = null; // ~100ms antes de reanudar reconocimiento

// Flags para controlar el botón "No sé" en estados de back
let showingErrorMessage = false;           // true mientras se muestra el mensaje "Incorrecto"
let lockedAfterSecondIncorrect = false;    // bloquea el botón tras segundo intento fallido hasta pasar de tarjeta
let lockedAfterCorrect = false;            // bloquea el botón tras acierto hasta pasar de tarjeta

function setSkipEnabled(enabled) {
    const skipBtn = document.getElementById('skip-button');
    if (!skipBtn) return;
    skipBtn.disabled = !enabled;
    skipBtn.style.opacity = enabled ? '1' : '0.5';
    skipBtn.style.pointerEvents = enabled ? 'auto' : 'none';
}

// Habilita "No sé" solo en dos momentos:
// 1) Cuando la tarjeta visible está en front (antes del primer intento)
// 2) Tras el primer fallo, en la ventana entre intentos (betweenAttempts=true)
function updateSkipButtonState() {
    const card = document.querySelector('.flashcard.is-visible');
    if (!card) { setSkipEnabled(false); return; }
    const isFront = !card.classList.contains('flipped');
    if (isFront) {
        // Permitido al estar en front (antes del 1er intento)
        setSkipEnabled(true);
        return;
    }
    // Back: activar por defecto salvo condiciones de bloqueo
    // Bloqueos explícitos: mientras se muestran mensajes de error, y después del segundo incorrecto
    if (showingErrorMessage || lockedAfterSecondIncorrect || lockedAfterCorrect) { setSkipEnabled(false); return; }
    // En la ventana entre intentos tras el primer fallo: activo
    if (betweenAttempts && voiceAttempts === 1) { setSkipEnabled(true); return; }
    // Si no estamos escuchando o no hay reconocimiento activo, permitir (otros casos de back)
    setSkipEnabled(true);
}

// Permitir saltar tarjeta como "No sé"
function skipCurrentCardAsUnknown() {
    // Respetar estado de habilitación del botón
    const btn = document.getElementById('skip-button');
    if (btn && btn.disabled) return;
    // Cancelar timeouts pendientes de la ventana entre intentos
    if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
    if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }
    // Evitar doble procesamiento si no hay tarjetas o ya está completada
    const flashcardsList = Array.from(document.querySelectorAll('.flashcard'));
    if (flashcardsList.length === 0) return;
    if (completedCards.has(currentCardIndex)) {
        // Si ya está completada, simplemente avanza
        goToNextCard();
        return;
    }

    // Marcar como incorrecta
    try {
        const currentCard = flashcardsList[currentCardIndex];
        const back = currentCard.querySelector('.back');
        const targetWord = currentCard.dataset.answer || (back ? back.textContent.trim() : '');
        if (targetWord) {
            incorrectWords.push(targetWord);
        }
    } catch (e) {}
    incorrectCount += 1;
    completedCards.add(currentCardIndex);

    // Persistir y actualizar UI
    saveGameProgress();
    updateCounters();
    updateCardCounter();

    // Avanzar a la siguiente tarjeta
    goToNextCard();
}

function scheduleStatsBoxUpdate() {
    const statsBox = document.getElementById('stats-box');
    if (!statsBox) { 
        // Fallback: aplicar inmediatamente
        updateCounters();
        if (typeof updateSuccessPercentage === 'function') updateSuccessPercentage();
        return; 
    }
    // Cancelar temporizadores anteriores
    if (statsShowTimeoutId) { clearTimeout(statsShowTimeoutId); statsShowTimeoutId = null; }
    if (statsHideTimeoutId) { clearTimeout(statsHideTimeoutId); statsHideTimeoutId = null; }
    if (percentageUpdateTimeoutId) { clearTimeout(percentageUpdateTimeoutId); percentageUpdateTimeoutId = null; }

    // 1) Mostrar cuadro ahora mismo
    statsBox.classList.remove('hidden');
    // 2) En 2s, aplicar actualización del marcador
    statsShowTimeoutId = setTimeout(() => {
        updateCounters();
        if (typeof updateSuccessPercentage === 'function') updateSuccessPercentage();
        // 3) Mantener visible y ocultar 3s después
        statsHideTimeoutId = setTimeout(() => {
            statsBox.classList.add('hidden');
        }, 3000);
    }, 2000);
}

// Función para normalizar el texto: quitar acentos, puntuación y a minúsculas.
function normalizeText(text) {
    if (!text) return "";
    return text.trim();
}

// === SISTEMA DE PERMISOS DE MICRÓFONO ===
let microphonePermissionGranted = null; // null = no preguntado, true = permitido, false = denegado
let microphonePermissionAsked = false;

// Verificar si ya se han pedido permisos anteriormente
function checkPreviousMicrophonePermission() {
    const permission = localStorage.getItem('microphonePermissionGranted');
    if (permission !== null) {
        microphonePermissionGranted = permission === 'true';
        microphonePermissionAsked = true;
        console.log(`🎤 Permiso de micrófono previo: ${microphonePermissionGranted ? 'CONCEDIDO' : 'DENEGADO'}`);
    }
}

// Mostrar modal de permisos personalizado
function showMicrophonePermissionModal() {
    return new Promise((resolve) => {
        console.log('🎤 Mostrando modal de permisos de micrófono');
        
        const overlay = document.getElementById('microphone-permission-overlay');
        const allowBtn = document.getElementById('microphone-permission-allow');
        
        if (!overlay || !allowBtn) {
            console.error('❌ No se pudo encontrar el modal de permisos');
            resolve(false);
            return;
        }
        
        // Mostrar overlay
        overlay.classList.add('show');
        console.log('📱 Modal de micrófono mostrado, clases:', overlay.className);
        console.log('📱 Estilo display:', window.getComputedStyle(overlay).display);
        console.log('📱 Estilo opacity:', window.getComputedStyle(overlay).opacity);
        console.log('📱 Estilo z-index:', window.getComputedStyle(overlay).zIndex);
        console.log('📱 Estilo visibility:', window.getComputedStyle(overlay).visibility);
        console.log('📱 Viewport:', window.innerWidth, 'x', window.innerHeight);
        console.log('📱 User agent:', navigator.userAgent);
        
        // Forzar visibilidad para dispositivos móviles
        if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
            console.log('📱 Dispositivo móvil detectado - forzando visibilidad');
            overlay.style.display = 'flex !important';
            overlay.style.opacity = '1 !important';
            overlay.style.visibility = 'visible !important';
            overlay.style.zIndex = '999999';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
        }
        
        // Verificación robusta de visibilidad
        setTimeout(() => {
            const computedStyle = window.getComputedStyle(overlay);
            const rect = overlay.getBoundingClientRect();
            
            console.log('🔍 Verificación final de visibilidad:');
            console.log('  - Display:', computedStyle.display);
            console.log('  - Opacity:', computedStyle.opacity);
            console.log('  - Visibility:', computedStyle.visibility);
            console.log('  - Z-index:', computedStyle.zIndex);
            console.log('  - Position:', computedStyle.position);
            console.log('  - Dimensiones:', rect.width, 'x', rect.height);
            console.log('  - Posición en pantalla:', rect.top, rect.left);
            console.log('  - Visible en viewport:', rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth);
            
            // Si no es visible, forzar nuevamente
            if (computedStyle.opacity === '0' || computedStyle.visibility === 'hidden' || computedStyle.display === 'none') {
                console.log('⚠️ Modal no visible - aplicando fix de emergencia');
                overlay.style.cssText = `
                    display: flex !important;
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100vw !important;
                    height: 100vh !important;
                    z-index: 999999 !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    background: rgba(0, 0, 0, 0.9) !important;
                    justify-content: center !important;
                    align-items: center !important;
                `;
            }
        }, 100);
        
        // Verificación robusta de visibilidad
        setTimeout(() => {
            const computedStyle = window.getComputedStyle(overlay);
            const rect = overlay.getBoundingClientRect();
            
            console.log('🔍 Verificación final de visibilidad:');
            console.log('  - Display:', computedStyle.display);
            console.log('  - Opacity:', computedStyle.opacity);
            console.log('  - Visibility:', computedStyle.visibility);
            console.log('  - Z-index:', computedStyle.zIndex);
            console.log('  - Position:', computedStyle.position);
            console.log('  - Dimensiones:', rect.width, 'x', rect.height);
            console.log('  - Posición en pantalla:', rect.top, rect.left);
            console.log('  - Visible en viewport:', rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth);
            
            // Si no es visible, forzar nuevamente
            if (computedStyle.opacity === '0' || computedStyle.visibility === 'hidden' || computedStyle.display === 'none') {
                console.log('⚠️ Modal no visible - aplicando fix de emergencia');
                overlay.style.cssText = `
                    display: flex !important;
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100vw !important;
                    height: 100vh !important;
                    z-index: 999999 !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    background: rgba(0, 0, 0, 0.9) !important;
                    justify-content: center !important;
                    align-items: center !important;
                `;
            }
        }, 100);
        
        // Manejar botón "Activar Micrófono"
        const handleAllow = async () => {
            console.log('✅ Usuario quiere activar micrófono');
            overlay.classList.remove('show');
            
            // Limpiar evento
            allowBtn.removeEventListener('click', handleAllow);
            
            // Solicitar permisos del navegador
            try {
                console.log('🔊 Solicitando permisos del navegador...');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                console.log('✅ Permisos de micrófono concedidos');
                microphonePermissionGranted = true;
                microphonePermissionAsked = true;
                localStorage.setItem('microphonePermissionGranted', 'true');
                
                // Cerrar el stream inmediatamente
                stream.getTracks().forEach(track => track.stop());
                
                resolve(true);
                
            } catch (error) {
                console.log('❌ Usuario denegó permisos:', error.name);
                microphonePermissionGranted = false;
                microphonePermissionAsked = true;
                localStorage.setItem('microphonePermissionGranted', 'false');
                resolve(false);
            }
        };
        
        // Añadir event listener
        allowBtn.addEventListener('click', handleAllow);
        
        // Auto-ocultar después de 30 segundos (como fallback)
        setTimeout(() => {
            if (overlay.classList.contains('show')) {
                console.log('⏰ Modal de permisos auto-cerrado por timeout');
                overlay.classList.remove('show');
                allowBtn.removeEventListener('click', handleAllow);
                resolve(false); // Considerar como no activado si no responde
            }
        }, 30000);
    });
}

// Función principal para manejar permisos de micrófono
async function handleMicrophonePermission() {
    // Primero verificar si el navegador ya tiene permisos concedidos
    try {
        // Intentar verificar el estado actual de permisos sin mostrar modal
        const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
        
        if (permissionStatus.state === 'granted') {
            console.log('✅ El micrófono ya está activado en el sistema');
            microphonePermissionGranted = true;
            microphonePermissionAsked = true;
            localStorage.setItem('microphonePermissionGranted', 'true');
            return true;
        }
        
        if (permissionStatus.state === 'denied') {
            console.log('❌ El micrófono está bloqueado en el sistema');
            microphonePermissionGranted = false;
            microphonePermissionAsked = true;
            localStorage.setItem('microphonePermissionGranted', 'false');
            return false;
        }
    } catch (error) {
        console.log('⚠️ No se pudo verificar estado de permisos:', error.message);
        // Continuar con el flujo normal si no se puede verificar
    }
    
    // Si ya se preguntó y fue denegado, no proceder
    if (microphonePermissionAsked && !microphonePermissionGranted) {
        console.log('❌ Permisos de micrófono previamente denegados');
        return false;
    }
    
    // Si ya se preguntó y fue concedido, proceder directamente
    if (microphonePermissionAsked && microphonePermissionGranted) {
        console.log('✅ Permisos de micrófono previamente concedidos');
        return true;
    }
    
    // Primera vez: mostrar modal personalizado
    console.log('🆕 Primera solicitud de permisos de micrófono');
    const result = await showMicrophonePermissionModal();
    
    if (!result) {
        console.log('❌ Permisos denegados');
        return false;
    }
    
    console.log('🎉 ¡Permisos de micrófono completamente concedidos!');
    return true;
}

// Inicializar sistema de permisos
function initializeMicrophonePermissions() {
    checkPreviousMicrophonePermission();
    console.log('🎤 Sistema de permisos de micrófono inicializado');
}


function startVoiceRecognition(targetWord, backElement) {
    // Verificar que la tarjeta esté volteada (en back) antes de permitir reconocimiento
    const card = backElement.closest('.flashcard');
    if (!card || !card.classList.contains('flipped')) {
        console.log("No se puede iniciar reconocimiento: la tarjeta no está volteada");
        return;
    }
    
    // Verificar permisos de micrófono antes de continuar
    handleMicrophonePermission().then(hasPermission => {
        if (!hasPermission) {
            console.log("❌ No hay permisos de micrófono, no se puede iniciar reconocimiento");
            return;
        }
        
        // Continuar con el reconocimiento de voz
        startSpeechRecognition(targetWord, backElement);
    }).catch(error => {
        console.error("Error al verificar permisos de micrófono:", error);
    });
}

// Función separada para el reconocimiento de voz real
function startSpeechRecognition(targetWord, backElement) {
    // Web Speech API (reconocimiento de voz del navegador)
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
        alert("Tu navegador no soporta reconocimiento de voz.");
        return;
    }
    
    const recognition = new SpeechRecognition();
    recognition.lang = 'es-ES';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    // El indicador se muestra solamente al voltear a back, no aquí

    // Timeout para auto-voltear si no hay respuesta (igual que en PC)
    const autoFlipTimer = setTimeout(() => {
        const card = backElement.closest('.flashcard');
        if (card && card.classList.contains('flipped')) {
            card.classList.remove('flipped');
            removeListeningIndicator(backElement);
        }
    }, 5000); // 5 segundos para pruebas

    recognition.onresult = function(event) {
        // Solo procesar si la tarjeta sigue volteada (no permitir contestar en front)
        clearTimeout(autoFlipTimer);
        const card = backElement.closest('.flashcard');
        if (!card || !card.classList.contains('flipped')) {
            // Ignorar resultado si se volvió a front
            return;
        }
        const spokenWord = event.results[0][0].transcript;
        handleVoiceResult(spokenWord, targetWord, backElement);
    };

    recognition.onerror = function(event) {
        console.error("Error de reconocimiento:", event.error); // Muestra el error en la consola para depuración
        // NO eliminar el indicador automáticamente, que persista
        clearTimeout(autoFlipTimer); // Limpiar timer
        const card = backElement.closest('.flashcard');

        // Si el error es 'no-speech' o un problema de red, simplemente voltea la tarjeta
        // para que el usuario pueda volver a intentarlo haciendo clic de nuevo.
        if (event.error === "no-speech" || event.error === "network") {
            if (card && card.classList.contains('flipped')) {
                card.classList.remove('flipped');
            }
            return;
        }
        
        // Para otros errores, no hacemos nada drástico, solo paramos.
        // El alert() se ha eliminado para no interrumpir al usuario.
    };

    recognition.onend = function() {
        // NO eliminar el indicador automáticamente, que persista
        clearTimeout(autoFlipTimer); // Limpiar timer
    };

    recognition.start();
}
function handleVoiceResult(spokenWord, targetWord, backElement) {
    // Bloquear procesamiento si la tarjeta NO está volteada (no se puede contestar en front)
    const cardElement = backElement.closest('.flashcard');
    if (!cardElement || !cardElement.classList.contains('flipped')) {
        return;
    }
    
    // Desactiva el botón de mezclar en el primer intento.
    document.getElementById('shuffle-button').disabled = true;
    
    const card = cardElement;

    if (!spokenWord || spokenWord.trim() === "") {
        // NO eliminar el indicador, mantenerlo visible
        setBackAttempts(backElement, 2 - voiceAttempts);
        backElement.classList.remove('hidden-text');
        setTimeout(() => {
            if (card && card.classList.contains('flipped')) {
                // Mostrar indicador nuevamente antes de reiniciar reconocimiento
                showListeningIndicator(backElement);
                setTimeout(() => {
                    startVoiceRecognition(targetWord, backElement);
                }, 100);
            }
        }, 2000);
        return;
    }
    const normalizedSpoken = spokenWord.trim();
    const normalizedTarget = targetWord.trim();

    // Detectar si el usuario dijo "No sé" y tratarlo como saltar tarjeta
    const lowerSpoken = normalizedSpoken.toLowerCase();
    if (lowerSpoken === 'no sé' || lowerSpoken === 'no se' || lowerSpoken === 'nose' || 
        lowerSpoken === 'no lo sé' || lowerSpoken === 'no lo se') {
        console.log('Usuario dijo "No sé" - saltando tarjeta');
        skipCurrentCardAsUnknown();
        return;
    }

    if (palabrasSimilares(normalizedSpoken, normalizedTarget)) {
        correctCount++;
        betweenAttempts = false;
        lockedAfterCorrect = true;
        updateSkipButtonState();
        
        // AGREGAR la palabra a la lista de correctas
        correctWords.push(targetWord);
        
        canFlipBack = true; 
        playSuccessSound();

        // Mostrar contador y nombre del país debajo SOLO si acierta
        clearBackContent(backElement);
        
        // Eliminar indicador cuando aparece la respuesta
        removeListeningIndicator(backElement);
        
        // Si se acierta al primer intento (voiceAttempts es 0), el contador se pone a 1.
        // Si se acierta al segundo (voiceAttempts es 1), el contador se pone a 0.
        setBackAttempts(backElement, 2 - (voiceAttempts + 1));

        voiceAttempts = 0; // Reiniciar para la siguiente tarjeta

        const nombrePais = document.createElement('div');
        nombrePais.style.marginTop = '40px';
        nombrePais.textContent = targetWord;
        // Aplicar el mismo efecto de luz que las respuestas incorrectas
        nombrePais.style.animation = 'respuestaGlow 1.5s infinite';
        backElement.appendChild(nombrePais);
        backElement.classList.remove('hidden-text');
        
        canFlip = false; // Deshabilitar volteo antes de mostrar la respuesta

        // ANTI-TRUCO: Marcar la tarjeta como completada inmediatamente
        // para evitar que un refresco durante la cuenta regresiva la cuente como restante
        if (!completedCards.has(currentCardIndex)) {
            completedCards.add(currentCardIndex);
            updateCardCounter();
            saveGameProgress();
        }

        // Si esta era la última tarjeta, actualizar el "avance anterior" en el momento 0
        // para no perder el resultado si el usuario refresca o cierra la página.
        // Al haber marcado la tarjeta como completada arriba, si no quedan restantes, 
        // el porcentaje del partido actual ya es definitivo.
        (function() {
            try {
                const remainingAfter = flashcards.length - completedCards.size;
                if (remainingAfter === 0) {
                    saveLastGamePercentage();
                }
            } catch (e) { /* noop */ }
        })();

        setTimeout(() => {
            const idx = flashcards.indexOf(card);
            if (hasValidAudio(idx)) {
                stopAllAudios();
                audios[idx].play().catch(() => {});
                audios[idx].addEventListener('ended', () => showCountdown(card), { once: true });
            } else {
                showCountdown(card);
            }
        }, 1000);

        // Programar la aparición/actualización/ocultación del cuadro de stats
        scheduleStatsBoxUpdate();
        
        // GUARDAR PROGRESO AUTOMÁTICAMENTE (ya guardado arriba al marcar completada)
        } else {
            voiceAttempts++;
            // NO eliminar el indicador, mantenerlo visible        // GUARDAR PROGRESO DESPUÉS DE INCREMENTAR voiceAttempts
        saveGameProgress();

        if (voiceAttempts < 2) {
            playErrorSound();
            // Primer intento fallido: solo muestra el mensaje de error elegante y centrado
            clearBackContent(backElement);
            // Eliminar indicador cuando aparece el mensaje de error
            removeListeningIndicator(backElement);
            setBackAttempts(backElement, 2 - voiceAttempts); // Solo actualiza el contador de intentos
            
            const mensajeError = document.createElement('div');
            mensajeError.className = 'mensaje-error';
            mensajeError.innerHTML = `
                <i class="fas fa-exclamation-circle"></i>
                <div>Incorrecto</div>
            `;
            backElement.appendChild(mensajeError);
            backElement.classList.remove('hidden-text');

            // Durante el mensaje de error, desactivar botón
            showingErrorMessage = true;
            updateSkipButtonState();

            // Eliminar el mensaje después de 2 segundos y reiniciar la grabación
            errorDelayTimeoutId = setTimeout(() => {
                mensajeError.remove(); // Elimina solo el mensaje de error
                if (card.classList.contains('flipped')) {
                    // Abrir ventana entre intentos: permitir pulsar "No sé" antes de reanudar
                    betweenAttempts = true;
                    showingErrorMessage = false; // terminó el mensaje
                    updateSkipButtonState();
                    // Mostrar indicador nuevamente antes de reiniciar reconocimiento
                    showListeningIndicator(backElement);
                    resumeRecognitionTimeoutId = setTimeout(() => {
                        // Vamos a reanudar: cerrar ventana entre intentos
                        betweenAttempts = false;
                        updateSkipButtonState();
                        startVoiceRecognition(targetWord, backElement);
                    }, 100);
                }
            }, 2000);

        } else {
            // Segundo (último) intento fallido
            playErrorSound();
            incorrectCount++;
            
            // AGREGAR la palabra a la lista de incorrectas
            incorrectWords.push(targetWord);
            
            voiceAttempts = 0;
            canFlipBack = false;
            canFlip = false; // Deshabilitar volteo antes de mostrar la respuesta
            // NO eliminar el indicador, mantenerlo visible

            // ANTI-TRUCO: Marcar la tarjeta como completada inmediatamente
            // para evitar que un refresco durante la cuenta regresiva la cuente como restante
            if (!completedCards.has(currentCardIndex)) {
                completedCards.add(currentCardIndex);
                updateCardCounter();
                saveGameProgress();
            }

            // Si esta era la última tarjeta, actualizar el "avance anterior" en el momento 0 del mensaje de error
            // para no perder el resultado si el usuario refresca o cierra la página en la última tarjeta.
            (function() {
                try {
                    const remainingAfter = flashcards.length - completedCards.size;
                    if (remainingAfter === 0) {
                        saveLastGamePercentage();
                    }
                } catch (e) { /* noop */ }
            })();

            // 1. Limpia TODO el contenido del reverso (incluyendo contadores)
            clearBackContent(backElement);
            // Eliminar indicador cuando aparece el mensaje de incorrecto
            removeListeningIndicator(backElement);
            backElement.classList.remove('hidden-text');

            // 2. Muestra el mensaje de "Incorrecto"
            const mensajeError = document.createElement('div');
            mensajeError.className = 'mensaje-error';
            mensajeError.innerHTML = `<i class="fas fa-exclamation-circle"></i>
                <div>Incorrecto</div>`;
            backElement.appendChild(mensajeError);

            // Bloquear "No sé" mientras se muestra el mensaje final de incorrecto y posterior respuesta
            showingErrorMessage = true;
            lockedAfterSecondIncorrect = true;
            updateSkipButtonState();

            // 3. Después de un delay, muestra SOLO la respuesta correcta (sin ningún contador)
            setTimeout(() => {
                betweenAttempts = false;
                showingErrorMessage = false;
                updateSkipButtonState(); // sigue bloqueado por lockedAfterSecondIncorrect
                canFlip = false; // Deshabilitar volteo cuando se muestra la respuesta
                // Elimina cualquier contador de intentos y residuos
                backElement.querySelectorAll('.intentos-back').forEach(el => el.remove());
                clearBackContent(backElement); // LIMPIA TODO preservando indicador
                // Eliminar indicador definitivamente cuando aparece la respuesta final
                removeListeningIndicator(backElement);
                const respuestaCorrecta = document.createElement('div');
                respuestaCorrecta.textContent = targetWord;
                respuestaCorrecta.style.animation = 'respuestaGlow 1.5s infinite';
                backElement.appendChild(respuestaCorrecta);

                // Reproduce el audio si existe y después muestra countdown
                const audioIndex = flashcards.indexOf(card);
                if (hasValidAudio(audioIndex)) {
                    stopAllAudios();
                    audios[audioIndex].play().catch(() => {});
                    audios[audioIndex].addEventListener('ended', () => showCountdown(card), { once: true });
                } else {
                    showCountdown(card);
                }
            }, 2000);

            // Programar la aparición/actualización/ocultación del cuadro de stats
            scheduleStatsBoxUpdate();
            
            // GUARDAR PROGRESO AUTOMÁTICAMENTE
            saveGameProgress();
        }
    }
    // No actualizar contadores de inmediato; lo haremos con el timing del cuadro
}

function palabrasSimilares(a, b) {
    // Normalizar ambas cadenas para una comparación flexible:
    // 1. Eliminar espacios al principio y al final.
    // 2. Convertir todo a minúsculas.
    // 3. Eliminar puntos y comas que pueda añadir el reconocimiento de voz.
    const normA = a.trim().toLowerCase().replace(/[.,]/g, '');
    const normB = b.trim().toLowerCase().replace(/[.,]/g, '');
    
    return normA === normB;
}

function showListeningIndicator(backElement, text = 'Habla ahora') {
    console.log(`showListeningIndicator llamada con voiceAttempts: ${voiceAttempts}`);
    if (!backElement) {
        console.log('Error: backElement es null');
        return;
    }
    // Limpiar cualquier indicador previo dentro de este back
    backElement.querySelectorAll('.listening-indicator').forEach(el => el.remove());
    
    const indicator = document.createElement('div');
    indicator.className = 'listening-indicator super-pulse-indicator';
    // Forzar visibilidad con estilos inline para mayor robustez
    indicator.style.cssText = `
        position: absolute !important;
        top: 50% !important;
        left: 50% !important;
        transform: translate(-50%, -50%) !important;
        z-index: 9999 !important;
        display: block !important;
        opacity: 1 !important;
        visibility: visible !important;
        pointer-events: none !important;
    `;
    
    // Determinar el texto a mostrar basado en el número de intentos
    let displayText, subtitleText;
    
    console.log(`Mostrando indicador con voiceAttempts: ${voiceAttempts}`);
    
    if (voiceAttempts === 0) {
        displayText = "¡Primer intento!";
        subtitleText = "Habla claro y fuerte";
    } else if (voiceAttempts === 1) {
        displayText = "¡Último intento!";
        subtitleText = "Concéntrate y habla claro";
    } else {
        displayText = "¡Habla claro!";
        subtitleText = "Escuchando...";
    }
    
   indicator.innerHTML = `
    <div class="super-pulse-container">
        <div class="pulse-ring pulse-ring-1"></div>
        <div class="pulse-ring pulse-ring-2"></div>
        <div class="pulse-ring pulse-ring-3"></div>
        <div class="pulse-ring pulse-ring-4"></div>
        <div class="pulse-center">
            <div class="mic-emoji">🎤</div>
            <div class="sound-waves">
                <span class="wave-dot"></span>
                <span class="wave-dot"></span>
                <span class="wave-dot"></span>
            </div>
        </div>
        <div class="floating-emojis" aria-hidden="true">
            <span class="floating-emoji e1">E</span> <!-- Norte -->
            <span class="floating-emoji e2">S</span> <!-- Noreste -->
            <span class="floating-emoji e3">P</span> <!-- Este -->
            <span class="floating-emoji e4">A</span> <!-- Sureste -->
            <span class="floating-emoji e5">Ñ</span> <!-- Sur -->
            <span class="floating-emoji e6">O</span> <!-- Suroeste -->
            <span class="floating-emoji e7">L</span> <!-- Oeste -->
        </div>
    </div>
    <div class="super-pulse-text">${displayText}</div>
    <div class="super-pulse-subtitle">${subtitleText}</div>
`;
    // Adjuntar dentro del lado back para que no sea global
    backElement.appendChild(indicator);
    console.log(`Indicador agregado al back. Elementos con clase 'listening-indicator': ${backElement.querySelectorAll('.listening-indicator').length}`);
    
    // Verificar visibilidad del indicador
    setTimeout(() => {
        const indicatorInDOM = backElement.querySelector('.listening-indicator');
        if (indicatorInDOM) {
            const styles = window.getComputedStyle(indicatorInDOM);
            console.log(`Indicador en DOM - Display: ${styles.display}, Opacity: ${styles.opacity}, Visibility: ${styles.visibility}`);
        } else {
            console.log('Error: Indicador no encontrado en DOM después de agregarlo');
        }
    }, 100);
}

// Función para asegurar que el indicador esté presente en el back
function ensureIndicatorVisible(backElement) {
    if (!backElement) return;
    
    const existingIndicator = backElement.querySelector('.listening-indicator, .super-pulse-indicator');
    if (!existingIndicator) {
        console.log('Indicador desaparecido, recreando...');
        showListeningIndicator(backElement);
    } else {
        console.log('Indicador ya presente');
    }
}

// Función para limpiar el contenido del back preservando el indicador
function clearBackContent(backElement) {
    // Preservar todos los indicadores y elementos importantes
    const indicators = backElement.querySelectorAll('.listening-indicator, .super-pulse-indicator');
    const indicatorsData = Array.from(indicators).map(ind => ({
        html: ind.outerHTML,
        element: ind.cloneNode(true)
    }));
    
    // Limpiar contenido
    backElement.innerHTML = '';
    
    // Restaurar indicadores
    indicatorsData.forEach(data => {
        backElement.appendChild(data.element);
    });
    
    console.log(`Contenido limpiado, indicadores preservados: ${indicatorsData.length}`);
}

// --- FIN DEL NUEVO SISTEMA DE VOZ ---

function removeListeningIndicator(backElement = null) {
    if (backElement) {
        backElement.querySelectorAll('.listening-indicator').forEach(el => el.remove());
        return;
    }
    // Como fallback, intenta limpiar en la tarjeta visible
    const visibleBack = document.querySelector('.flashcard.is-visible .back');
    if (visibleBack) {
        visibleBack.querySelectorAll('.listening-indicator').forEach(el => el.remove());
    }
}
let isShuffling = false;

document.getElementById('shuffle-button').addEventListener('click', () => {
    if (isShuffling) return;
    isShuffling = true;
    vibrar(80); 
    document.getElementById('shuffleSound').play().catch(() => {});
    shuffleCards();
    setTimeout(() => { isShuffling = false; }, 800); // Evita abusos rápidos
});

// Botón "No sé"
const skipBtn = document.getElementById('skip-button');
if (skipBtn) {
    skipBtn.addEventListener('click', () => {
        vibrar(60);
        playButtonSound();
        skipCurrentCardAsUnknown();
    });
}

function playSuccessSound() {
    const successAudio = new Audio('https://fawzinoo.github.io/audios/win.mp3');
    successAudio.volume = 0.7;
    successAudio.play().catch(() => {});
}

function showCountdown(card) {
    // Elimina cualquier timer previo
    const back = card.querySelector('.back');
    back.querySelectorAll('.countdown-inline').forEach(el => el.remove());

    // Verificar si es la última tarjeta (tras marcar la actual como completada, remaining debe ser 0 si era la última)
    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
    const remainingCards = flashcards.filter((_, index) => !completedCards.has(index)).length;
    const isLastCard = remainingCards <= 0;

    // Crea el contenedor del timer
    const timerDiv = document.createElement('div');
    timerDiv.className = 'countdown-inline';
    const messageText = isLastCard ? 'Finalizando...' : 'Siguiente tarjeta en...';
    timerDiv.innerHTML = `
        <div class="countdown-inline-circle">
            <span class="countdown-inline-number">3</span>
        </div>
        <div class="countdown-inline-text">${messageText}</div>
    `;
    back.appendChild(timerDiv);

    let count = 3;
    const numberSpan = timerDiv.querySelector('.countdown-inline-number');

    function updateCounter() {
        numberSpan.textContent = count;
        timerDiv.classList.remove('pulse-timer');
        void timerDiv.offsetWidth;
        timerDiv.classList.add('pulse-timer');
        if (count > 0) {
            count--;
            setTimeout(updateCounter, 1000);
        } else {
            timerDiv.remove();
            goToNextCard();
        }
    }
    updateCounter();
}

function goToNextCard() {
    // Reactivar el botón de mezclar al pasar a la siguiente tarjeta
    document.getElementById('shuffle-button').disabled = false;

    // REPRODUCIR SONIDO DE NAIPE al cambiar de tarjeta
    document.getElementById('shuffleSound').play().catch(() => {});

    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
    completedCards.add(currentCardIndex);
    updateCardCounter();
    
    // GUARDAR PROGRESO AUTOMÁTICAMENTE al completar una tarjeta
    saveGameProgress();
    
    canFlipBack = true; // Permitir voltear en la nueva tarjeta
    canFlip = true; // Rehabilitar volteo para la nueva tarjeta
    updateCounters();
    voiceAttempts = 0; // Reiniciar intentos para la nueva tarjeta
    // Cancelar cualquier timeout entre intentos por seguridad
    if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
    if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }
    showingErrorMessage = false;
    lockedAfterSecondIncorrect = false;
    lockedAfterCorrect = false;

    // Buscar la siguiente tarjeta pendiente empezando DESPUÉS de la actual (búsqueda circular)
    const total = flashcards.length;
    let nextIndex = -1;
    for (let step = 1; step <= total; step++) {
        const i = (currentCardIndex + step) % total;
        if (!completedCards.has(i)) {
            nextIndex = i;
            break;
        }
    }
    
    if (nextIndex !== -1) {
        currentCardIndex = nextIndex;
        showCard(currentCardIndex);
    } else {
        // Guardar porcentaje del último partido jugado
        saveLastGamePercentage();
        
        // Decidir qué función llamar según el resultado
        if (correctCount > incorrectCount) {
            // Verificar si es perfecto (sin errores)
            if (incorrectCount === 0) {
                showCompletionEuforiaMaxima(); // PERFECTO: sin errores
            } else {
                showCompletioneuforia(); // GANA: con algunos errores
            }
        } else if (incorrectCount > correctCount) {
            showCompletionPerdida(); // Perdió: mensaje motivacional
        } else {
            showCompletionEmpate(); // Empate: mensaje equilibrado
        }
    }
}

function showCard(index) {
    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
flashcards.forEach(card => {
    card.classList.remove('is-visible', 'flipped');
    const back = card.querySelector('.back');
    // Elimina cualquier contador de intentos
    back.querySelectorAll('.intentos-back').forEach(el => el.remove());
    if (card.dataset.answer) {
        back.innerHTML = card.dataset.answer;
    }
});

    if (flashcards[index]) {
        flashcards[index].classList.add('is-visible');
    }
    updateCounters();
    // Al mostrar una tarjeta, estamos en front: habilitar skip
    betweenAttempts = false;
    updateSkipButtonState();
}

function updateProgress() {
    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
    const totalCards = flashcards.length;
    const percentage = totalCards > 0 ? Math.round((completedCards.size / totalCards) * 100) : 0;
    const porcentajeDiv = document.getElementById('porcentaje-guardado');
    const porcentajeSpan = document.getElementById('current-percentage');
    if (porcentajeDiv && porcentajeSpan) {
        porcentajeSpan.textContent = `${percentage}%`;
    }
}

function updateCounters() {
    // Correctas
    const correctasPill = document.querySelector('.pill-correctas');
    const prevCorrect = Number(correctasPill.getAttribute('data-prev') || 0);
    document.getElementById('correctas-count').textContent = correctCount;

    if (correctCount > prevCorrect) {
        correctasPill.classList.remove('glow-correct');
        void correctasPill.offsetWidth; // Reinicia animación
        correctasPill.classList.add('glow-correct');
    }
    correctasPill.setAttribute('data-prev', correctCount);

    // Incorrectas
    const incorrectasPill = document.querySelector('.pill-incorrectas');
    const prevIncorrect = Number(incorrectasPill.getAttribute('data-prev') || 0);
    document.getElementById('incorrectas-count').textContent = incorrectCount;

    if (incorrectCount > prevIncorrect) {
        incorrectasPill.classList.remove('glow-error');
        void incorrectasPill.offsetWidth; // Reinicia animación
        incorrectasPill.classList.add('glow-error');
    }
    incorrectasPill.setAttribute('data-prev', incorrectCount);

    updateCardCounter();
}

function showCompletionEuforiaMaxima() {
    // LIMPIAR PROGRESO GUARDADO al completar el juego
    clearCurrentProgress();
    
    // Reproducir audio de victoria máxima
    const audioVictoriaMaxima = new Audio('https://fawzinoo.github.io/audios/victoriamaxima.mp3');
    audioVictoriaMaxima.play().catch(error => {
        console.log('Error al reproducir audio de victoria máxima:', error);
    });
    
    // Crear overlay que cubra toda la pantalla
    const fullScreenOverlay = document.createElement('div');
    fullScreenOverlay.id = 'euforia-maxima-overlay';
    fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(45deg, #FFD700 0%, #FFA500 25%, #FF4500 50%, #FF1493 75%, #9932CC 100%);
        background-size: 400% 400%;
        animation: rainbowBackground 3s ease infinite, perfectEntrance 1s ease-out;
    `;
    
    fullScreenOverlay.innerHTML = `
        <div id="trophy-container" style="font-size: 4rem; margin-bottom: 20px; animation: perfectExplosion 1.5s infinite;">🏆</div>
        <div style="font-size: 4rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255,255,255,1); animation: perfectShine 2s ease-in-out infinite;">
            ¡PERFECTO!
        </div>
        <div style="font-size: 2.5rem; margin-bottom: 10px; opacity: 0.95; animation: goldenGlow 2.5s ease-in-out infinite;">
            ¡Sin errores! ¡Eres increíble!
        </div>
        <div style="font-size: 1.8rem; opacity: 0.9; animation: diamondSpark 2s infinite;">
            ¡PUNTUACIÓN MÁXIMA!
        </div>
    `;
    
    // Añadir el overlay al body
    document.body.appendChild(fullScreenOverlay);
    
    // Efecto de confeti DOBLE para perfecto
    confetti({
        particleCount: 200,
        spread: 100,
        origin: { y: 0.4 }
    });
    
    // Segundo confeti con delay
    const confettiTimeoutId = setTimeout(() => {
        confetti({
            particleCount: 150,
            spread: 80,
            origin: { y: 0.7 }
        });
    }, 500);
    
    // DETENER la animación de la copa después de 3 segundos
    const trophyTimeoutId = setTimeout(() => {
        const trophyContainer = fullScreenOverlay.querySelector('#trophy-container');
        if (trophyContainer) {
            trophyContainer.style.animation = 'none';
        }
    }, 3000);
    
    // Permitir salto por clic o toque en cualquier parte
    let skipped = false;
    const clearAll = () => {
        if (skipped) return; skipped = true;
        try { audioVictoriaMaxima.pause(); audioVictoriaMaxima.currentTime = 0; } catch (e) {}
        try { clearTimeout(confettiTimeoutId); } catch (e) {}
        try { clearTimeout(trophyTimeoutId); } catch (e) {}
        if (typeof confetti === 'function' && typeof confetti.reset === 'function') {
            try { confetti.reset(); } catch (e) {}
        }
        if (fullScreenOverlay && fullScreenOverlay.parentNode) {
            fullScreenOverlay.remove();
        }
        document.removeEventListener('click', onSkip, true);
        document.removeEventListener('touchstart', onSkip, true);
        showCompletionMessage();
    };
    const onSkip = () => clearAll();
    document.addEventListener('click', onSkip, true);
    document.addEventListener('touchstart', onSkip, true);
    
    // Fallback automático
    const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
}

function showCompletioneuforia() {
    // LIMPIAR PROGRESO GUARDADO al completar el juego
    clearCurrentProgress();
    
    // Reproducir audio de victoria normal
    const audioVictoriaNormal = new Audio('https://fawzinoo.github.io/audios/victorianormal.mp3');
    audioVictoriaNormal.play().catch(error => {
        console.log('Error al reproducir audio de victoria normal:', error);
    });
    
    // Crear overlay que cubra toda la pantalla
    const fullScreenOverlay = document.createElement('div');
    fullScreenOverlay.id = 'euforia-overlay';
    fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #28a745 0%, #20c997 50%, #17a2b8 100%);
        animation: euforiaEntrance 0.8s ease-out;
    `;
    
    fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: celebrationBounce 1.2s infinite;">🥇</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: euforiaWiggle 1.5s ease-in-out infinite;">
            ¡FANTÁSTICO!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: happyFloat 2s ease-in-out infinite;">
            ¡Excelente resultado!
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: sparkle 1.8s infinite;">
            Calculando puntuación...
        </div>
    `;
    
    // Añadir el overlay al body
    document.body.appendChild(fullScreenOverlay);
    
    // Efecto de confeti normal
    confetti({
        particleCount: 150,
        spread: 70,
        origin: { y: 0.6 }
    });
    
    // Permitir salto por clic o toque en cualquier parte
    let skipped = false;
    const clearAll = () => {
        if (skipped) return; skipped = true;
        try { audioVictoriaNormal.pause(); audioVictoriaNormal.currentTime = 0; } catch (e) {}
        if (typeof confetti === 'function' && typeof confetti.reset === 'function') {
            try { confetti.reset(); } catch (e) {}
        }
        if (fullScreenOverlay && fullScreenOverlay.parentNode) {
            fullScreenOverlay.remove();
        }
        document.removeEventListener('click', onSkip, true);
        document.removeEventListener('touchstart', onSkip, true);
        showCompletionMessage();
    };
    const onSkip = () => clearAll();
    document.addEventListener('click', onSkip, true);
    document.addEventListener('touchstart', onSkip, true);
    
    const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
}

function showCompletionPerdida() {
    // LIMPIAR PROGRESO GUARDADO al completar el juego
    clearCurrentProgress();
    
    // Reproducir audio de derrota
    const audioDerrota = new Audio('https://fawzinoo.github.io/audios/derrota.mp3');
    audioDerrota.play().catch(error => {
        console.log('Error al reproducir audio de derrota:', error);
    });
    
    // Crear overlay que cubra toda la pantalla
    const fullScreenOverlay = document.createElement('div');
    fullScreenOverlay.id = 'perdida-overlay';
    fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 50%, #fd79a8 100%);
        animation: sadFadeIn 1s ease-in;
    `;
    
    fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: sadDrop 2s ease-out infinite;">😔</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: disappointedSway 2.5s ease-in-out infinite;">
            ¡A seguir practicando!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: gentleFloat 3s ease-in-out infinite;">
            La práctica hace al maestro
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: fadingHope 2.2s infinite;">
            Calculando resultados...
        </div>
    `;
    
    // Añadir el overlay al body
    document.body.appendChild(fullScreenOverlay);
    
    // NO hay confeti para perdida
    
    // Permitir salto por clic o toque en cualquier parte
    let skipped = false;
    const clearAll = () => {
        if (skipped) return; skipped = true;
        try { audioDerrota.pause(); audioDerrota.currentTime = 0; } catch (e) {}
        if (fullScreenOverlay && fullScreenOverlay.parentNode) {
            fullScreenOverlay.remove();
        }
        document.removeEventListener('click', onSkip, true);
        document.removeEventListener('touchstart', onSkip, true);
        showCompletionMessage();
    };
    const onSkip = () => clearAll();
    document.addEventListener('click', onSkip, true);
    document.addEventListener('touchstart', onSkip, true);
    
    const finishTimeoutId = setTimeout(() => { clearAll(); }, 7000);
}

function showCompletionEmpate() {
    // LIMPIAR PROGRESO GUARDADO al completar el juego
    clearCurrentProgress();
    
    // Reproducir audio de empate (palpitaciones)
    const audioEmpate = new Audio('https://fawzinoo.github.io/audios/empate.mp3');
    audioEmpate.play().catch(error => {
        console.log('Error al reproducir audio de empate:', error);
    });
    
    // Crear overlay que cubra toda la pantalla
    const fullScreenOverlay = document.createElement('div');
    fullScreenOverlay.id = 'empate-overlay';
    fullScreenOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        text-align: center;
        background: linear-gradient(135deg, #74b9ff 0%, #0984e3 50%, #6c5ce7 100%);
        animation: neutralZoom 0.6s ease-out;
    `;
    
    fullScreenOverlay.innerHTML = `
        <div style="font-size: 6rem; margin-bottom: 20px; animation: balanceSway 2s ease-in-out infinite;">⚖️</div>
        <div style="font-size: 3.5rem; font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 8px rgba(0,0,0,0.3); animation: steadyPulse 2s infinite;">
            ¡Empate perfecto!
        </div>
        <div style="font-size: 2rem; margin-bottom: 10px; opacity: 0.9; animation: calmWave 2.5s ease-in-out infinite;">
            Resultado equilibrado
        </div>
        <div style="font-size: 1.5rem; opacity: 0.8; animation: steadyGlow 2s infinite;">
            Analizando desempeño...
        </div>
    `;
    
    // Añadir el overlay al body
    document.body.appendChild(fullScreenOverlay);
    
    // NO hay confeti para empate
    
    // Permitir salto por clic o toque en cualquier parte
    let skipped = false;
    const clearAll = () => {
        if (skipped) return; skipped = true;
        try { audioEmpate.pause(); audioEmpate.currentTime = 0; } catch (e) {}
        if (fullScreenOverlay && fullScreenOverlay.parentNode) {
            fullScreenOverlay.remove();
        }
        document.removeEventListener('click', onSkip, true);
        document.removeEventListener('touchstart', onSkip, true);
        showCompletionMessage();
    };
    const onSkip = () => clearAll();
    document.addEventListener('click', onSkip, true);
    document.addEventListener('touchstart', onSkip, true);
    
    const finishTimeoutId = setTimeout(() => { clearAll(); }, 9000);
}
function showCompletionMessage() {
    const container = document.getElementById('flashcard-container');
    
    if (correctCount > incorrectCount) {
        if (incorrectCount === 0) {
            // CASO 1A: Victoria PERFECTA (sin errores) - Diseño moderno dorado/negro
            container.innerHTML = `
                <div style="
                    display: flex; 
                    flex-direction: column; 
                    justify-content: center; 
                    align-items: center; 
                    height: 100%; 
                    color: white; 
                    text-align: center;
                    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #1a1a1a 100%);
                    border-radius: 25px;
                    position: relative;
                    overflow: hidden;
                    border: 2px solid #FFD700;
                ">
                    <div style="
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: radial-gradient(circle at 30% 20%, rgba(255,215,0,0.1) 0%, transparent 50%),
                                    radial-gradient(circle at 70% 80%, rgba(255,215,0,0.05) 0%, transparent 50%);
                    "></div>
                    
                    <div id="final-trophy" style="font-size: 4rem; margin-bottom: 30px; animation: perfectExplosion 2s infinite; filter: drop-shadow(0 0 20px #FFD700);">🏆</div>
                    
                    <div style="
                        background: linear-gradient(135deg, rgba(26,26,26,0.95) 0%, rgba(45,45,45,0.95) 100%);
                        padding: 25px 35px;
                        border-radius: 20px;
                        backdrop-filter: blur(20px);
                        border: 1px solid rgba(255,215,0,0.3);
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 0 20px rgba(255,215,0,0.1);
                        margin-bottom: 20px;
                        width: 280px;
                    ">
                        <div style="font-size: 1.1rem; margin-bottom: 20px; color: #FFD700; font-weight: 600; letter-spacing: 1px;">
                            ⭐ PUNTUACIÓN MÁXIMA ⭐
                        </div>
                        <div id="correct-words-btn" style="
                            font-size: 1.1rem; 
                            color: #ffffff; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(0,200,81,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                            font-weight: 500;
                            animation: pulse 2s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                            ✅ Correctas: ${correctCount} (Ver)
                        </div>
                        <div style="
                            font-size: 1.1rem; 
                            color: white; 
                            opacity: 0.7; 
                            font-weight: 500;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, rgba(136,136,136,0.2) 0%, rgba(136,136,136,0.1) 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(136,136,136,0.3);
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        ">
                            ❌ Incorrectas: ${incorrectCount}
                        </div>
                        <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #FFD700; font-weight: 400; text-align: center;">
                            Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                        </div>
                    </div>
                </div>
            `;
        } else {
            // CASO 1B: Victoria NORMAL - Diseño moderno azul/gris
            container.innerHTML = `
                <div style="
                    display: flex; 
                    flex-direction: column; 
                    justify-content: center; 
                    align-items: center; 
                    height: 100%; 
                    color: white; 
                    text-align: center;
                    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
                    border-radius: 25px;
                    position: relative;
                    overflow: hidden;
                    border: 2px solid #4FC3F7;
                ">
                    <div style="
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: radial-gradient(circle at 30% 20%, rgba(79,195,247,0.1) 0%, transparent 50%),
                                    radial-gradient(circle at 70% 80%, rgba(79,195,247,0.05) 0%, transparent 50%);
                    "></div>
                    
                    <div id="celebration-emoji" style="font-size: 4rem; margin-bottom: 30px; animation: perfectExplosion 2s infinite; filter: drop-shadow(0 0 20px #4FC3F7);">🥇</div>
                    
                    <div style="
                        background: linear-gradient(135deg, rgba(30,60,114,0.95) 0%, rgba(42,82,152,0.95) 100%);
                        padding: 25px 35px;
                        border-radius: 20px;
                        backdrop-filter: blur(20px);
                        border: 1px solid rgba(79,195,247,0.3);
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 0 20px rgba(79,195,247,0.1);
                        margin-bottom: 20px;
                        width: 280px;
                    ">
                        <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡ENHORABUENA!
                        </div>
                         <div id="correct-words-btn" style="
                            font-size: 1.1rem; 
                            color: #ffffff; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(0,200,81,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                            font-weight: 500;
                            animation: alternatePulse 4s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                            ✅ Correctas: ${correctCount} (Ver)
                        </div>
                        <div id="incorrect-words-btn" style="
                              font-size: 1.1rem; 
                            color: white; 
                            margin-bottom: 15px;
                            cursor: pointer;
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                            border-radius: 12px;
                            border: 1px solid rgba(255,87,34,0.3);
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                            font-weight: 500;
                            animation: alternatePulseIncorrect 4s infinite;
                            width: 100%;
                            box-sizing: border-box;
                            text-align: left;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                            ❌ Incorrectas: ${incorrectCount} (Ver)
                        </div>
                        <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #B0BEC5; font-weight: 400; text-align: center;">
                            Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                        </div>
                    </div>
                </div>
            `;
        }
    } else if (incorrectCount > correctCount) {
        // CASO 2: Pérdida - Diseño moderno púrpura/gris
        container.innerHTML = `
            <div style="
                display: flex; 
                flex-direction: column; 
                justify-content: center; 
                align-items: center; 
                height: 100%; 
                color: white; 
                text-align: center;
                background: linear-gradient(135deg, #4A148C 0%, #6A1B9A 50%, #4A148C 100%);
                border-radius: 25px;
                position: relative;
                overflow: hidden;
                border: 2px solid #BA68C8;
            ">
                <div style="font-size: 4rem; margin-bottom: 25px; filter: drop-shadow(0 0 15px #BA68C8);">😔</div>
              
               
                <div style="
                    background: linear-gradient(135deg, rgba(74,20,140,0.95) 0%, rgba(106,27,154,0.95) 100%);
                    padding: 20px 30px;
                    border-radius: 18px;
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(186,104,200,0.3);
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    width: 280px;
                ">
                 <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡A SEGUIR PRACTICANDO!
                        </div>
                    <div id="correct-words-btn" style="
                        font-size: 1.1rem; 
                        margin-bottom: 12px;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(0,200,81,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                        font-weight: 500;
                        animation: alternatePulse 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                        ✅ Correctas: ${correctCount} (Ver)
                    </div>
                    <div id="incorrect-words-btn" style="
                        font-size: 1.1rem;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(255,87,34,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                        font-weight: 500;
                        animation: alternatePulseIncorrect 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                        ❌ Incorrectas: ${incorrectCount} (Ver)
                    </div>
                    <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #BA68C8; font-weight: 400; text-align: center;">
                        Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                    </div>
                </div>
            </div>
        `;
    } else {
        // CASO 3: Empate - Diseño moderno gris/plateado
        container.innerHTML = `
            <div style="
                display: flex; 
                flex-direction: column; 
                justify-content: center; 
                align-items: center; 
                height: 100%; 
                color: white; 
                text-align: center;
                background: linear-gradient(135deg, #37474F 0%, #546E7A 50%, #37474F 100%);
                border-radius: 25px;
                position: relative;
                overflow: hidden;
                border: 2px solid #90A4AE;
            ">
                <div style="font-size: 4rem; margin-bottom: 25px; filter: drop-shadow(0 0 15px #90A4AE);">⚖️</div>
             
               
                <div style="
                    background: linear-gradient(135deg, rgba(55,71,79,0.95) 0%, rgba(84,110,122,0.95) 100%);
                    padding: 20px 30px;
                    border-radius: 18px;
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(144,164,174,0.3);
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    width: 280px;
                ">
                   <div style="font-size: 1.1rem; margin-bottom: 20px; color: #4FC3F7; font-weight: 600; letter-spacing: 1px;">
                            ¡EMPATE PERFECTO!
                        </div>
                      <div id="correct-words-btn" style="
                        font-size: 1.1rem; 
                        margin-bottom: 12px;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #00C851 0%, #00A041 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(0,200,81,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(0,200,81,0.2);
                        font-weight: 500;
                        animation: alternatePulse 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,200,81,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,200,81,0.2)'">
                        ✅ Correctas: ${correctCount} (Ver)
                    </div>
                    <div id="incorrect-words-btn" style="
                        font-size: 1.1rem;
                        cursor: pointer;
                        padding: 12px 20px;
                        background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
                        border-radius: 12px;
                        border: 1px solid rgba(255,87,34,0.3);
                        color: #fff;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(255,87,34,0.2);
                        font-weight: 500;
                        animation: alternatePulseIncorrect 4s infinite;
                        width: 100%;
                        box-sizing: border-box;
                        text-align: left;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255,87,34,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255,87,34,0.2)'">
                        ❌ Incorrectas: ${incorrectCount} (Ver)
                    </div>
                    <div style="font-size: 1rem; opacity: 0.8; margin-top: 8px; color: #90A4AE; font-weight: 400; text-align: center;">
                        Precisión: ${flashcards.length > 0 ? Math.round((correctCount / flashcards.length) * 100) : 0}%
                    </div>
                </div>
            </div>
        `;
    }

    // DETENER SOLO las animaciones del fondo y elementos decorativos después de 3 segundos
    // PERO MANTENER la animación pulse del botón verde
    setTimeout(() => {
        const finalTrophy = document.getElementById('final-trophy');
        const celebrationEmoji = document.getElementById('celebration-emoji');
        const containerDiv = container.firstElementChild;
        
        if (finalTrophy) finalTrophy.style.animation = 'none';
        if (celebrationEmoji) celebrationEmoji.style.animation = 'none';
        if (containerDiv) containerDiv.style.animation = 'none';
        
        // ⭐ NO detener la animación pulse del botón verde
        // Línea eliminada: if (correctBtn) correctBtn.style.animation = 'none';
    }, 3000);

    // AÑADIR EVENT LISTENERS para los botones clicables
    setTimeout(() => {
        const correctBtn = document.getElementById('correct-words-btn');
        const incorrectBtn = document.getElementById('incorrect-words-btn');

        if (correctBtn) {
            correctBtn.addEventListener('click', function() {
                vibrar(50);
                playButtonSound();
                showCorrectWords();
            });
        }
        
        if (incorrectBtn) {
            incorrectBtn.addEventListener('click', function() {
                vibrar(50);
                playButtonSound();
                showIncorrectWords();
            });
        }
    }, 100);
}

// Función para mostrar palabras correctas
function showCorrectWords() {
    const overlay = document.createElement('div');
    overlay.id = 'correct-words-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;
    
    const wordsHtml = correctWords.length > 0 
        ? correctWords.map(word => `
            <div class="word-card correct-word" onclick="vibrar(50); playButtonSound(); showItemImage('${word}')">
                <span class="word-text">${word}</span>
                <div class="word-checkmark">✓</div>
            </div>
        `).join('')
        : '<div class="no-words-message"><span class="no-words-icon">🎯</span><p>No hay palabras acertadas</p></div>';
    
    overlay.innerHTML = `
        <div class="modal-container correct-modal">
            <div class="modal-header">
                <div class="modal-title-row">
                    <h2 class="modal-title">Palabras Acertadas</h2>
                </div>
                <div class="modal-stats">${correctWords.length} ${correctWords.length === 1 ? 'palabra' : 'palabras'}</div>
            </div>
            
            <div class="modal-content">
                <div class="words-container">
                    ${wordsHtml}
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="modal-close-btn correct-btn" onclick="vibrar(50); playButtonSound(); document.getElementById('correct-words-overlay').remove()">
                    <span>Cerrar</span>
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Cerrar modal al hacer clic en el fondo
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            vibrar(50);
            playButtonSound();
            overlay.remove();
        }
    });
}

// Función para mostrar palabras incorrectas
function showIncorrectWords() {
    const overlay = document.createElement('div');
    overlay.id = 'incorrect-words-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;
    
    const wordsHtml = incorrectWords.length > 0 
        ? incorrectWords.map(word => `
            <div class="word-card incorrect-word" onclick="vibrar(50); playButtonSound(); showItemImage('${word}')">
                <span class="word-text">${word}</span>
                <div class="word-checkmark">✗</div>
            </div>
        `).join('')
        : '<div class="no-words-message"><span class="no-words-icon">🎯</span><p>No hay palabras incorrectas</p></div>';
    
    overlay.innerHTML = `
        <div class="modal-container incorrect-modal">
            <div class="modal-header">
                <div class="modal-title-row">
                    <h2 class="modal-title">Palabras Incorrectas</h2>
                </div>
                <div class="modal-stats">${incorrectWords.length} ${incorrectWords.length === 1 ? 'palabra' : 'palabras'}</div>
            </div>
            
            <div class="modal-content">
                <div class="words-container">
                    ${wordsHtml}
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="modal-close-btn incorrect-btn" onclick="vibrar(50); playButtonSound(); document.getElementById('incorrect-words-overlay').remove()">
                    <span>Cerrar</span>
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Cerrar modal al hacer clic en el fondo
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            vibrar(50);
            playButtonSound();
            overlay.remove();
        }
    });
}

// Variables para rastrear palabras correctas e incorrectas
let correctWords = [];
let incorrectWords = [];

// ============ SISTEMA DE PERSISTENCIA DE PROGRESO ============
// Función para guardar el progreso actual en localStorage
function saveGameProgress() {
    const gameState = {
        currentCardIndex: currentCardIndex,
        completedCards: Array.from(completedCards),
        correctCount: correctCount,
        incorrectCount: incorrectCount,
        correctWords: [...correctWords],
        incorrectWords: [...incorrectWords],
        voiceAttempts: voiceAttempts,
        timestamp: Date.now(),
        cardOrder: flashcards.map(card => ({
            frontImg: card.querySelector('.front img').src,
            frontAlt: card.querySelector('.front img').alt,
            backText: card.dataset.answer
        }))
    };
    
    try {
        const stateString = JSON.stringify(gameState);
        localStorage.setItem('paises1_gameProgress', stateString); // ✅ Cambiado de paises2_gameProgress
        console.log(`✅ Progreso guardado automáticamente. voiceAttempts: ${voiceAttempts}`);
    } catch (error) {
        if (error.name === 'QuotaExceededError') {
            console.warn('⚠️ LocalStorage lleno, limpiando datos antiguos del tema actual...');
            clearOldThemeData();
            
            try {
                localStorage.setItem('paises1_gameProgress', JSON.stringify(gameState)); // ✅ Cambiado
                console.log('✅ Progreso guardado después de limpiar datos del tema');
            } catch (secondError) {
                console.error('❌ Error persistente al guardar progreso:', secondError);
                const minimalState = {
                    currentCardIndex: currentCardIndex,
                    completedCards: Array.from(completedCards),
                    correctCount: correctCount,
                    incorrectCount: incorrectCount,
                    voiceAttempts: voiceAttempts,
                    timestamp: Date.now()
                };
                try {
                    localStorage.setItem('paises1_gameProgress', JSON.stringify(minimalState)); // ✅ Cambiado
                    console.log('✅ Progreso mínimo guardado exitosamente');
                } catch (finalError) {
                    console.error('💥 No se pudo guardar ningún progreso:', finalError);
                }
            }
        } else {
            console.error('❌ Error inesperado al guardar progreso:', error);
        }
    }
}

// Nueva función que SOLO limpia datos del tema actual, respeta otros temas
function clearOldThemeData() {
    console.log('🧹 Limpiando datos antiguos SOLO del tema actual...');
    
    // ✅ Claves estandarizadas con paises1
    const currentThemeKeys = [
        'paises1_gameProgress',       // progreso actual del tema
        'paises1',                    // último resultado del tema (ya correcto)
        'paises1Date',                // fecha del último resultado (ya correcto)
    ];
    
    const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    
    currentThemeKeys.forEach(key => {
        const data = localStorage.getItem(key);
        if (data) {
            try {
                if (key.includes('gameProgress')) {
                    const parsed = JSON.parse(data);
                    if (parsed.timestamp && parsed.timestamp < weekAgo) {
                        localStorage.removeItem(key);
                        console.log(`🗓️ Eliminado progreso antiguo: ${key}`);
                    }
                }
                else if (key.includes('Date')) {
                    const date = new Date(data);
                    if (date.getTime() < weekAgo) {
                        const associatedKey = key.replace('Date', '');
                        localStorage.removeItem(key);
                        localStorage.removeItem(associatedKey);
                        console.log(`🗓️ Eliminados datos antiguos: ${key}, ${associatedKey}`);
                    }
                }
            } catch (e) {
                if (key === 'paises1_gameProgress') { // ✅ Cambiado
                    localStorage.removeItem(key);
                    console.log(`🔧 Eliminados datos corruptos: ${key}`);
                }
            }
        }
    });
    
    // Limpiar datos temporales/cache genéricos (seguros de eliminar)
    const safeToClearPatterns = [
        /^temp_/,
        /^cache_/,
        /^session_/,
        /^tmp_/,
    ];
    
    const allKeys = [];
    for (let i = 0; i < localStorage.length; i++) {
        allKeys.push(localStorage.key(i));
    }
    
    let clearedGeneric = 0;
    allKeys.forEach(key => {
        if (key && safeToClearPatterns.some(pattern => pattern.test(key))) {
            localStorage.removeItem(key);
            clearedGeneric++;
        }
    });
    
    if (clearedGeneric > 0) {
        console.log(`🗑️ Eliminadas ${clearedGeneric} entradas temporales genéricas`);
    }
    
    console.log('✅ Limpieza completada - otros temas preservados');
}

function clearOldStorageData() {
    console.log('🧹 Limpiando localStorage...');
    
    // Lista de claves a mantener (datos importantes) - actualizada con paises1
    const keepKeys = [
        'paises1_gameProgress',      // ✅ Cambiado
        'lastSuccessPercentage',
        'lastUpdateDate',
        'paises1',                   // ✅ Ya correcto
        'paises1Date',               // ✅ Ya correcto
        'microphonePermissionGranted'
    ];
    
    // Obtener todas las claves y eliminar las que no son esenciales
    const allKeys = [];
    for (let i = 0; i < localStorage.length; i++) {
        allKeys.push(localStorage.key(i));
    }
    
    let clearedItems = 0;
    allKeys.forEach(key => {
        if (key && !keepKeys.includes(key)) {
            localStorage.removeItem(key);
            clearedItems++;
        }
    });
    
    console.log(`🗑️ Eliminadas ${clearedItems} entradas antiguas de localStorage`);
    
    // Si todavía hay problemas, optimizar los datos que sí guardamos
    if (clearedItems === 0) {
        console.log('🔧 Optimizando datos existentes...');
        
        // Eliminar datos de progreso muy antiguos (más de 7 días)
        const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
        const savedProgress = localStorage.getItem('paises1_gameProgress'); // ✅ Cambiado
        
        if (savedProgress) {
            try {
                const data = JSON.parse(savedProgress);
                if (data.timestamp && data.timestamp < weekAgo) {
                    localStorage.removeItem('paises1_gameProgress'); // ✅ Cambiado
                    console.log('🗓️ Eliminado progreso muy antiguo');
                }
            } catch (e) {
                // Si hay datos corruptos, eliminarlos
                localStorage.removeItem('paises1_gameProgress'); // ✅ Cambiado
                console.log('🔧 Eliminados datos corruptos');
            }
        }
    }
}

// Función para cargar el progreso desde localStorage
function loadGameProgress() {
    const savedState = localStorage.getItem('paises1_gameProgress'); // ✅ Cambiado
    if (!savedState) return null;
    
    try {
        const parsedState = JSON.parse(savedState);
        const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
        if (parsedState.timestamp && parsedState.timestamp < weekAgo) {
            console.log('🗓️ Progreso guardado muy antiguo, ignorando...');
            localStorage.removeItem('paises1_gameProgress'); // ✅ Cambiado
            return null;
        }
        return parsedState;
    } catch (error) {
        console.error('❌ Error al cargar progreso guardado:', error);
        localStorage.removeItem('paises1_gameProgress'); // ✅ Cambiado
        return null;
    }
}

// Función para restaurar el estado del juego
function restoreGameState(gameState) {
    if (!gameState) return false;
    
    try {
        // Restaurar variables de estado
        currentCardIndex = gameState.currentCardIndex || 0;
        completedCards = new Set(gameState.completedCards || []);
        correctCount = gameState.correctCount || 0;
        incorrectCount = gameState.incorrectCount || 0;
        correctWords = [...(gameState.correctWords || [])];
        incorrectWords = [...(gameState.incorrectWords || [])];
        voiceAttempts = gameState.voiceAttempts || 0;
        
        // Restaurar orden de tarjetas si existe
        if (gameState.cardOrder && gameState.cardOrder.length === flashcards.length) {
            flashcards.forEach((card, index) => {
                const cardData = gameState.cardOrder[index];
                if (cardData) {
                    card.querySelector('.front img').src = cardData.frontImg;
                    card.querySelector('.front img').alt = cardData.frontAlt;
                    const back = card.querySelector('.back');
                    back.innerHTML = cardData.backText;
                    card.dataset.answer = cardData.backText;
                }
            });
        }
        
        // Reasignar audios a cada tarjeta según su respuesta (por si el orden se cambió)
        reassignAudiosToCards();

        // IMPORTANTE: Resetear el estado de las tarjetas al restaurar
        flashcards.forEach(card => {
            card.classList.remove('is-visible', 'flipped');
            const back = card.querySelector('.back');
            // Limpiar cualquier indicador de escucha previo
            back.querySelectorAll('.listening-indicator').forEach(el => el.remove());
            back.classList.remove('hidden-text');
        });
        
        // Si el índice actual apunta a una tarjeta ya completada, avanzar a la primera pendiente empezando desde la siguiente (circular)
        try {
            const total = flashcards.length;
            if (total > 0 && completedCards.has(currentCardIndex)) {
                for (let step = 1; step <= total; step++) {
                    const i = (currentCardIndex + step) % total;
                    if (!completedCards.has(i)) { currentCardIndex = i; break; }
                }
            }
        } catch (e) {}

        // Actualizar interfaz
        updateCounters();
        updateCardCounter();
        updateSuccessPercentage();
        
        // Mostrar tarjeta actual
        showCard(currentCardIndex);
        
        console.log('Estado del juego restaurado exitosamente');
        console.log(`Restaurado: voiceAttempts=${voiceAttempts}, currentCardIndex=${currentCardIndex}, correctCount=${correctCount}, incorrectCount=${incorrectCount}`);
        return true;
    } catch (error) {
        console.error('Error al restaurar estado del juego:', error);
        return false;
    }
}

// Función para limpiar solo el progreso actual (mantener avance anterior)
function clearCurrentProgress() {
    localStorage.removeItem('paises1_gameProgress');
    console.log('Progreso actual limpiado');
}

// Función para verificar si hay progreso guardado Y el juego NO está completado
function hasProgressSaved() {
    const savedState = loadGameProgress();
    if (!savedState) return false;
    
    // Verificar si el juego está completado
    const totalCards = flashcards.length;
    const completedCount = savedState.completedCards ? savedState.completedCards.length : 0;
    const isGameCompleted = completedCount >= totalCards;
    
    // Si el juego está completado, NO mostrar modal de continuación
    if (isGameCompleted) {
        console.log('Juego completado detectado, limpiando progreso y reiniciando');
        clearCurrentProgress();
        return false;
    }
    
    // Verificar si hay progreso significativo (al menos una tarjeta completada o un intento)
    const hasProgress = (savedState.completedCards && savedState.completedCards.length > 0) ||
                       (savedState.correctCount > 0) ||
                       (savedState.incorrectCount > 0) ||
                       (savedState.voiceAttempts > 0);
    
    return hasProgress;
}

// Función para mostrar el modal de continuación
function showContinueGameModal() {
    const savedState = loadGameProgress();
    if (!savedState) return;
    
    const totalCards = flashcards.length;
    const completedCount = savedState.completedCards ? savedState.completedCards.length : 0;
    const remaining = totalCards - completedCount;
    const correctCount = savedState.correctCount || 0;
    const incorrectCount = savedState.incorrectCount || 0;
    
    const overlay = document.createElement('div');
    overlay.className = 'continue-game-overlay';
    overlay.id = 'continue-game-overlay';
    
    overlay.innerHTML = `
        <div class="continue-game-modal">
            <div class="continue-modal-header">
                <span class="continue-modal-icon">🎯</span>
                <h2 class="continue-modal-title">¡Progreso Detectado!</h2>
                <p class="continue-modal-subtitle">Tienes un juego en progreso</p>
            </div>
            
            <div class="continue-modal-content">
                <div class="continue-progress-info">
                    <div class="continue-progress-title">Tu progreso actual:</div>
                    <div class="continue-progress-stats">
                        <div class="continue-stat-item">
                            <div class="continue-stat-number correct">${correctCount}</div>
                            <div class="continue-stat-label">Correctas</div>
                        </div>
                        <div class="continue-stat-item">
                            <div class="continue-stat-number incorrect">${incorrectCount}</div>
                            <div class="continue-stat-label">Incorrectas</div>
                        </div>
                        <div class="continue-stat-item">
                            <div class="continue-stat-number remaining">${remaining}</div>
                            <div class="continue-stat-label">Restantes</div>
                        </div>
                    </div>
                </div>
                
                <div class="continue-modal-buttons">
                    <button class="continue-btn continue-btn-primary" id="continue-game-btn">
                        <i class="fas fa-play"></i>
                        Continuar
                    </button>
                    <button class="continue-btn continue-btn-secondary" id="start-fresh-btn">
                        <i class="fas fa-sync-alt"></i>
                        Empezar de Cero
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Event listeners para los botones
    const continueBtn = overlay.querySelector('#continue-game-btn');
    const startFreshBtn = overlay.querySelector('#start-fresh-btn');
    
    continueBtn.addEventListener('click', function() {
        vibrar(60);
        playButtonSound();
        
        // Restaurar el estado del juego
        if (restoreGameState(savedState)) {
            overlay.remove();
            console.log('Juego continuado desde el progreso guardado');
        } else {
            console.error('Error al restaurar el juego, empezando de cero');
            clearCurrentProgress();
            overlay.remove();
            initializeNewGame();
        }
    });
    
    startFreshBtn.addEventListener('click', function() {
        vibrar(60);
        playButtonSound();
        
        // Limpiar progreso actual pero mantener avance anterior
        clearCurrentProgress();
        overlay.remove();
        initializeNewGame();
        console.log('Nuevo juego iniciado');
    });
    
    // Cerrar modal al hacer clic en el fondo (por defecto continúa)
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            vibrar(40);
            // Por defecto continuar el juego
            if (restoreGameState(savedState)) {
                overlay.remove();
            }
        }
    });
}

// Función para inicializar un nuevo juego
function initializeNewGame() {
    // Resetear todas las variables
    currentCardIndex = 0;
    voiceAttempts = 0;
    completedCards.clear();
    correctWords.length = 0;
    incorrectWords.length = 0;
    correctCount = 0;
    incorrectCount = 0;
    canFlipBack = true;
    canFlip = true;
    
    // Mezclar tarjetas
    shuffleCards();
    
    // Actualizar interfaz
    updateCounters();
    updateCardCounter();
    
    // Mostrar primera tarjeta
    showCard(0);
}

// Mapeo de países a códigos de bandera
const countryFlags = {
    'España': 'es',
    'Marruecos': 'ma', 
    'México': 'mx',
    'Argentina': 'ar',
    'Francia': 'fr',
    'Italia': 'it',
    'Alemania': 'de',
    'Brasil': 'br',
    'Chile': 'cl',
    'Peru': 'pe',
    'Colombia': 'co',
    'Portugal': 'pt',
    'Grecia': 'gr',
    'Turquía': 'tr',
    'Japón': 'jp',
    'China': 'cn',
    'India': 'in',
    'Rusia': 'ru',
    'Canadá': 'ca',
    'Australia': 'au'
};

// Helper: normalizar nombre de país (minúsculas, sin tildes, trim)
function normalizeCountryKey(str) {
    return (str || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/\p{Diacritic}+/gu, '') // quitar acentos
        .trim();
}

// Índice normalizado para lookup robusto (soporta con/sin acentos)
const countryFlagsByKey = {};
Object.keys(countryFlags).forEach(name => {
    countryFlagsByKey[normalizeCountryKey(name)] = countryFlags[name];
});

// Variable global para el overlay de bandera
let currentFlagOverlay = null;

// Base opcional para imágenes genéricas (png/jpg/webp). Puedes cambiar esta URL.
const baseImagesUrl = 'https://fawzinoo.github.io/Fotos/';

// Mostrar imagen genérica o bandera si existe
function showItemImage(name) {
    const candidates = [];
    const key = normalizeAudioKey(name); // minúsculas, sin tildes, con guiones

    // 1) Preferir la imagen actual de la tarjeta (front) si existe
    try {
        const match = flashcards.find(card => {
            const ans = card.dataset.answer || (card.querySelector('.back')?.textContent?.trim() || '');
            return normalizeAudioKey(ans) === key;
        });
        const frontSrc = match?.querySelector('.front img')?.src;
        if (frontSrc) candidates.push(frontSrc);
    } catch (e) {}

    // 2) Intentar recursos locales/genéricos por nombre normalizado en varios formatos
    ['png','jpg','jpeg','webp'].forEach(ext => {
        candidates.push(`${baseImagesUrl}${key}.${ext}`);
    });

    // 3) Finalmente, bandera si hay código conocido
    const code = countryFlags[name] || countryFlagsByKey[normalizeCountryKey(name)];
    if (code) {
        candidates.push(`https://flagcdn.com/w640/${code}.png`);
    }
    
    // Función para probar en cadena hasta cargar una
    const tryNext = (idx) => {
        if (idx >= candidates.length) {
            // Fallback: imagen inline de no disponible
            openImageModal('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+');
            return;
        }
        const url = candidates[idx];
        const testImg = new Image();
        testImg.onload = () => openImageModal(url, name);
        testImg.onerror = () => tryNext(idx + 1);
        testImg.src = url;
    };
    tryNext(0);
}

function openImageModal(src, name = '') {
    // Cerrar anterior si existe
    if (currentFlagOverlay) { currentFlagOverlay.remove(); currentFlagOverlay = null; }
    const overlay = document.createElement('div');
    overlay.id = 'flag-modal-overlay';
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
        display: flex; justify-content: center; align-items: center;
        z-index: 15000; opacity: 0; animation: fadeInOverlay 0.3s ease-out forwards;`;
    currentFlagOverlay = overlay;
    overlay.innerHTML = `
        <div class="flag-card-container">
            <div class="flag-controls-floating">
                <button class="flag-control-btn fullscreen-btn" title="Pantalla completa"> 
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
                </button>
                <button class="flag-control-btn restore-btn" title="Restituir" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                </button>
                <button class="flag-control-btn close-btn" title="Cerrar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div class="flag-card-body-full">
                <img id="flag-image" src="${src}" alt="${name ? 'Imagen de '+name : 'Imagen'}" class="flag-display" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+'" />
            </div>
        </div>`;
    document.body.appendChild(overlay);
    const fullscreenBtn = overlay.querySelector('.fullscreen-btn');
    const restoreBtn = overlay.querySelector('.restore-btn');
    const closeBtn = overlay.querySelector('.close-btn');
    if (fullscreenBtn) fullscreenBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); toggleFullscreen(); });
    if (restoreBtn) restoreBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); exitFullscreen(); });
    if (closeBtn) closeBtn.addEventListener('click', () => { vibrar(50); playButtonSound(); closeFlagModal(); });
    overlay.addEventListener('click', (e) => { if (e.target === overlay) { vibrar(50); playButtonSound(); closeFlagModal(); }});
}

// Función para mostrar la bandera del país
function showCountryFlag(countryName) {
    // Cerrar overlay anterior si existe
    if (currentFlagOverlay) {
        currentFlagOverlay.remove();
        currentFlagOverlay = null;
    }
    
    // Buscar por clave exacta o clave normalizada (para soportar tildes)
    const flagCode = countryFlags[countryName] || countryFlagsByKey[normalizeCountryKey(countryName)];
    if (!flagCode) {
        console.log(`No se encontró código de bandera para: ${countryName}`);
        return;
    }
    
    const flagUrl = `https://flagcdn.com/w640/${flagCode}.png`;
    
    const overlay = document.createElement('div');
    overlay.id = 'flag-modal-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 15000;
        opacity: 0;
        animation: fadeInOverlay 0.3s ease-out forwards;
    `;
    
    // Guardar referencia global
    currentFlagOverlay = overlay;
    
    overlay.innerHTML = `
        <div class="flag-card-container">
            <div class="flag-controls-floating">
                <button class="flag-control-btn fullscreen-btn" title="Pantalla completa">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                    </svg>
                </button>
                <button class="flag-control-btn restore-btn" title="Restituir" style="display: none;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <button class="flag-control-btn close-btn" title="Cerrar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="flag-card-body-full">
                <img id="flag-image" src="${flagUrl}" alt="Bandera de ${countryName}" class="flag-display" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y4ZjlmYSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzZiNzI4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSI+SW1hZ2VuIG5vIGRpc3BvbmlibGU8L3RleHQ+PC9zdmc+'" />
            </div>
        </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Agregar event listeners después de crear el HTML
    const fullscreenBtn = overlay.querySelector('.fullscreen-btn');
    const restoreBtn = overlay.querySelector('.restore-btn');
    const closeBtn = overlay.querySelector('.close-btn');
    
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', function() {
            vibrar(50);
            playButtonSound();
            toggleFullscreen();
        });
    }
    
    if (restoreBtn) {
        restoreBtn.addEventListener('click', function() {
            vibrar(50);
            playButtonSound();
            exitFullscreen();
        });
    }
    
    if (closeBtn) {
        closeBtn.addEventListener('click', function() {
            vibrar(50);
            playButtonSound();
            closeFlagModal();
        });
    }
    
    // Cerrar modal al hacer clic en el fondo
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            vibrar(50);
            playButtonSound();
            closeFlagModal();
        }
    });
}

// Funciones para pantalla completa
function toggleFullscreen() {
    if (!currentFlagOverlay) return;
    
    const flagContainer = currentFlagOverlay.querySelector('.flag-card-container');
    const fullscreenBtn = currentFlagOverlay.querySelector('.fullscreen-btn');
    const restoreBtn = currentFlagOverlay.querySelector('.restore-btn');
    
    if (!flagContainer || !fullscreenBtn || !restoreBtn) return;
    
    // Añadir clase para pantalla completa
    flagContainer.classList.add('fullscreen-mode');
    
    // Cambiar visibilidad de botones
    fullscreenBtn.style.display = 'none';
    restoreBtn.style.display = 'flex';
    
    // Aplicar estilos de pantalla completa al contenedor
    flagContainer.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        max-width: none !important;
        max-height: none !important;
        z-index: 20000 !important;
        border-radius: 0 !important;
        border: none !important;
        background: linear-gradient(to right, #1f3658, #3558e3) !important;
        display: flex !important;
        flex-direction: column !important;
        overflow: hidden !important;
        animation: expandToFullscreen 0.3s ease-out !important;
    `;
    
    // Ocultar el overlay de fondo
    currentFlagOverlay.style.background = 'transparent';
}

function exitFullscreen() {
    if (!currentFlagOverlay) return;
    
    const flagContainer = currentFlagOverlay.querySelector('.flag-card-container');
    const fullscreenBtn = currentFlagOverlay.querySelector('.fullscreen-btn');
    const restoreBtn = currentFlagOverlay.querySelector('.restore-btn');
    
    if (!flagContainer || !fullscreenBtn || !restoreBtn) return;
    
    // Remover clase de pantalla completa
    flagContainer.classList.remove('fullscreen-mode');
    
    // Cambiar visibilidad de botones
    fullscreenBtn.style.display = 'flex';
    restoreBtn.style.display = 'none';
    
    // Restaurar estilos originales del contenedor
    flagContainer.style.cssText = `
        width: 100%;
        height: 500px;
        max-height: 500px;
        max-width: 400px;
        background: linear-gradient(to right, #1f3658, #3558e3);
        border-radius: 25px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        border: 3px solid #aab0b4;
        overflow: hidden;
        position: relative;
        animation: slideInModal 0.4s ease-out;
        display: flex;
        flex-direction: column;
    `;
    
    // Restaurar el overlay de fondo
    currentFlagOverlay.style.background = 'rgba(0, 0, 0, 0.9)';
}

// Función para cerrar el modal de bandera
function closeFlagModal() {
    if (currentFlagOverlay) {
        currentFlagOverlay.remove();
        currentFlagOverlay = null;
    }
}




const baseUrl = 'https://fawzinoo.github.io/audios/';
const audioFiles = [
    'espana.mp3', 'marruecos.mp3', 'mexico.mp3', 'argentina.mp3', 'colombia.mp3',
    'peru.mp3', 'chile.mp3', 'venezuela.mp3', 'ecuador.mp3', 'bolivia.mp3',
    'paraguay.mp3', 'uruguay.mp3', 'guatemala.mp3', 'cuba.mp3', 'republica-dominicana.mp3',
    'Honduras.mp3', 'Nicaragua.mp3', 'costa-rica.mp3', 'panama.mp3', 'el-salvador.mp3',
    'guinea-ecuatorial.mp3', 'Estados-unidos.mp3', 'canada.mp3', 'brazil.mp3', 'francia.mp3',
    'alemania.mp3', 'holanda.mp3', 'belgica.mp3', 'dinamarca.mp3', 'italia.mp3',
    'reino-unido.mp3', 'rusia.mp3', 'china.mp3', 'japon.mp3', 'corea-del-sur.mp3',
    'india.mp3', 'australia.mp3', 'sudafrica.mp3', 'egipto.mp3', 'nigeria.mp3',
    'turquia.mp3', 'arabia-saudi.mp3', 'iran.mp3'
];

const audios = audioFiles.map(file => {
    const audio = new Audio();
    audio.preload = 'none';
    audio.src = baseUrl + file;
    return audio;
});

// Normalizador y mapa para resolver el audio correcto según el nombre del país
function normalizeAudioKey(str) {
    return (str || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '') // quitar acentos
        .replace(/\s+/g, '-')             // espacios -> guiones
        .replace(/[^a-z-]/g, '');          // solo letras y guiones
}

const audioFilenameByKey = {};
audioFiles.forEach(file => {
    const base = file.replace(/\.mp3$/i, '');
    const key = normalizeAudioKey(base);
    audioFilenameByKey[key] = file; // guarda el nombre de archivo original
});

function getAudioSrcForCountryName(countryName) {
    const key = normalizeAudioKey(countryName);
    const file = audioFilenameByKey[key];
    return file ? (baseUrl + file) : null;
}

// Alias para discrepancias de nombres entre el texto mostrado y el archivo de audio
// Evita que tarjetas como "Brasil" (archivo brazil.mp3) queden sin src y bloqueen el flujo
if (audioFilenameByKey['brazil'] && !audioFilenameByKey['brasil']) {
    audioFilenameByKey['brasil'] = audioFilenameByKey['brazil'];
}

// Helper robusto para saber si un índice de audio tiene realmente una fuente válida
function hasValidAudio(index) {
    const a = audios[index];
    return !!(a && a.src && a.src.trim() !== '');
}

// Copia del HTML original del contenedor de tarjetas para poder restaurar tras pantallas finales
let originalFlashcardsHTML = null;
const flashcards = Array.from(document.querySelectorAll('.flashcard'));

function shuffleCards() {
    stopAllAudios();
document.querySelectorAll('.countdown-overlay, .mensaje-error, .listening-indicator').forEach(el => el.remove());


    // 1. Obtener los datos de todas las tarjetas.
const allCardData = flashcards.map((card, index) => ({
    frontImg: card.querySelector('.front img').src,
    frontAlt: card.querySelector('.front img').alt,
    // CORRECTO: usar el texto del reverso real
    backText: card.querySelector('.back').textContent.trim()
}));

    // 2. Separar los datos de las tarjetas en pendientes y completadas.
    const remainingCardData = [];
    const completedCardData = [];
    allCardData.forEach((data, index) => {
        if (completedCards.has(index)) {
            completedCardData.push(data);
        } else {
            remainingCardData.push(data);
        }
    });

    // 3. Barajar solo las tarjetas pendientes.
    for (let i = remainingCardData.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [remainingCardData[i], remainingCardData[j]] = [remainingCardData[j], remainingCardData[i]];
    }

    // 4. Crear el nuevo mazo: pendientes barajadas primero, luego las completadas.
    const newCardOrder = [...remainingCardData, ...completedCardData];

    // 5. Actualizar el DOM y los audios según el nuevo orden.
flashcards.forEach((card, index) => {
    const data = newCardOrder[index];
    card.classList.remove('is-visible', 'flipped');
    card.querySelector('.front img').src = data.frontImg;
    card.querySelector('.front img').alt = data.frontAlt;
    // Restaurar el texto original del reverso por si había cambiado a "Incorrecto"
    const back = card.querySelector('.back');
// Elimina cualquier contador de intentos antes de restaurar el texto
back.querySelectorAll('.intentos-back').forEach(el => el.remove());
back.innerHTML = data.backText;
    // --- ACTUALIZA EL data-answer TAMBIÉN ---
    card.dataset.answer = data.backText;
        // Reasignar el audio CORRECTO según el nombre del país
        const src = getAudioSrcForCountryName(data.backText);
        if (src) {
            try { audios[index].pause(); } catch {}
            audios[index].currentTime = 0;
            audios[index].preload = 'none';
            audios[index].src = src;
        } else {
            // Si no hay audio mapeado, limpiar para evitar desincronización
            try { audios[index].pause(); } catch {}
            audios[index].currentTime = 0;
            audios[index].src = '';
        }
});

    // 6. Actualizar el estado para reflejar el nuevo orden.
    setTimeout(() => {
        // Las tarjetas completadas ahora están al final del mazo.
        // Sus nuevos índices van desde `remainingCardData.length` hasta el final.
        const newCompletedCards = new Set();
        for (let i = 0; i < completedCardData.length; i++) {
            newCompletedCards.add(remainingCardData.length + i);
        }
        
        completedCards = newCompletedCards; // Reemplazar el set antiguo por el nuevo.
        // Empezar desde la primera PENDIENTE real
        currentCardIndex = 0;
        for (let i = 0; i < flashcards.length; i++) {
            if (!completedCards.has(i)) { currentCardIndex = i; break; }
        }
        
        showCard(currentCardIndex);
        updateCounters(); // Actualizar los contadores en la UI sin reiniciarlos.
    }, 10);
    voiceAttempts = 0;
canFlipBack = true;
}

function getCountryText(backElement) {
    // Clonamos el nodo para no modificar el original
    const clone = backElement.cloneNode(true);
    // Buscamos y eliminamos el contador de intentos si existe
    const attemptsDiv = clone.querySelector('.intentos-back');
    if (attemptsDiv) {
        attemptsDiv.remove();
    }
    // Devolvemos el texto limpio
    return clone.textContent.trim();
}

function attachFlashcardHandlers() {
    flashcards.forEach((card) => {
        // Guardar la respuesta correcta original en un atributo data-answer SOLO una vez
        if (!card.dataset.answer) {
            const back = card.querySelector('.back');
            card.dataset.answer = back.textContent.trim();
        }

        card.addEventListener('click', () => {
            console.log(`Click en tarjeta. canFlip: ${canFlip}, voiceAttempts: ${voiceAttempts}, flipped: ${card.classList.contains('flipped')}`);
            if (!canFlip) {
                console.log('Volteo bloqueado por canFlip');
                // Opcional: Agregar feedback visual cuando no se puede voltear
                card.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    card.style.transform = '';
                }, 150);
                return; // No permitir voltear si canFlip es false
            }
            
            vibrar(80); 
            const backElement = card.querySelector('.back');
            if (card.classList.contains('flipped')) {
                card.classList.remove('flipped');
                stopAllAudios();
                // Limpia cualquier contador de intentos al volver a front
                backElement.querySelectorAll('.intentos-back').forEach(el => el.remove());
                // Eliminar indicador de escucha al volver al frente
                removeListeningIndicator(backElement);
                setBackAttempts(backElement, 2 - voiceAttempts);
                // NO detengas ni reinicies el reconocimiento de voz aquí
                betweenAttempts = false;
                updateSkipButtonState();
            } else {
                // Volteo de front a back: SIEMPRE permitir voltear para mostrar indicador
                console.log(`Volteando a back con voiceAttempts: ${voiceAttempts}`);
                card.classList.add('flipped');
                
                // Preparar back: restaurar contenido, limpiar residuos y mostrar intentos
                if (card.dataset.answer) {
                    backElement.innerHTML = card.dataset.answer;
                }
                backElement.querySelectorAll('.listening-indicator, .mensaje-error').forEach(el => el.remove());
                backElement.classList.remove('hidden-text');
                setBackAttempts(backElement, 2 - voiceAttempts);
                
                // Mostrar SIEMPRE el indicador al voltear a back
                console.log(`Mostrando indicador para voiceAttempts: ${voiceAttempts}`);
                showListeningIndicator(backElement);
                
                // Solo iniciar reconocimiento si quedan intentos
                if (voiceAttempts < 2) {
                    // Pequeño delay para permitir pintar el indicador y luego ocultar el texto
                    const correctWord = card.dataset.answer;
                    setTimeout(() => {
                        backElement.classList.add('hidden-text');
                        if (!isRecording) {
                            startVoiceRecognition(correctWord, backElement);
                        }
                    }, 150);
                } else {
                    // No quedan intentos - mostrar respuesta directamente
                    console.log(`Sin intentos restantes (${voiceAttempts}), mostrando respuesta directamente`);
                    // Eliminar indicador cuando aparece la respuesta directa
                    removeListeningIndicator(backElement);

                    // ANTI-TRUCO (refuerzo): marcar como completada al mostrar respuesta directa
                    if (!completedCards.has(currentCardIndex)) {
                        completedCards.add(currentCardIndex);
                        updateCardCounter();
                        saveGameProgress();
                    }
                    
                    // Mostrar la respuesta correcta con efecto de brillo
                    const respuestaCorrecta = document.createElement('div');
                    respuestaCorrecta.textContent = card.dataset.answer;
                    respuestaCorrecta.style.animation = 'respuestaGlow 1.5s infinite';
                    respuestaCorrecta.style.marginTop = '40px';
                    backElement.appendChild(respuestaCorrecta);
                    
                    // Reproducir audio si existe y después mostrar countdown
                    const audioIndex = flashcards.indexOf(card);
                        if (hasValidAudio(audioIndex)) {
                            stopAllAudios();
                            audios[audioIndex].play().catch(() => {});
                            audios[audioIndex].addEventListener('ended', () => showCountdown(card), { once: true });
                        } else {
                            showCountdown(card);
                        }
                }
                // En back, por defecto el botón No sé queda deshabilitado (salvo ventana entre intentos)
                updateSkipButtonState();
            }
        });
    });
}

// Anclar manejadores de tarjetas al cargar
attachFlashcardHandlers();
window.addEventListener('DOMContentLoaded', () => {
    // Guardar HTML original del tablero de tarjetas por si luego se reemplaza
    const container = document.getElementById('flashcard-container');
    if (container && !originalFlashcardsHTML) {
        originalFlashcardsHTML = container.innerHTML;
    }
    
    // VERIFICAR SI HAY PROGRESO GUARDADO ANTES DE INICIALIZAR
    if (hasProgressSaved()) {
        // Asegurar que el "avance anterior" se pinte desde localStorage aunque mostremos el modal
        updateLastGamePillFromStorage();
        // Mostrar modal de continuación si hay progreso
        setTimeout(() => {
            showContinueGameModal();
        }, 500); // Pequeño delay para que la página termine de cargar
        return; // No ejecutar el resto de la inicialización
    }
    
    // Si no hay progreso guardado, continuar con la inicialización normal
    initializePage();
});

// Función para inicializar la página cuando no hay progreso guardado
function initializePage() {
    // Cargar último porcentaje de aciertos desde localStorage
    const savedPercentage = localStorage.getItem('lastSuccessPercentage');
    const porcentajeDiv = document.getElementById('porcentaje-guardado');
    const porcentajeSpan = document.getElementById('current-percentage');
    
    if (porcentajeDiv && porcentajeSpan) {
        const percentage = savedPercentage !== null ? parseInt(savedPercentage) : NaN;
        porcentajeSpan.textContent = `${!isNaN(percentage) ? percentage : 0}%`;
        // Fondo transparente como el cuadro; estilo neutro si 0 o no hay datos
        porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
        if (!isNaN(percentage) && percentage > 0) {
            if (percentage >= 80) {
                porcentajeDiv.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
            } else if (percentage >= 60) {
                porcentajeDiv.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
            } else {
                porcentajeDiv.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
            }
        } else {
            porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            porcentajeDiv.style.boxShadow = 'none';
        }
    }
    
    // Pintar el porcentaje del último partido (avance anterior)
    updateLastGamePillFromStorage();
    
    // Mezclar tarjetas automáticamente al cargar la página
    shuffleCards();
    
    // Asegurar mapeo audio→tarjeta tras mezcla inicial
    reassignAudiosToCards();

    showCard(currentCardIndex);
    updateCounters();
    // Precargar audio correcto para la tarjeta visible tras primera mezcla
    const firstBack = document.querySelector('.flashcard.is-visible .back');
    const visibleAnswer = firstBack ? firstBack.textContent.trim() : null;
    const visibleSrc = visibleAnswer ? getAudioSrcForCountryName(visibleAnswer) : null;
    if (visibleSrc && audios[currentCardIndex]) {
        try { audios[currentCardIndex].pause(); } catch {}
        audios[currentCardIndex].currentTime = 0;
        audios[currentCardIndex].preload = 'auto';
        audios[currentCardIndex].src = visibleSrc;
        audios[currentCardIndex].load();
    }
    // Mostrar hints secuenciales al cargar
    showPillHints();
}

// Helper: pintar el "avance anterior" desde localStorage en su pill
function updateLastGamePillFromStorage() {
    const lastGamePercentage = localStorage.getItem('paises1');
    const lastGameDiv = document.getElementById('last-game-percentage');
    const lastGamePill = document.getElementById('last-game-pill');
    if (lastGamePercentage !== null && lastGameDiv && lastGamePill) {
        const gamePercentage = parseInt(lastGamePercentage);
        lastGameDiv.textContent = `${isNaN(gamePercentage) ? 0 : gamePercentage}%`;
        // Estilo visual del pill según nivel
        lastGamePill.style.background = 'rgba(255,255,255,0.08)';
        if (!isNaN(gamePercentage)) {
            if (gamePercentage >= 80) {
                lastGamePill.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                lastGamePill.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
            } else if (gamePercentage >= 60) {
                lastGamePill.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
            } else {
                lastGamePill.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
            }
        } else {
            lastGamePill.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            lastGamePill.style.boxShadow = 'none';
        }
    }
}

// Reasignar audios a tarjetas según el texto del reverso (data-answer)
function reassignAudiosToCards() {
    try {
        flashcards.forEach((card, index) => {
            const answer = card.dataset.answer || (card.querySelector('.back')?.textContent?.trim() || '');
            const src = getAudioSrcForCountryName(answer);
            if (src) {
                try { audios[index].pause(); } catch {}
                audios[index].currentTime = 0;
                audios[index].preload = 'none';
                audios[index].src = src;
            } else {
                try { audios[index].pause(); } catch {}
                audios[index].currentTime = 0;
                audios[index].src = '';
            }
        });
    } catch (e) {
        console.warn('No se pudo reasignar audios:', e);
    }
}

function updateCardCounter() {
    const pillFaltan = document.querySelector('.pill-faltan');
    const totalCardsElem = document.getElementById('total-cards');
    const prevValue = Number(pillFaltan.getAttribute('data-prev') || 0);

    const remaining = flashcards.length - completedCards.size;
    totalCardsElem.textContent = remaining;

    if (remaining !== prevValue) {
        pillFaltan.classList.remove('glow-faltan');
        void pillFaltan.offsetWidth; // Reinicia animación
        pillFaltan.classList.add('glow-faltan');
    }
    pillFaltan.setAttribute('data-prev', remaining);
    
    // Calcular y mostrar porcentaje de aciertos
    updateSuccessPercentage();
}

function updateSuccessPercentage() {
    const totalCards = flashcards.length;
    const percentage = totalCards > 0 ? Math.round((correctCount / totalCards) * 100) : 0;

    // Actualizar elemento visual inmediato (la visibilidad la controla el scheduler)
    const porcentajeDiv = document.getElementById('porcentaje-guardado');
    const porcentajeSpan = document.getElementById('current-percentage');
    if (porcentajeDiv && porcentajeSpan) {
        porcentajeSpan.textContent = `${percentage}%`;
        porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
        if (totalCards > 0) {
            if (percentage >= 80) {
                porcentajeDiv.style.borderColor = 'rgba(0, 200, 81, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
            } else if (percentage >= 60) {
                porcentajeDiv.style.borderColor = 'rgba(255, 215, 0, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
            } else {
                porcentajeDiv.style.borderColor = 'rgba(255, 53, 71, 0.6)';
                porcentajeDiv.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
            }
        } else {
            porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            porcentajeDiv.style.boxShadow = 'none';
        }
    }

    // Guardar en localStorage
    localStorage.setItem('lastSuccessPercentage', percentage.toString());
    localStorage.setItem('lastUpdateDate', new Date().toISOString());
}

function saveLastGamePercentage() {
    const totalCards = flashcards.length;
    const gamePercentage = totalCards > 0 ? Math.round((correctCount / totalCards) * 100) : 0;
    
    // Guardar porcentaje del último partido jugado
    localStorage.setItem('paises1', gamePercentage.toString());
    localStorage.setItem('paises1Date', new Date().toISOString());
    
    // Actualizar display inmediatamente
    const lastGameDiv = document.getElementById('last-game-percentage');
    const lastGamePill = document.getElementById('last-game-pill');
    
    if (lastGameDiv && lastGamePill) {
        lastGameDiv.textContent = `${gamePercentage}%`;
        
        // Cambiar color según el porcentaje del último partido
        // Fondo transparente como el cuadro; solo resaltar borde según nivel
        lastGamePill.style.background = 'rgba(255,255,255,0.08)';
        if (gamePercentage >= 80) {
            lastGamePill.style.borderColor = 'rgba(0, 200, 81, 0.6)';
            lastGamePill.style.boxShadow = '0 4px 12px rgba(0, 200, 81, 0.25)';
        } else if (gamePercentage >= 60) {
            lastGamePill.style.borderColor = 'rgba(255, 215, 0, 0.6)';
            lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.25)';
        } else {
            lastGamePill.style.borderColor = 'rgba(255, 53, 71, 0.6)';
            lastGamePill.style.boxShadow = '0 4px 12px rgba(255, 53, 71, 0.25)';
        }
    }
    
    console.log(`Partido terminado con ${gamePercentage}% de aciertos`);
}

window.addEventListener('load', () => {
    document.getElementById('soundResetButton').play().catch(e => console.log(e));
});

function stopAllAudios() {
    audios.forEach(audio => {
        audio.pause();
        audio.currentTime = 0;
    });
}

// Muestra frases (hints) cerca de los pills al cargar la página
function showPillHints() {
    const lastGamePill = document.getElementById('last-game-pill');
    const currentPill = document.getElementById('porcentaje-guardado');
    const statsBox = document.getElementById('stats-box');
    if (!lastGamePill || !currentPill) return;

    // Helper para crear y mostrar un hint sobre un objetivo
    function createHint(target, text, delayMs = 0, onRemoved = null) {
        const hint = document.createElement('div');
        hint.className = 'pill-hint';
        hint.textContent = text;
        // Configurar animación de tipeo según longitud
        const chars = Math.max(8, text.length);
        hint.style.setProperty('--chars', chars);
        const typeDur = Math.min(1800, 60 * chars);
        hint.style.setProperty('--type-dur', `${typeDur}ms`);
        hint.style.setProperty('--delay', `${delayMs}ms`);
        // Mantener visible SOLO 4s en total (tipeo + lectura)
        // Si el tipeo tarda X ms, mantenemos (4000 - X) ms extra antes de iniciar el fade
        const holdAfterTyping = Math.max(0, 4000 - typeDur);
        const fadeDelay = delayMs + typeDur + holdAfterTyping;
        hint.style.setProperty('--fade-delay', `${fadeDelay}ms`);
        target.appendChild(hint);
        // Remover al terminar el fade
        setTimeout(() => {
            hint.remove();
            if (typeof onRemoved === 'function') onRemoved();
        }, fadeDelay + 600);
    }

    // Secuencia: primero el inferior; cuando se elimina, mostramos el superior
    const bottomText = 'Avance anterior';
    const topText = 'Avance actual';
    const bottomDelay = 200; // inicio del inferior

    createHint(lastGamePill, bottomText, bottomDelay, () => {
        // pequeño gap tras eliminar el inferior
        setTimeout(() => {
            // Crear el superior y, al eliminarse, programar esconder el cuadro 3s después
            createHint(currentPill, topText, 0, () => {
                if (statsBox) {
                    setTimeout(() => {
                        statsBox.classList.add('hidden');
                    }, 3000); // 3 segundos después de desaparecer el hint superior
                }
            });
        }, 150);
    });
}

function resetGame() {
    // Si el tablero fue reemplazado por una pantalla final, restaurarlo
    reinitFlashcardsDOMIfMissing();
    
    // Solo guardar el avance si hay un juego completado (no al reiniciar desde 0)
    const totalAttempts = correctCount + incorrectCount;
    if (totalAttempts > 0) {
        saveLastGamePercentage();
    }
    
    // LIMPIAR PROGRESO GUARDADO al reiniciar
    clearCurrentProgress();
    
    // Limpiar timeouts de stats box si estuvieran activos
    if (statsShowTimeoutId) { clearTimeout(statsShowTimeoutId); statsShowTimeoutId = null; }
    if (statsHideTimeoutId) { clearTimeout(statsHideTimeoutId); statsHideTimeoutId = null; }
    if (percentageUpdateTimeoutId) { clearTimeout(percentageUpdateTimeoutId); percentageUpdateTimeoutId = null; }
    
    // Resetear todas las variables del juego
    currentCardIndex = 0;
    voiceAttempts = 0;
    completedCards.clear();
    correctWords.length = 0;
    incorrectWords.length = 0;
    correctCount = 0;
    incorrectCount = 0;
    
    // Limpiar timeouts activos
    if (typeof autoFlipTimer !== 'undefined') {
        clearTimeout(autoFlipTimer);
    }
    
    // Resetear todas las tarjetas al estado inicial
    const allCards = document.querySelectorAll('.flashcard');
    allCards.forEach(card => {
        card.classList.remove('flipped');
        
        // Limpiar indicadores de respuesta
        const backElement = card.querySelector('.back');
        if (backElement) {
            backElement.classList.remove('correct-answer', 'incorrect-answer', 'hidden-text');
            
            // Resetear intentos mostrados
            const attemptsDiv = backElement.querySelector('.attempts');
            if (attemptsDiv) {
                attemptsDiv.remove();
            }
        }
    });
    
    // Habilitar botón de mezclar
    document.getElementById('shuffle-button').disabled = false;
    
    // Limpiar cualquier modal o overlay existente
    const overlays = document.querySelectorAll('[id$="-overlay"]');
    overlays.forEach(overlay => overlay.remove());
    
    // Resetear botones de palabras correctas/incorrectas (si existen)
    const correctBtn = document.getElementById('correct-words-btn');
    const incorrectBtn = document.getElementById('incorrect-words-btn');
    if (correctBtn) correctBtn.style.display = 'none';
    if (incorrectBtn) incorrectBtn.style.display = 'none';
    
    // Resetear atributos data-prev de las píldoras
    const correctasPill = document.querySelector('.pill-correctas');
    const incorrectasPill = document.querySelector('.pill-incorrectas');
    if (correctasPill) correctasPill.setAttribute('data-prev', '0');
    if (incorrectasPill) incorrectasPill.setAttribute('data-prev', '0');
    
    // Actualizar porcentaje actual (pero NO el "avance anterior" que ya se guardó)
    const totalCards = flashcards.length;
    const percentage = 0; // Siempre 0 al reiniciar
    const porcentajeDiv = document.getElementById('porcentaje-guardado');
    const porcentajeSpan = document.getElementById('current-percentage');
    if (porcentajeDiv && porcentajeSpan) {
        porcentajeSpan.textContent = `${percentage}%`;
        porcentajeDiv.style.background = 'rgba(255,255,255,0.08)';
        porcentajeDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';
        porcentajeDiv.style.boxShadow = 'none';
    }
    
    // Mezclar tarjetas sin sonido (el sonido es solo para el botón mezclar)
    shuffleCards();
    
    // Actualizar contadores
    updateCounters();
    updateCardCounter();
    
    // Mostrar la primera tarjeta
    showCard(0);
}

// Restaura el DOM de tarjetas si fue reemplazado por pantallas de fin de juego
function reinitFlashcardsDOMIfMissing() {
    const container = document.getElementById('flashcard-container');
    if (!container) return;
    const hasCards = container.querySelectorAll('.flashcard').length > 0;
    if (!hasCards && originalFlashcardsHTML) {
        container.innerHTML = originalFlashcardsHTML;
        // Volver a poblar el arreglo global (const) sin reasignar
        const newCards = Array.from(container.querySelectorAll('.flashcard'));
        flashcards.length = 0;
        newCards.forEach(c => flashcards.push(c));
        // Reanclar manejadores de clic
        attachFlashcardHandlers();
    }
}

document.getElementById('reset-button').addEventListener('click', () => {
    vibrar(80);
    const soundResetButton = document.getElementById('soundResetButton');
    soundResetButton.play().catch(e => console.log(e));

    const overlaysPresent = (
        document.getElementById('euforia-maxima-overlay') ||
        document.getElementById('euforia-overlay') ||
        document.getElementById('perdida-overlay') ||
        document.getElementById('empate-overlay')
    );
    
    // Verificar si se muestra la pantalla final de showCompletionMessage
    const container = document.getElementById('flashcard-container');
    const hasCompletionScreen = container && !container.querySelector('.flashcard');
    
    // Calcular finalización de forma robusta con el DOM actual
    const totalCardsNow = document.querySelectorAll('.flashcard').length;
    const finished = overlaysPresent || hasCompletionScreen || (totalCardsNow > 0 && completedCards.size >= totalCardsNow);
    const started = ((correctCount + incorrectCount) > 0) || (voiceAttempts > 0);

    if (!finished) {
        if (started) {
            const existing = document.getElementById('reset-guard-toast');
            if (existing) existing.remove();
            const toast = document.createElement('div');
            toast.id = 'reset-guard-toast';
            toast.innerHTML = `
                <div style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 12px;
                    font-size: 16px;
                    font-weight: 600;
                ">
                    <div style="
                        font-size: 24px;
                        filter: drop-shadow(0 0 8px rgba(255,152,0,0.6));
                    ">⏳</div>
                    <span>Finaliza el juego primero</span>
                </div>
            `;
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30,30,30,0.95) 0%, rgba(50,50,50,0.95) 100%);
                color: #fff;
                padding: 20px 28px;
                border-radius: 16px;
                font-weight: 600;
                font-size: 16px;
                letter-spacing: 0.3px;
                z-index: 10000;
                backdrop-filter: blur(12px);
                border: 1px solid rgba(255,152,0,0.3);
                box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 20px rgba(255,152,0,0.1);
                animation: modernFadeInOut 2.2s ease;
                min-width: 280px;
                text-align: center;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2200);
            return; // bloquear si empezó
        }
        // Si no ha empezado, sí podemos reiniciar y mezclar
        resetGame();
        return;
    }

    // Resetear el juego sin recargar la página (solo al finalizar)
    resetGame();
});


function setBackAttempts(backElement, attemptsLeft, mensajeExtra = "") {
    // Elimina TODOS los contadores de intentos antes de crear uno nuevo
    backElement.querySelectorAll('.intentos-back').forEach(el => el.remove());

    // Ya no mostramos ningún contador visual de intentos.
    // Si quieres mostrar un mensaje extra, puedes hacerlo aquí:
    if (mensajeExtra) {
        const extraDiv = document.createElement('div');
        extraDiv.className = 'mensaje-extra';
        extraDiv.style.marginTop = '10px';
        extraDiv.innerHTML = mensajeExtra;
        backElement.prepend(extraDiv);
    }
}

// Agregar sonido a todos los elementos clickeables excepto reiniciar y mezclar
document.addEventListener('DOMContentLoaded', function() {
    // Función para agregar sonido a elementos clickeables
    function addClickSound(element) {
        if (element && !element.hasAttribute('data-sound-added')) {
            element.addEventListener('click', function(e) {
                // Excluir botones de reiniciar y mezclar (ya tienen su propia vibración)
                if (this.id !== 'reset-button' && this.id !== 'shuffle-button') {
                    vibrar(50); // Vibración leve para elementos clickeables
                    playButtonSound();
                }
            });
            element.setAttribute('data-sound-added', 'true');
        }
    }
    
    // Agregar sonido a elementos específicos
    const clickableElements = [
        // Botones de control de bandera
        '.flag-control-btn',
        '.flag-close-btn',
        // Botones de modal
        '.modal-close-btn',
        // Tarjetas de palabras
        '.word-card',
        // Pills de estadísticas clickeables
        '.pill-correctas',
        '.pill-incorrectas',
        '.pill-progreso'
    ];
    
    clickableElements.forEach(selector => {
        document.querySelectorAll(selector).forEach(addClickSound);
    });
    
    // Observer para elementos que se crean dinámicamente
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1) { // Element node
                    // Buscar elementos clickeables en el nodo agregado
                    clickableElements.forEach(selector => {
                        if (node.matches && node.matches(selector)) {
                            addClickSound(node);
                        }
                        node.querySelectorAll && node.querySelectorAll(selector).forEach(addClickSound);
                    });
                    
                    // Manejar elementos con onclick dinámicos
                    if (node.onclick || node.getAttribute('onclick')) {
                        addClickSound(node);
                    }
                    node.querySelectorAll && node.querySelectorAll('[onclick]').forEach(addClickSound);
                }
            });
        });
    });
    
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
});

// Prevenir menú contextual (clic derecho y presión larga)
document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    e.stopPropagation();
    return false;
}, true);

// Prevenir arrastrar imágenes
document.addEventListener('dragstart', function(e) {
    if (e.target.tagName === 'IMG') {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
}, true);

// Prevenir presión larga en dispositivos móviles
document.addEventListener('touchstart', function(e) {
    if (e.target.tagName === 'IMG') {
        // Solo permitir un toque, prevenir presión larga
        setTimeout(() => {
            e.target.style.pointerEvents = 'none';
            setTimeout(() => {
                e.target.style.pointerEvents = '';
            }, 50);
        }, 10);
    }
}, {passive: false});

// Prevenir selección con teclado
document.addEventListener('keydown', function(e) {
    // Prevenir Ctrl+A, Ctrl+C, Ctrl+S, F12, etc.
    if ((e.ctrlKey || e.metaKey) && (e.key === 'a' || e.key === 'A' || 
        e.key === 'c' || e.key === 'C' || e.key === 's' || e.key === 'S')) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
    // Prevenir F12 (DevTools)
    if (e.key === 'F12') {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
}, true);

// ============ GUARDADO AUTOMÁTICO EN EVENTOS DE PÁGINA ============
// Guardar progreso cuando el usuario cambie de pestaña, minimice la ventana o cierre la página
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'hidden') {
        // Solo guardar si hay progreso actual
        const totalAttempts = correctCount + incorrectCount;
        const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;
        
        if (hasCurrentProgress) {
            saveGameProgress();
            console.log('Progreso guardado al cambiar de pestaña');
        }
    }
});

// Guardar progreso antes de que se cierre la página
window.addEventListener('beforeunload', function() {
    // Solo guardar si hay progreso actual
    const totalAttempts = correctCount + incorrectCount;
    const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;
    
    if (hasCurrentProgress) {
        saveGameProgress();
        console.log('Progreso guardado antes de cerrar página');
    }
});

// Guardar progreso periódicamente cada 30 segundos si hay actividad
let autoSaveInterval = null;

function startAutoSave() {
    if (autoSaveInterval) return; // Ya está corriendo
    
    autoSaveInterval = setInterval(() => {
        const totalAttempts = correctCount + incorrectCount;
        const hasCurrentProgress = totalAttempts > 0 || completedCards.size > 0 || voiceAttempts > 0;
        
        if (hasCurrentProgress) {
            saveGameProgress();
            console.log('Guardado automático periódico');
        }
    }, 30000); // Cada 30 segundos
}

function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

// Iniciar guardado automático cuando el usuario comience a jugar
document.addEventListener('DOMContentLoaded', function() {
    // Esperar un poco antes de iniciar el auto-guardado
    setTimeout(() => {
        startAutoSave();
    }, 5000); // Empezar después de 5 segundos
    
    // Inicializar sistema de conectividad
    initConnectivityMonitor();
});

// === SISTEMA DE MONITOREO DE CONECTIVIDAD ===
let connectivityCheckInterval = null;
let isConnectivityOverlayVisible = false;
let connectivityCheckInProgress = false;
let lastConnectionStatus = true;

// Inicializar el monitor de conectividad
function initConnectivityMonitor() {
    console.log('🌐 Iniciando monitor de conectividad...');
    
    // Verificar conexión inicial
    setTimeout(() => {
        checkInternetConnection();
    }, 2000);
    
    // Escuchar eventos de online/offline del navegador
    window.addEventListener('online', handleOnlineEvent);
    window.addEventListener('offline', handleOfflineEvent);
    
    // Configurar el botón de reintentar
    const retryBtn = document.getElementById('connectivity-retry-btn');
    if (retryBtn) {
        retryBtn.addEventListener('click', handleRetryConnection);
    }
    
    // Iniciar verificación periódica cada 10 segundos
    startPeriodicConnectivityCheck();
}

// Manejar evento de conexión online
function handleOnlineEvent() {
    console.log('🟢 Evento online detectado');
    setTimeout(() => {
        checkInternetConnection();
    }, 1000); // Dar tiempo para que la conexión se estabilice
}

// Manejar evento de desconexión offline
function handleOfflineEvent() {
    console.log('🔴 Evento offline detectado');
    updateConnectivityStatus(false, 'Sin conexión a Internet');
}

// Verificar conectividad real haciendo fetch a recursos externos
async function checkInternetConnection() {
    if (connectivityCheckInProgress) return;
    
    connectivityCheckInProgress = true;
    updateConnectivityStatusText('Verificando conexión...');
    
    console.log('🔍 Verificando conectividad real...');
    
    const testUrls = [
        'https://www.google.com/favicon.ico',
        'https://httpbin.org/status/200',
        'https://jsonplaceholder.typicode.com/posts/1',
        'https://api.github.com'
    ];
    
    let connectionSuccessful = false;
    
    for (const url of testUrls) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 segundos timeout
            
            const response = await fetch(url, {
                method: 'HEAD',
                mode: 'no-cors',
                cache: 'no-cache',
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            console.log(`✅ Conexión exitosa a: ${url}`);
            connectionSuccessful = true;
            break;
            
        } catch (error) {
            console.log(`❌ Fallo al conectar a: ${url}`, error.message);
            continue;
        }
    }
    
    // Si todas las pruebas fallan, intentar con navigator.onLine como respaldo
    if (!connectionSuccessful && navigator.onLine) {
        try {
            // Prueba simple con fetch a la misma página
            const response = await fetch(window.location.href, {
                method: 'HEAD',
                cache: 'no-cache'
            });
            
            if (response.ok) {
                connectionSuccessful = true;
                console.log('✅ Conectividad confirmada con fetch local');
            }
        } catch (error) {
            console.log('❌ Fallo en fetch local:', error.message);
        }
    }
    
    const statusMessage = connectionSuccessful ? 
        'Conexión estable' : 
        'Sin conexión o muy lenta';
        
    updateConnectivityStatus(connectionSuccessful, statusMessage);
    connectivityCheckInProgress = false;
}

// Actualizar el estado de conectividad
function updateConnectivityStatus(isConnected, message = '') {
    lastConnectionStatus = isConnected;
    
    console.log(`📊 Estado de conectividad: ${isConnected ? 'CONECTADO' : 'DESCONECTADO'} - ${message}`);
    
    if (isConnected) {
        hideConnectivityOverlay();
    } else {
        showConnectivityOverlay(message);
    }
}

// Mostrar overlay de conectividad
function showConnectivityOverlay(message = 'Sin conexión a Internet') {
    if (isConnectivityOverlayVisible) return;
    
    console.log('🚫 Mostrando overlay de conectividad');
    
    const overlay = document.getElementById('connectivity-overlay');
    const statusText = document.getElementById('connectivity-status-text');
    const retryBtn = document.getElementById('connectivity-retry-btn');
    
    if (overlay) {
        // Actualizar mensaje
        updateConnectivityStatusText(message);
        
        // Mostrar overlay
        overlay.classList.remove('reconnected');
        overlay.classList.add('show');
        isConnectivityOverlayVisible = true;
        
        // Desabilitar interacciones con el juego
        disableGameInteractions();
        
        // Reset del botón de retry
        if (retryBtn) {
            retryBtn.classList.remove('checking');
        }
    }
}

// Ocultar overlay de conectividad
function hideConnectivityOverlay() {
    if (!isConnectivityOverlayVisible) return;
    
    console.log('✅ Ocultando overlay de conectividad');
    
    const overlay = document.getElementById('connectivity-overlay');
    const retryBtn = document.getElementById('connectivity-retry-btn');
    
    if (overlay) {
        // Mostrar efecto de reconexión exitosa
        overlay.classList.add('reconnected');
        
        // Actualizar contenido para reconexión
        updateConnectivityContent(true);
        
        // Ocultar después de mostrar el éxito
        setTimeout(() => {
            overlay.classList.remove('show', 'reconnected');
            isConnectivityOverlayVisible = false;
            
            // Reabilitar interacciones con el juego
            enableGameInteractions();
            
            // Reset del contenido del overlay
            setTimeout(() => {
                updateConnectivityContent(false);
            }, 500);
            
        }, 2500); // Mostrar éxito por 2.5 segundos
        
        // Reset del botón
        if (retryBtn) {
            retryBtn.classList.remove('checking');
        }
    }
}

// Actualizar contenido del overlay
function updateConnectivityContent(isReconnected) {
    const icon = document.querySelector('.connectivity-icon');
    const title = document.querySelector('.connectivity-title');
    const message = document.querySelector('.connectivity-message');
    
    if (isReconnected) {
        if (icon) icon.textContent = '✅';
        if (title) title.textContent = '¡Reconectado!';
        if (message) message.innerHTML = 'Tu conexión ha sido restablecida.<br>Ya puedes continuar jugando.';
        updateConnectivityStatusText('Conexión restablecida');
    } else {
        if (icon) icon.textContent = '📡';
        if (title) title.textContent = 'Sin Conexión';
        if (message) message.innerHTML = 'Parece que tu conexión a Internet es débil o se ha perdido.<br>Esta aplicación necesita conexión para funcionar correctamente.';
    }
}

// Actualizar texto de estado
function updateConnectivityStatusText(text) {
    const statusText = document.getElementById('connectivity-status-text');
    if (statusText) {
        statusText.textContent = text;
    }
}

// Manejar clic en botón de reintentar
async function handleRetryConnection() {
    const retryBtn = document.getElementById('connectivity-retry-btn');
    
    if (retryBtn) {
        retryBtn.classList.add('checking');
        retryBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Verificando...</span>';
    }
    
    updateConnectivityStatusText('Reintentando conexión...');
    
    // Esperar un poco antes de verificar
    setTimeout(async () => {
        await checkInternetConnection();
        
        // Restaurar botón después de un tiempo
        setTimeout(() => {
            if (retryBtn && !lastConnectionStatus) {
                retryBtn.classList.remove('checking');
                retryBtn.innerHTML = '<i class="fas fa-redo"></i><span>Intentar de nuevo</span>';
            }
        }, 2000);
    }, 1500);
}

// Desabilitar interacciones del juego
function disableGameInteractions() {
    console.log('🚫 Deshabilitando interacciones del juego');
    
    // Pausar el juego si está en progreso
    if (typeof stopAutoSave === 'function') {
        stopAutoSave();
    }
    
    // Desabilitar botones principales
    const gameButtons = document.querySelectorAll('.button, .pill, .back-arrow');
    gameButtons.forEach(button => {
        button.style.pointerEvents = 'none';
        button.style.opacity = '0.5';
    });
    
    // Desabilitar flashcards
    const flashcards = document.querySelectorAll('.flashcard');
    flashcards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.7';
    });
    
    // Pausar reconocimiento de voz si está activo
    if (typeof stopListening === 'function') {
        stopListening();
    }
}

// Reabilitar interacciones del juego
function enableGameInteractions() {
    console.log('✅ Rehabilitando interacciones del juego');
    
    // Reanudar auto-guardado
    if (typeof startAutoSave === 'function') {
        startAutoSave();
    }
    
    // Rehabilitar botones
    const gameButtons = document.querySelectorAll('.button, .pill, .back-arrow');
    gameButtons.forEach(button => {
        button.style.pointerEvents = 'auto';
        button.style.opacity = '1';
    });
    
    // Rehabilitar flashcards
    const flashcards = document.querySelectorAll('.flashcard');
    flashcards.forEach(card => {
        card.style.pointerEvents = 'auto';
        card.style.opacity = '1';
    });
}

// Iniciar verificación periódica
function startPeriodicConnectivityCheck() {
    // Limpiar intervalo previo si existe
    if (connectivityCheckInterval) {
        clearInterval(connectivityCheckInterval);
    }
    
    // Verificar cada 15 segundos
    connectivityCheckInterval = setInterval(() => {
        // Solo verificar si no hay una verificación en progreso
        if (!connectivityCheckInProgress) {
            checkInternetConnection();
        }
    }, 15000);
    
    console.log('⏰ Verificación periódica de conectividad iniciada (cada 15 segundos)');
}

// Detener verificación periódica
function stopPeriodicConnectivityCheck() {
    if (connectivityCheckInterval) {
        clearInterval(connectivityCheckInterval);
        connectivityCheckInterval = null;
        console.log('⏹️ Verificación periódica de conectividad detenida');
    }
}

// Limpiar al salir de la página
window.addEventListener('beforeunload', () => {
    stopPeriodicConnectivityCheck();
});

function debugGameState() {
    console.log('=== DEBUG GAME STATE ===');
    console.log('currentCardIndex:', currentCardIndex);
    console.log('Total flashcards:', flashcards.length);
    console.log('completedCards:', Array.from(completedCards));
    console.log('correctCount:', correctCount);
    console.log('incorrectCount:', incorrectCount);
    console.log('voiceAttempts:', voiceAttempts);
    console.log('========================');
}

// Modificar la función goToNextCard para añadir debug
function goToNextCardWithDebug() {
    console.log('🔄 goToNextCard called');
    debugGameState();
    
    // Reactivar el botón de mezclar al pasar a la siguiente tarjeta
    document.getElementById('shuffle-button').disabled = false;

    // REPRODUCIR SONIDO DE NAIPE al cambiar de tarjeta
    document.getElementById('shuffleSound').play().catch(() => {});

    const flashcards = Array.from(document.querySelectorAll('.flashcard'));
    console.log('📊 Flashcards encontradas:', flashcards.length);
    
    completedCards.add(currentCardIndex);
    console.log('✅ Tarjeta marcada como completada:', currentCardIndex);
    console.log('📈 Total completadas:', completedCards.size);
    
    updateCardCounter();
    
    // GUARDAR PROGRESO AUTOMÁTICAMENTE al completar una tarjeta
    saveGameProgress();
    
    canFlipBack = true;
    canFlip = true;
    updateCounters();
    voiceAttempts = 0;
    
    // Limpiar timeouts
    if (errorDelayTimeoutId) { clearTimeout(errorDelayTimeoutId); errorDelayTimeoutId = null; }
    if (resumeRecognitionTimeoutId) { clearTimeout(resumeRecognitionTimeoutId); resumeRecognitionTimeoutId = null; }
    showingErrorMessage = false;
    lockedAfterSecondIncorrect = false;
    lockedAfterCorrect = false;

    // Buscar la siguiente tarjeta pendiente
    const total = flashcards.length;
    let nextIndex = -1;
    console.log('🔍 Buscando siguiente tarjeta...');
    
    for (let step = 1; step <= total; step++) {
        const i = (currentCardIndex + step) % total;
        console.log(`   Checking index ${i}, completed: ${completedCards.has(i)}`);
        if (!completedCards.has(i)) {
            nextIndex = i;
            console.log(`✨ Found next card at index: ${nextIndex}`);
            break;
        }
    }
    
    if (nextIndex !== -1) {
        console.log('➡️ Moving to next card:', nextIndex);
        currentCardIndex = nextIndex;
        showCard(currentCardIndex);
    } else {
        console.log('🏁 No more cards - showing completion');
        // Resto del código de finalización...
        saveLastGamePercentage();
        
        if (correctCount > incorrectCount) {
            if (incorrectCount === 0) {
                showCompletionEuforiaMaxima();
            } else {
                showCompletioneuforia();
            }
        } else if (incorrectCount > correctCount) {
            showCompletionPerdida();
        } else {
            showCompletionEmpate();
        }
    }
    
    console.log('🔄 goToNextCard finished');
}
    </script>
    
    
</body>
</html>
