<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Visor PDF Profesional</title>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
	<!-- jsPDF para generar un PDF de una sola página desde canvas -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
		
		body {
			font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			background: #ffffff; /* Fondo unificado para evitar salto visual */
			margin: 0;
			padding: 0;
			overflow: hidden;
			position: relative;
			touch-action: none;
			user-select: none;
		}
		
		.pdf-viewer-container {
			width: 100vw;
			height: 100vh;
			display: flex;
			align-items: center;
			justify-content: center;
			position: relative;
			overflow: hidden;
			background: #ffffff; /* Igual que body y canvas */
			perspective: 1600px;
		}
		
		.side-arrow {
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
			z-index: 5000; /* elevado para estar encima de la imagen de ejercicio (2400) y debajo del menú (4000) -> ahora encima de ambos */
			width: 60px;
			height: 60px;
			border-radius: 50%;
			background: rgba(0,0,0,0.5);
			color: #fff;
			border: none;
			font-size: 2.5rem;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			transition: background 0.2s, transform 0.2s;
			box-shadow: 0 4px 16px rgba(0,0,0,0.2);
			opacity: 0.8;
		}
		/* Variante más clara para flecha izquierda en modo ejercicio (pedida) */
		.side-arrow.exercise-left-active {
			/* Fondo sólido (no transparente) en tono más claro que el botón negro base */
			background: linear-gradient(135deg, #646464 0%, #4a4a4a 100%);
			color: #fff;
			box-shadow: 0 6px 20px rgba(0,0,0,0.45);
		}
		.side-arrow.exercise-left-active:hover {
			background: linear-gradient(135deg, #6f6f6f 0%, #535353 100%);
		}
		/* Variante clara para flecha derecha en modo ejercicio (simetría solicitada) */
		.side-arrow.exercise-right-active {
			background: linear-gradient(135deg, #646464 0%, #4a4a4a 100%);
			color: #fff;
			box-shadow: 0 6px 20px rgba(0,0,0,0.45);
		}
		.side-arrow.exercise-right-active:hover {
			background: linear-gradient(135deg, #6f6f6f 0%, #535353 100%);
		}
		
		.side-arrow:hover {
			background: rgba(0,0,0,0.8);
			transform: translateY(-50%) scale(1.1);
			opacity: 1;
		}
		
		.left-arrow { left: 10px; }
		.right-arrow { right: 10px; }
		
		.page-counter {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.6);
			color: white;
			padding: 8px 16px;
			border-radius: 20px;
			font-size: 14px;
			font-weight: 500;
			z-index: 1000;
			backdrop-filter: blur(10px);
			transition: all 0.3s ease;
		}

		/* Top bar compacta y moderna */
		.top-bar {
			background: linear-gradient(135deg, #434343 0%, #000000 100%);
			padding: 10px 14px;
			border-radius: 0 0 20px 20px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			box-shadow: 0 4px 20px rgba(0,0,0,0.6);
			width: min(940px, calc(100% - 12px));
			margin: 0 auto;
		}

		/* Botón flotante para mostrar/ocultar menú (hamburguesa morada) */
		.menu-toggle-btn {
			position: fixed;
			top: calc(env(safe-area-inset-top, 0px) + 10px);
			left: 0;
			width: clamp(28px, 6vw, 38px);
			height: clamp(44px, 10vw, 54px);
			border-radius: 8px; /* bordes más reducidos */
			background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
			color: #fff;
			border: none;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			z-index: 4000;
			cursor: pointer;
			box-shadow: 0 10px 26px rgba(109,40,217,0.5);
			transition: transform 160ms ease, box-shadow 200ms ease, filter 160ms ease;
		}
		.menu-toggle-btn:hover { transform: translateY(-1px); box-shadow: 0 14px 30px rgba(109,40,217,0.6); }
		.menu-toggle-btn:active { transform: translateY(0); box-shadow: inset 0 2px 8px rgba(0,0,0,0.45), 0 6px 14px rgba(0,0,0,0.3); }
		.menu-toggle-btn svg { width: 62%; height: 62%; }
		.bar-group {
			display: flex;
			align-items: center;
			gap: 10px;
		}
		.label-chip {
			color: #fff;
			font-weight: 700;
			font-size: 16px;
			margin: 0 6px 0 2px;
		}

		/* Botones compactos con estilo moderno (SVG, neumorfismo ligero) */
		.round-icon-btn {
			width: 40px;
			height: 40px;
			border: 1px solid rgba(255,255,255,0.08);
			border-radius: 14px;
			background: linear-gradient(180deg, #505050 0%, #3a3a3a 100%);
			color: #fff;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			box-shadow: 0 6px 18px rgba(0,0,0,0.45), inset 0 0 0 rgba(255,255,255,0);
			transition: transform 120ms ease, box-shadow 180ms ease, filter 120ms ease;
		}
		.round-icon-btn svg { width: 60%; height: 60%; color: #fff; }
		.round-icon-btn:hover { transform: translateY(-1px); box-shadow: 0 10px 24px rgba(0,0,0,0.5); }
		.round-icon-btn:active { transform: translateY(0); box-shadow: inset 0 2px 8px rgba(0,0,0,0.45), 0 4px 10px rgba(0,0,0,0.3); }

		/* Variante primaria (descargar) en azul moderno */
		#download-page-btn.round-icon-btn {
			background: linear-gradient(180deg, #4c8bf5 0%, #1a73e8 100%);
			box-shadow: 0 8px 22px rgba(26,115,232,0.55), inset 0 0 0 rgba(255,255,255,0);
		}
		#download-page-btn.round-icon-btn:hover { box-shadow: 0 12px 28px rgba(26,115,232,0.6); }

		
		#pdf-canvas {
			width: 100vw !important;
			border: none;
			/* Mantener espacio desde el principio para evitar reflow y usar fade */
			opacity: 0;
			background: #ffffff;
			object-fit: contain;
			position: absolute;
			top: 0;
			left: 50%;
			transform: translateX(-50%);
			transition: opacity 70ms ease-out;
		}

		/* Imagen del ejercicio: cubrir completamente la ventana sin barras negras */
		#exercise-img {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			width: 100vw;     /* ajustar siempre al ancho */
			height: auto;     /* altura se ajusta proporcionalmente */
			max-height: 100vh; /* evitar desbordes verticales */
			display: none;
			z-index: 2400;
			opacity: 0;
			background: transparent;
		}
		
		.loading {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: white;
			font-size: 18px;
			font-weight: 500;
			display: none; /* Oculto por defecto para evitar parpadeo inicial */
		}
		
		/* En móviles: la imagen debe ocupar todo el alto y ajustar el ancho proporcionalmente */
		@media (max-width: 768px) {
			#exercise-img {
				top: 0;
				left: 50%;
				transform: translateX(-50%);
				width: auto;    /* el ancho depende de la pantalla */
				height: 100vh;  /* ocupa todo el alto */
				max-width: 100vw; /* evitar desbordes horizontales */
				max-height: none; /* ya fijamos altura */
			}
			
			/* Eliminadas reglas que ocultaban el canvas para reducir parpadeo */
		}

		/* Estilos para los botones del menú superior */
		/* Botón 'Ir' de ejercicio en azul marino y sin animación */
		#show-exercise-btn {
			transition: none !important;
			background: linear-gradient(135deg, #0b3d91 0%, #062a6e 100%) !important;
			color: #fff !important;
		}
		#show-exercise-btn:hover {
			background: linear-gradient(135deg, #0b3d91 0%, #062a6e 100%) !important; /* mismo aspecto en hover */
			transform: none !important; /* sin desplazamiento al hacer hover */
			box-shadow: none !important;
			filter: none !important;
		}

		/* Botón 'Ir' de página en rojo vivo */
		#goto-page-btn {
			background: linear-gradient(135deg, #ff4d4d 0%, #ff1a1a 100%) !important;
			color: #fff !important;
		}
		#goto-page-btn:hover {
			background: linear-gradient(135deg, #ff4d4d 0%, #ff1a1a 100%) !important;
			box-shadow: none !important;
			filter: none !important;
		}
		
		#show-all-btn:hover {
			background: linear-gradient(135deg, #555 0%, #333 100%) !important;
			transform: translateY(-2px);
			box-shadow: 0 6px 20px rgba(102,102,102,0.6) !important;
		}
		
		@media (max-width: 480px) {
			.side-arrow {
				display: none; /* Ocultar flechas en móvil - usar gestos */
			}
		}

		/* Indicadores visuales para gestos de swipe en móvil */
		.swipe-indicator {
			position: fixed;
			top: 50%;
			transform: translateY(-50%);
			width: 6px;
			height: 120px;
			background: rgba(255, 255, 255, 0.4);
			border-radius: 3px;
			opacity: 0;
			transition: opacity 0.2s ease;
			z-index: 1000;
			pointer-events: none;
		}
		.swipe-indicator.left { left: 3px; }
		.swipe-indicator.right { right: 3px; }
		.swipe-indicator.active { opacity: 0.8; }

		/* Inputs: el contenedor se convierte en la “caja” blanca */
.input-with-icon {
	position: relative;
	display: inline-flex;
	align-items: center;
	background: #fff;                 /* la caja blanca ahora es el wrapper */
	border-radius: 12px;
	padding: 0 3px 0 0;               /* 0 a la izquierda para permitir 1px exacto del prefijo */
	box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
}

/* Mantener el prefijo E/P igual que antes */
.input-with-icon.with-prefix::before {
  content: attr(data-prefix);
  position: absolute;
	left: 4px;                        /* más espacio a la izquierda del prefijo */
  top: 50%;
  transform: translateY(-50%);
  font-weight: 800;
  font-size: clamp(12px, 3.4vw, 14px);
  color: #222;
  pointer-events: none;
  opacity: 0.9;
  letter-spacing: 0;
}
.input-with-icon.with-prefix[data-prefix="P"]::before { color: #e53935; }
/* Letra del ejercicio (E) en azul marino */
.prefix-e::before { color: #0b3d91 !important; }

/* El input ahora es transparente dentro de la caja blanca */
.control-input {
  width: clamp(48px, 16vw, 80px);
  height: clamp(26px, 4.8vh, 36px);
		padding: 1px 0px;               /* menos espacio: número ↔ flechas y arriba/abajo */
  border-radius: 10px;      /* solo por compatibilidad visual */
  border: none;
  outline: none;
  font-size: clamp(11.5px, 3.4vw, 13.5px);
  font-weight: 700;
  text-align: center;
  background: transparent;  /* antes era #fff */
  box-shadow: none;         /* quitamos el inset del input */
}

/* Mantener centrado el valor con prefijo E/P */

.input-with-icon.with-prefix .control-input {
	padding-left: 5px !important;   /* -1px: reduce el espacio letra ↔ número */
	text-align: center;
}

/* Botón “Ir” embebido dentro de la misma caja blanca, a la derecha del spinner */
.input-with-icon .icon-btn {
	position: relative; /* que fluya al lado del input (después del spinner) */
	height: clamp(22px, 4.8vw, 28px);
	min-width: clamp(28px, 7vw, 36px);
	margin-left: 1px;           /* 1px de separación del spinner */
	padding: 0 6px !important;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	font-size: clamp(10.5px, 3vw, 12px);
	border: none;
	border-radius: 8px;
	cursor: pointer;
	background: linear-gradient(135deg, #666 0%, #444 100%);
	color: #fff;
}

/* Hover suave (evita cambios bruscos de posición) */
.input-with-icon .icon-btn:hover {
  filter: brightness(1.1);
  transform: none; /* sin “salto” visual dentro de la caja */
}

/* Asegurar visibilidad de las flechas (spinners) en WebKit y que no queden tapadas */
/* Compactar spinner en WebKit (más cerca del número y un pelín más bajo) */
input[type="number"]::-webkit-inner-spin-button {
	-webkit-appearance: inner-spin-button;
	opacity: 1;
	height: auto;              /* conservar visibilidad */
	margin-left: -4px;         /* acercar aún más al número */
	transform: translateX(-5px) translateY(-1px) scale(0.9); /* más cerca, ligeramente más bajo y 10% más compacto */
	transition: none;
}
input[type="number"]::-webkit-outer-spin-button {
	-webkit-appearance: inner-spin-button;
	opacity: 1;
	height: auto;
	transform: scale(0.9);
	transition: none;
}

/* La regla previa ya no es necesaria, pero no afecta si queda: 
   .input-with-icon .has-icon { padding-right: 8px !important; } */

/* Mantén los colores de números */
#exercise-input { color: #0b3d91; font-weight: 800; caret-color: #0b3d91; }
#page-input { color: #e53935; font-weight: 800; caret-color: #e53935; }
		/* Modo guiones para input de ejercicios cuando estamos en vista PDF explícita */
		#exercise-input.dashes-mode {
			color: #fff !important;
			letter-spacing: 2px;
			font-weight: 800;
			caret-color: transparent; /* no cursor sobre los guiones */
		}
		
		/* Estilo especial para mostrar el guión de placeholder */
		#exercise-input.dash-placeholder {
			color: #0b3d91 !important;
			font-weight: 900;
			font-size: clamp(14px, 3.8vw, 16px);
			text-align: center;
			letter-spacing: 0;
		}
		
		/* Estilo especial para mostrar el placeholder de ejercicio - MUY VISIBLE */
		#exercise-input.dash-placeholder {
			color: #ffffff !important;
			background-color: #ff4d4d !important;
			font-weight: 900;
			font-size: clamp(18px, 4.5vw, 22px);
			text-align: center;
			letter-spacing: 2px;
			border-radius: 8px;
			animation: pulse 2s infinite;
			caret-color: #ffffff !important; /* cursor blanco visible */
		}
		
		@keyframes pulse {
			0% { background-color: #ff4d4d; }
			50% { background-color: #ff1a1a; }
			100% { background-color: #ff4d4d; }
		}

		/* ===== Menú superior responsivo (sin desbordes en móviles) ===== */
		.top-menu-wrapper {
			position: fixed; /* más estable que absolute en móviles */
			top: env(safe-area-inset-top, 0);
			left: 0;
			right: 0;
			z-index: 3000;
			padding: max(6px, env(safe-area-inset-top)) clamp(8px, 4vw, 16px);
			/* Oculta fuera de pantalla y que entre como una cinta de izq→der */
			transform: translateX(-110%);
			transition: transform 520ms cubic-bezier(.2,.8,.2,1);
			will-change: transform;
			pointer-events: none; /* no bloquear clics cuando esté oculta */
		}
		/* Mostrar cuando el body tenga la clase menu-open */
		body.menu-open .top-menu-wrapper { transform: translateX(0); pointer-events: auto; }
		.top-menu {
			background: linear-gradient(135deg, #434343 0%, #000000 100%);
			border-radius: 0 10px 10px 0; /* izquierda 0, derecha 10px */
			box-shadow: 0 4px 20px rgba(0,0,0,0.6);
			display: flex;
			align-items: center;
			justify-content: center;
			gap: clamp(4px, 2vw, 10px);
			flex-wrap: wrap; /* permite varias filas en pantallas pequeñas */
			padding: 10px clamp(10px, 4vw, 16px);
			margin: 0 auto;
			width: min(940px, 100%);
		}
		.label-chip { font-size: clamp(12px, 3.6vw, 16px); margin: 0 4px; white-space: nowrap; }
		/* Versión compacta final del input, sobrescribe la previa */
		.control-input {
			width: clamp(46px, 14vw, 68px);
			height: clamp(24px, 4.4vh, 32px);
			padding: 2px 1px;                 /* menos espacio a la derecha (número ↔ flechas) */
			border-radius: 10px;
			border: none;
			outline: none;
			font-size: clamp(11.5px, 3.2vw, 13px);
			font-weight: 700;
			text-align: center;
			background: transparent;           /* sin “doble caja” */
			box-shadow: none;                  /* limpio dentro del wrapper */
		}
		.round-icon-btn {
			width: clamp(32px, 9vw, 32px);
			height: clamp(32px, 9vw, 32px);
			font-size: clamp(18px, 5vw, 20px);
		}
		@media (max-width: 420px){ .label-chip{ display: none; } }
		@media (max-width: 360px){ .top-menu{ gap: 6px; padding: 8px 10px; } .control-input{ width: clamp(64px, 26vw, 96px); } }

		/* Modal elegante para errores */
		.error-modal {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.8);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 10000;
			backdrop-filter: blur(10px);
			animation: fadeIn 0.3s ease;
		}

		.error-modal-content {
			background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
			border-radius: 20px;
			padding: 30px;
			max-width: 400px;
			width: 90%;
			text-align: center;
			box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
			border: 1px solid rgba(255, 255, 255, 0.1);
			animation: slideUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
		}

		.error-icon {
			font-size: 60px;
			margin-bottom: 20px;
			opacity: 0.8;
		}

		.error-title {
			color: #fff;
			font-size: 24px;
			font-weight: 700;
			margin-bottom: 15px;
		}

		.error-message {
			color: #ccc;
			font-size: 16px;
			line-height: 1.5;
			margin-bottom: 25px;
		}

		.error-button {
			background: linear-gradient(135deg, #ff6b6b 0%, #ff5252 100%);
			color: white;
			border: none;
			padding: 12px 30px;
			border-radius: 12px;
			font-size: 16px;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.3s ease;
			box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
		}

		.error-button:hover {
			background: linear-gradient(135deg, #ff5252 0%, #e53935 100%);
			transform: translateY(-2px);
			box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
		}

		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}

		@keyframes slideUp {
			from {
				transform: translateY(30px);
				opacity: 0;
			}
			to {
				transform: translateY(0);
				opacity: 1;
			}
		}
	</style>
</head>
<body>
	<!-- Botón para mostrar/ocultar el menú -->
	<button id="menu-toggle-btn" class="menu-toggle-btn" aria-label="Mostrar u ocultar menú" aria-controls="top-menu" aria-expanded="false" title="Menú">
		<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
			<path d="M4 7h16"/>
			<path d="M4 12h16"/>
			<path d="M4 17h16"/>
		</svg>
	</button>
	<div class="pdf-viewer-container">
		<button class="side-arrow left-arrow" id="prev-page" title="Página anterior" aria-label="Página anterior">
			<svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true">
				<!-- Arco/cayado (báculo) hacia la izquierda -->
				<path d="M18 4C10 4 10 20 18 20" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" />
				<!-- Punta en forma de chevrón curvo -->
				<path d="M11 8L6 12L11 16" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
			</svg>
		</button>
		<button class="side-arrow right-arrow" id="next-page" title="Página siguiente" aria-label="Página siguiente">
			<svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true">
				<!-- Arco/cayado (báculo) hacia la derecha -->
				<path d="M6 4C14 4 14 20 6 20" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" />
				<!-- Punta en forma de chevrón curvo -->
				<path d="M13 8L18 12L13 16" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
			</svg>
		</button>
		
		<!-- Indicadores de zona de swipe para móvil -->
		<div class="swipe-indicator left" id="swipe-indicator-left"></div>
		<div class="swipe-indicator right" id="swipe-indicator-right"></div>
		
		<!-- Menú superior responsivo -->
		<div class="top-menu-wrapper">
			<div class="top-menu">
				<span class="input-with-icon with-prefix prefix-e" data-prefix="E">
					<input id="exercise-input" type="number" min="1" max="28" value="1" class="has-icon control-input" />
					<button id="show-exercise-btn" class="icon-btn" title="Ir al ejercicio">Ir</button>
				</span>

				<span class="input-with-icon with-prefix prefix-p" data-prefix="P">
					<input id="page-input" type="number" min="1" value="1" class="has-icon control-input" />
					<button id="goto-page-btn" class="icon-btn" title="Ir a la página">Ir</button>
				</span>

				<button id="show-all-btn" class="round-icon-btn" title="Mostrar PDF" aria-label="Mostrar PDF">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
						<path d="M3 5.5A2.5 2.5 0 0 1 5.5 3H12v18H5.5A2.5 2.5 0 0 1 3 18.5v-13z"/>
						<path d="M21 5.5A2.5 2.5 0 0 0 18.5 3H12v18h6.5A2.5 2.5 0 0 0 21 18.5v-13z"/>
					</svg>
				</button>
				<button id="download-page-btn" class="round-icon-btn" title="Descargar esta página en PDF" aria-label="Descargar esta página en PDF">
					<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
						<path d="M12 3v12"/>
						<path d="M7 10l5 5 5-5"/>
						<path d="M5 21h14"/>
					</svg>
				</button>
			</div>
		</div>

		<!-- Modal elegante para errores -->
		<div class="error-modal" id="error-modal">
			<div class="error-modal-content">
				<div class="error-icon">📚</div>
				<div class="error-title">Imagen no disponible</div>
				<div class="error-message" id="error-message">La imagen del ejercicio no se encuentra disponible en este momento.</div>
				<button class="error-button" onclick="closeErrorModal()">¡Entendido!</button>
			</div>
		</div>

		
		<div class="page-counter" id="page-counter">Página 1</div>
		<div class="loading" id="loading">Cargando PDF...</div>
		
		<canvas id="pdf-canvas"></canvas>
		<img id="exercise-img" alt="Ejercicio" />
	</div>
	<script>
		// Configurar PDF.js worker
		pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
		
		// Inicialización temprana para prevenir parpadeos en móvil
		let isInitialLoad = true; // Flag para controlar la primera carga
		let isMobile = window.innerWidth <= 768;
		
		// Ocultar elementos problemáticos inmediatamente en móvil
		if (isMobile) {
			document.addEventListener('DOMContentLoaded', function() {
				const container = document.querySelector('.pdf-viewer-container');
				const canvas = document.getElementById('pdf-canvas');
				const loading = document.getElementById('loading');
				
				if (canvas) canvas.style.display = 'none';
				if (loading) loading.style.display = 'none';
				
				// Solo mostrar contenido cuando esté completamente inicializado
				setTimeout(() => {
					if (container) container.classList.add('loaded');
					document.body.classList.add('mobile-loaded');
				}, 2000); // 2 segundos de gracia para carga completa
				
				// Backup: mostrar contenido después de máximo 4 segundos sin importar el estado
				setTimeout(() => {
					if (container) container.classList.add('loaded');
					document.body.classList.add('mobile-loaded');
				}, 4000);
			});
		}
		
		// Variables globales
		const urlDefault = 'https://fawzinoo.github.io/Rep/U11.pdf';
		let pdfDoc = null;
		let currentPage = 1;
		let totalPages = 0;
		let zoomLevel = 1.0; // Empezar con zoom 1.0 para pantalla completa
		let canvas = null;
		let ctx = null;
		// Estado para teclado móvil y tamaño de viewport estable
		let keyboardOpen = false;
		let stableViewport = { width: window.innerWidth, height: window.innerHeight };
		let pendingKeyboardCloseRender = false;
		// Cola / control de render estable
		let __isRendering = false;
		let __pendingPage = null;
		// Modo estable configurable
		const STABLE_MODE = true; // fuerza secuencial y evita saltos
		const NO_FLIP_ANIMATION = true; // desactiva la animación rotateY para máxima estabilidad
		let exerciseBeforeError = 1; // Guardar el ejercicio que se intentó abrir
		let currentExerciseTarget = null; // Ejercicio solicitado/visible actualmente
		let showImageRequestId = 0; // Control de concurrencia para carga de ejercicios
		// Caché de resultados exitosos y fracasos definitivos
		const exerciseImageCache = new Map(); // n -> { url, status: 'ok'|'fail' }
		const PREFETCH_AHEAD = 1; // cuántos ejercicios adelante prefetch
		const IMAGE_TIMEOUT_MS = 6500; // ampliar timeout para conexiones lentas
		const MAX_RETRY_ROUND = 2; // cuántas rondas completas de candidatos antes de declarar fail

		function prefetchExercise(n){
			if (exerciseImageCache.has(n) && exerciseImageCache.get(n).status === 'ok') return;
			if (n < 1 || n > imageLinks.length) return;
			const base = baseImageUrl.replace(/\/$/, '');
			const candidates = [];
			if (imageLinks[n-1]) candidates.push(imageLinks[n-1]);
			candidates.push(`${base}/U1E${n}.png`,`$${'base'}/U1E${n}.jpg`,`$${'base'}/U1E${n}.jpeg`); // intentionally redundant fallback
			if (n < 10){
				const nn = `0${n}`;
				candidates.push(`${base}/U1E${nn}.png`,`$${'base'}/U1E${nn}.jpg`,`$${'base'}/U1E${nn}.jpeg`);
			}
			// intentar primer candidato solamente para no saturar
			const url = candidates[0];
			const img = new Image();
			img.onload = ()=>{
				if (!exerciseImageCache.has(n)) exerciseImageCache.set(n,{url, status:'ok'});
			};
			img.src = url;
		}

		// Helper para saber si el ejercicio está visible (estado real computado)
		function isExerciseVisible() {
			const el = document.getElementById('exercise-img');
			if (!el) return false;
			return window.getComputedStyle(el).display !== 'none';
		}

		// Funciones para gestionar historial con localStorage
		function saveUserState(type, data) {
			const state = {
				type: type, // 'pdf' o 'exercise'
				data: data, // { page: number } para PDF, { exerciseNumber: number } para ejercicio
				timestamp: Date.now()
			};
			localStorage.setItem('visorUserState', JSON.stringify(state));
		}

		// Guardar/leer último ejercicio válido mostrado
		function setLastValidExercise(n) {
			try { localStorage.setItem('lastValidExercise', String(n)); } catch (e) {}
		}
		function getLastValidExercise() {
			try {
				const v = localStorage.getItem('lastValidExercise');
				return v ? parseInt(v, 10) : null;
			} catch (e) {
				return null;
			}
		}

		function getUserState() {
			try {
				const saved = localStorage.getItem('visorUserState');
				return saved ? JSON.parse(saved) : null;
			} catch (e) {
				return null;
			}
		}

		function restoreUserState() {
			const savedState = getUserState();
			if (!savedState) {
				// Si no hay estado guardado, asegurar que el PDF esté visible
				document.getElementById('exercise-img').style.display = 'none';
				const pdfCanvas = document.getElementById('pdf-canvas');
				pdfCanvas.style.display = 'block';
				pdfCanvas.style.transition = '';
				pdfCanvas.style.opacity = '1';
				pdfCanvas.style.transform = 'translateX(-50%)';
				return;
			}

			// Esta función ya no es necesaria porque la lógica se maneja en la inicialización
			// Mantenerla por compatibilidad pero no hacer nada
		}

		// Base de imágenes (ajusta si guardas en otro sitio)
		const baseImageUrl = 'https://fawzinoo.github.io/Fotos/';
		const imageLinks = Array.from({ length: 28 }, (_, i) => `${baseImageUrl}U1E${i+1}.png`);
		const exerciseImg = document.getElementById('exercise-img');
		// Mapeo de ejercicios a páginas del PDF
		const exerciseToPage = {
			1: 1, 2: 1, 3: 1, 4: 1,
			5: 2, 6: 2, 7: 2,
			9: 3, 10: 3, 12: 3, 13: 3, 14: 3,
			15: 4, 16: 4,
			17: 5, 18: 5, 19: 5,
			21: 6, 22: 6, 23: 6,
			24: 7, 25: 7, 26: 7
		};
		// Conjunto rápido de ejercicios definidos
		const definedExercises = new Set(Object.keys(exerciseToPage).map(k => parseInt(k,10)));

		function getCurrentExerciseNumber(){
			const img = document.getElementById('exercise-img');
			if (img && isExerciseVisible() && img.dataset && img.dataset.exerciseNumber) {
				return parseInt(img.dataset.exerciseNumber, 10);
			}
			return null;
		}

		function navigateExercise(delta, isSwipe = false){
			// Basado en ejercicio actual o input
			let current = getCurrentExerciseNumber();
			if (!current) {
				const last = getLastValidExercise();
				if (last) current = last; else current = parseInt(document.getElementById('exercise-input').value,10) || 1;
			}
			let target = current + delta;
			// Buscar siguiente válido dentro de límites razonables
			const MAX = imageLinks.length;
			while (target >= 1 && target <= MAX && !definedExercises.has(target)) {
				target += delta;
			}
			if (target < 1 || target > MAX) return; // no hace nada si sale de rango
			// Evitar repetir
			if (target === currentExerciseTarget || target === current) return;
			// Actualizar input visual
			const exInput = document.getElementById('exercise-input');
			if (exInput) exInput.value = target;
			// Reproducir sonido apropiado: swipe para gestos, botón para clics
			if (isSwipe) {
				playSwipeSound();
			} else {
				playButtonSound();
			}
			showImageByNumber(target, { suppressError: false, onSuccess: () => updateNavigationArrows(), onFail: () => updateNavigationArrows() });
			setTimeout(updateNavigationArrows,0);
		}
		
		// Inicializar canvas
		canvas = document.getElementById('pdf-canvas');
		ctx = canvas.getContext('2d');
		

		// Permitir modificar el ancho y el alto visual de la página PDF
		const widthFactor = 1.0; // Cambia este valor para hacer la página más ancha (>1) o más estrecha (<1)
		const heightFactor = 0.8; // Ligeramente más alto que el original

		function renderPage(pageNum) {
		   if (STABLE_MODE) {
		   	if (__isRendering) { __pendingPage = pageNum; return; }
		   	__isRendering = true;
		   }
		   const loading = document.getElementById('loading');
		   // Solo mostrar pantalla de carga después de la carga inicial
		   if (!isInitialLoad) {
		   	loading.style.display = 'block';
		   }

		   // Si hay una animación en curso, la cancelamos para evitar que el canvas quede "volcado"
		   if (window.__pageFlip && window.__pageFlip.isAnimating) {
		   	try { window.__pageFlip.cancel(); } catch(e) {}
		   }

		   // Si el teclado está abierto y el resize ha reducido artificialmente el viewport, posponer render salvo que sea forzado
		   if (keyboardOpen) {
		   	// Mantener tamaño anterior (stableViewport)
		   	// Mostrar la página actual sin recalcular escala para evitar miniaturas
		   	// Marcamos que al cerrar el teclado se hará un render correcto
		   	pendingKeyboardCloseRender = true;
		   }

		   pdfDoc.getPage(pageNum).then(function(page) {
			   // Obtener dimensiones de la pantalla (estables si teclado abierto)
			   const containerWidth = keyboardOpen ? stableViewport.width : window.innerWidth;
			   const containerHeight = keyboardOpen ? stableViewport.height : window.innerHeight;
			   const dpr = window.devicePixelRatio || 1;

			   // Calcular el scale para que ocupe toda la pantalla
			   const viewport = page.getViewport({ scale: 1 });
			   const scaleX = (containerWidth / viewport.width) * widthFactor;
			   const scaleY = containerHeight / viewport.height;
			   // Priorizar el alto y aumentar un 25% para que la página se vea aún más alta
			   const scale = scaleY * 1.25 * dpr * zoomLevel;

			   // Viewport escalado para alta resolución
			   const scaledViewport = page.getViewport({ scale: scale });

		   // Ajustar el tamaño interno del canvas (alta resolución)
		   canvas.width = scaledViewport.width;
		   canvas.height = scaledViewport.height;

		   // Ajustar el tamaño visual del canvas (pantalla)
		   canvas.style.width = ((scaledViewport.width / dpr) / widthFactor) + 'px';
		   canvas.style.height = ((scaledViewport.height / dpr) * heightFactor) + 'px';
		   canvas.style.objectFit = 'fill';
		   
		   // Asegurar que el canvas está en el flujo (ya no usamos display:none), mantenemos opacity para fade
		   if (canvas.style.display === 'none') canvas.style.display = 'block';

		   const renderContext = {
			   canvasContext: ctx,
			   viewport: scaledViewport
		   };
		   page.render(renderContext).promise.then(function() {
			   loading.style.display = 'none';
			   if (isInitialLoad) {
				   // Fade ultrarápido para evitar percepción de parpadeo largo
				   requestAnimationFrame(() => { canvas.style.opacity = '1'; });
			   } else {
				   canvas.style.opacity = '1';
			   }
			   isInitialLoad = false;
				   updatePageCounter();
				   saveUserState('pdf', { page: currentPage });
			   }).catch(()=>{}).finally(()=>{
				   if (STABLE_MODE) {
				   	__isRendering = false;
				   	if (__pendingPage != null && __pendingPage !== currentPage) {
				   		const next = __pendingPage; __pendingPage = null; renderPage(next); return;
				   	}
				   	__pendingPage = null;
				   }
			   });
		   });
		}

		// Mostrar imagen desde enlaces con reintento png->jpg, fallback a PDF
		function showImageByNumber(n, options = {}) {
			console.log('showImageByNumber llamada con:', n); // Debug
			
			// Nueva versión: transición inmediata sin estado de "Cargando" en el botón
			const { suppressError = false, onFail, onSuccess } = options;
			const myReq = ++showImageRequestId;
			exerciseBeforeError = n;
			currentExerciseTarget = n;

			// Si mientras tanto el usuario cambió de idea muy rápido, abortar pronto
			function isStale(){ return myReq !== showImageRequestId; }

			// Si el ejercicio no está en la lista definida, no iniciar carga de imágenes (evita intentos inútiles)
			if (!definedExercises.has(n)) {
				console.log('Ejercicio no definido:', n); // Debug
				// Marcar fail en caché pero no mostrar modal si no es la solicitud activa
				if (!isStale()) {
					exerciseImageCache.set(n,{status:'fail'});
					if (!suppressError) showErrorModal(`Ejercicio ${n}`, 'El ejercicio no está programado por tu profesor, elige otro ejercicio.');
					if (typeof onFail === 'function') onFail();
				}
				return;
			}

			console.log('Ejercicio válido, intentando cargar:', n); // Debug

			// Si ya cacheado OK: mostrar al instante SIN TRANSICIONES
			if (exerciseImageCache.has(n) && exerciseImageCache.get(n).status === 'ok') {
				const cached = exerciseImageCache.get(n);
				const pdfCanvas = document.getElementById('pdf-canvas');
				const exerciseImgEl = document.getElementById('exercise-img');
				
				// Cambio instantáneo
				if (pdfCanvas) {
					pdfCanvas.style.display='none';
				}
				exerciseImgEl.style.display='block';
				exerciseImgEl.style.opacity = '1';
				exerciseImgEl.style.transition = 'none';
				exerciseImgEl.src = cached.url;
				exerciseImgEl.dataset.exerciseNumber = String(n);
				adjustImageSize();
				// Sincronizar cuadro de páginas si el ejercicio pertenece a una página
				const mapped = exerciseToPage[n];
				if (mapped) {
					currentPage = mapped;
					const pageInput = document.getElementById('page-input');
					if (pageInput) pageInput.value = mapped;
					const pageCounter = document.getElementById('page-counter');
					if (pageCounter && totalPages) {
						pageCounter.innerHTML = `Página <span class="pc-num">${mapped}</span> de <span class="pc-num">${totalPages}</span>`;
					}
				}
				saveUserState('exercise',{exerciseNumber:n});
				setLastValidExercise(n);
				if (typeof onSuccess==='function') onSuccess();
				// Prefetch siguientes
				for (let i=1;i<=PREFETCH_AHEAD;i++){ prefetchExercise(n+i); }
				updateNavigationArrows();
				return;
			}

			const pdfCanvas = document.getElementById('pdf-canvas');
			const exerciseImgEl = document.getElementById('exercise-img');

			// Transición INSTANTÁNEA: ocultar PDF y mostrar ejercicio directamente
			if (pdfCanvas) {
				pdfCanvas.style.display = 'none';
			}

			// Mostrar ejercicio inmediatamente sin transiciones
			exerciseImgEl.style.display = 'block';
			exerciseImgEl.style.opacity = '1';
			exerciseImgEl.style.transform = 'translate(-50%, -50%)';
			exerciseImgEl.style.transition = 'none';
			
			// Ajustar tamaño inmediatamente
			adjustImageSize();

			// Construir candidatos
			const base = baseImageUrl.replace(/\/$/, '');
			const candidates = [];
			if (imageLinks[n-1]) candidates.push(imageLinks[n-1]);
			candidates.push(`${base}/U1E${n}.png`);
			candidates.push(`${base}/U1E${n}.jpg`);
			candidates.push(`${base}/U1E${n}.jpeg`);
			if (n < 10) {
				const nn = `0${n}`;
				candidates.push(`${base}/U1E${nn}.png`);
				candidates.push(`${base}/U1E${nn}.jpg`);
				candidates.push(`${base}/U1E${nn}.jpeg`);
			}

			let tried = 0;
			let round = 1;
			function tryNext() {
				if (tried >= candidates.length) {
					if (round < MAX_RETRY_ROUND) {
						tried = 0; round++;
					} else {
						// Antes de mostrar error, comprobar si la petición sigue siendo la actual y si el usuario
						// continúa intentando ver este ejercicio; si no, silenciosamente abortar.
						if (isStale() || getCurrentExerciseNumber() !== n) {
							return; // solicitud desfasada: no mostrar nada
						}
						currentExerciseTarget = null;
						exerciseImageCache.set(n,{status:'fail'});
						if (!suppressError) {
							showErrorModal(`Ejercicio ${n}`, 'El ejercicio no está programado por tu profesor, elige otro ejercicio.');
						}
						if (pdfCanvas) {
							pdfCanvas.style.display = 'block';
							pdfCanvas.style.opacity = '0';
							pdfCanvas.style.transform = 'translateX(-50%) scale(1.04)';
							requestAnimationFrame(() => {
								pdfCanvas.style.transition = 'opacity 0.45s ease, transform 0.45s cubic-bezier(.19,1,.22,1)';
								pdfCanvas.style.opacity = '1';
								pdfCanvas.style.transform = 'translateX(-50%) scale(1)';
							});
						}
						exerciseImgEl.style.display = 'none';
						if (typeof onFail === 'function') onFail();
						return;
					}
				}
				const url = candidates[tried++];
				const testImg = new Image();
				let timeoutId;
				function cleanup(){
					try { testImg.onload = null; testImg.onerror = null; } catch(e) {}
					if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }
				}
				testImg.onload = function(){
					if (myReq !== showImageRequestId) { cleanup(); return; }
					exerciseImgEl.src = url;
					exerciseImgEl.dataset.exerciseNumber = String(n);
					exerciseImageCache.set(n,{url, status:'ok'});
					adjustImageSize();
					// Sincronizar cuadro de páginas si el ejercicio pertenece a una página
					const mapped = exerciseToPage[n];
					if (mapped) {
						currentPage = mapped;
						const pageInput = document.getElementById('page-input');
						if (pageInput) pageInput.value = mapped;
						const pageCounter = document.getElementById('page-counter');
						if (pageCounter && totalPages) {
							pageCounter.innerHTML = `Página <span class="pc-num">${mapped}</span> de <span class="pc-num">${totalPages}</span>`;
						}
					}
					saveUserState('exercise',{exerciseNumber:n});
					setLastValidExercise(n);
					if (typeof onSuccess==='function') onSuccess();
					// Prefetch siguientes ejercicios
					for (let i=1;i<=PREFETCH_AHEAD;i++){ prefetchExercise(n+i); }
					updateNavigationArrows();
					cleanup();
				};
				testImg.onerror = function(){
					// Si ya no es la solicitud actual, abortar sin continuar reintentos
					if (isStale()) { cleanup(); return; }
					cleanup();
					tryNext();
				};
				timeoutId = setTimeout(()=>{ try { testImg.src=''; } catch(e) {}; testImg.onerror && testImg.onerror(); }, IMAGE_TIMEOUT_MS);
				testImg.src = url;
			}
			tryNext();
		}
		
		// Actualizar contador de páginas
		function updatePageCounter() {
			const pageCounter = document.getElementById('page-counter');
			pageCounter.innerHTML = `Página <span class="pc-num">${currentPage}</span> de <span class="pc-num">${totalPages}</span>`;

			// Sincronizar el input de página si existe
			const pageInput = document.getElementById('page-input');
			if (pageInput) {
				pageInput.value = String(currentPage);
				if (totalPages) pageInput.max = String(totalPages);
			}
			
			updateNavigationArrows();
		}

		function updateNavigationArrows(){
			const left = document.getElementById('prev-page');
			const right = document.getElementById('next-page');
			if(!left || !right) return;
			if (isExerciseVisible()) {
				let ex = getCurrentExerciseNumber();
				if (!ex && currentExerciseTarget) ex = currentExerciseTarget;
				if (!ex) {
					const v = parseInt(document.getElementById('exercise-input').value,10);
					if (Number.isFinite(v)) ex = v;
				}
				let prevValid=null; for (let i=ex-1;i>=1;i--){ if(definedExercises.has(i)){ prevValid=i; break; } }
				let nextValid=null; for (let i=ex+1;i<=imageLinks.length;i++){ if(definedExercises.has(i)){ nextValid=i; break; } }
				left.style.opacity = prevValid ? '1':'0.3';
				right.style.opacity = nextValid ? '1':'0.3';
				// Aplicar clases claras simétricas cuando hay ejercicios navegables
				if (prevValid) left.classList.add('exercise-left-active'); else left.classList.remove('exercise-left-active');
				if (nextValid) right.classList.add('exercise-right-active'); else right.classList.remove('exercise-right-active');

				// Requisito: a partir del ejercicio 2 la flecha izquierda debe verse igual que la derecha (activa),
				// incluso si momentáneamente aún no se detectó prevValid por asincronía.
				if (ex >= 2) {
					left.style.opacity = '1';
					left.classList.add('exercise-left-active');
				}
			} else {
				left.style.opacity = currentPage <= 1 ? '0.3' : '1';
				right.style.opacity = currentPage >= totalPages ? '0.3' : '1';
				left.classList.remove('exercise-left-active');
				right.classList.remove('exercise-right-active');
			}
		}
		
		// Navegación por páginas
		function nextPage() {
			if (currentPage < totalPages) {
				currentPage++;
				renderPage(currentPage);
			}
		}
		
		function prevPage() {
			if (currentPage > 1) {
				currentPage--;
				renderPage(currentPage);
			}
		}
		

		
		// Sonido para botones (navegación, acciones y cierre de modal) con debounce
		const pageSound = new Audio('https://fawzinoo.github.io/audios/botonn.mp3');
		pageSound.preload = 'auto';
		
		// Sonido específico para gestos de swipe
		const swipeSound = new Audio('https://www.fesliyanstudios.com/play-mp3/387');
		swipeSound.preload = 'auto';
		let lastSoundAt = 0;
		function playButtonSound(minIntervalMs = 350) {
			const now = Date.now();
			// si el sonido ya se está reproduciendo recientemente, no reiniciar
			if (!pageSound.paused && (now - lastSoundAt < 1000)) return;
			if (now - lastSoundAt < minIntervalMs) return; // debounce
			lastSoundAt = now;
			try {
				pageSound.pause();
				pageSound.currentTime = 0;
				pageSound.play();
			} catch (e) {}
		}

		// Función específica para sonido de swipe
		let lastSwipeSoundAt = 0;
		function playSwipeSound(minIntervalMs = 200) {
			const now = Date.now();
			// si el sonido ya se está reproduciendo recientemente, no reiniciar
			if (!swipeSound.paused && (now - lastSwipeSoundAt < 800)) return;
			if (now - lastSwipeSoundAt < minIntervalMs) return; // debounce
			lastSwipeSoundAt = now;
			try {
				swipeSound.pause();
				swipeSound.currentTime = 0;
				swipeSound.play();
			} catch (e) {}
		}

		// Vibración ligera al presionar botones (si el dispositivo lo soporta)
		function haptic(ms = 18) {
			try {
				if (window.navigator && 'vibrate' in window.navigator) {
					window.navigator.vibrate(ms);
				}
			} catch (e) {}
		}

		// Adjuntar vibración a todos los botones de la interfaz
		(function attachHaptics(){
			const btns = document.querySelectorAll('button');
			btns.forEach(b => {
				b.addEventListener('click', () => haptic(22), { passive: true });
				b.addEventListener('pointerdown', () => haptic(14), { passive: true });
			});
		})();
		
		// Animación de transición tipo libro
		function animatePage(direction) {
			if (NO_FLIP_ANIMATION) return; // desactivar animación para estabilidad
			if (!window.__pageFlip) initPageFlipHelper();
			window.__pageFlip.start(direction);
		}

		// Helper para controlar animaciones y poder cancelarlas limpiamente
		function initPageFlipHelper(){
			const baseTransform = 'translateX(-50%)';
			const canvas = document.getElementById('pdf-canvas');
			window.__pageFlip = {
				isAnimating: false,
				_timeout: null,
				start(dir){
					if (this.isAnimating) this.cancel();
					this.isAnimating = true;
					try { canvas.style.willChange = 'transform'; } catch(e) {}
					canvas.style.transition = 'transform 0.45s cubic-bezier(.77,0,.18,1)';
					canvas.style.transform = (dir === 'right')
						? baseTransform + ' rotateY(-30deg) scale(0.96)'
						: baseTransform + ' rotateY(30deg) scale(0.96)';
					this._timeout = setTimeout(() => {
						canvas.style.transition = 'transform 0.25s ease';
						canvas.style.transform = baseTransform;
						setTimeout(() => {
							this.isAnimating = false;
							canvas.style.transition = '';
							canvas.style.willChange = '';
						}, 260);
					}, 450);
				},
				cancel(){
					try { clearTimeout(this._timeout); } catch(e) {}
					this._timeout = null;
					this.isAnimating = false;
					canvas.style.transition = '';
					canvas.style.transform = baseTransform;
					canvas.style.willChange = '';
				}
			};
		}

		// Renderizar una página del PDF a un canvas fuera de pantalla, a buena resolución
		async function renderPageToCanvas(pageNum, scale = 2) {
			if (!pdfDoc) throw new Error('PDF no cargado');
			const page = await pdfDoc.getPage(pageNum);
			const viewport = page.getViewport({ scale });
			const off = document.createElement('canvas');
			const offCtx = off.getContext('2d');
			off.width = viewport.width;
			off.height = viewport.height;
			await page.render({ canvasContext: offCtx, viewport }).promise;
			return off;
		}

		// Descargar la página actual o la mapeada desde ejercicio como PDF de una sola página
		async function downloadCurrentPdfPage() {
			try {
				// Determinar la página destino: si hay ejercicio visible, usar mapeo; de lo contrario, currentPage
				let exNum = null;
				const exEl = document.getElementById('exercise-img');
				const isExerciseVisible = exEl && exEl.style.display !== 'none';
				if (isExerciseVisible) {
					if (exEl.dataset && exEl.dataset.exerciseNumber) {
						exNum = parseInt(exEl.dataset.exerciseNumber, 10);
					} else if (currentExerciseTarget) {
						exNum = parseInt(currentExerciseTarget, 10);
					} else {
						exNum = getLastValidExercise();
					}
				}
				let pageNum = (exNum && exerciseToPage[exNum]) ? exerciseToPage[exNum] : currentPage;
				// Renderizar a canvas fuera de pantalla
				const offCanvas = await renderPageToCanvas(pageNum, 2);
				// Calcular tamaño en puntos (asumiendo 96 dpi para CSS px)
				const pxToPt = 72 / 96;
				const widthPt = offCanvas.width * pxToPt;
				const heightPt = offCanvas.height * pxToPt;
				const dataUrl = offCanvas.toDataURL('image/jpeg', 0.95);
				const { jsPDF } = window.jspdf;
				const pdf = new jsPDF({ unit: 'pt', format: [widthPt, heightPt] });
				pdf.addImage(dataUrl, 'JPEG', 0, 0, widthPt, heightPt);
				pdf.save(`pagina_${pageNum}.pdf`);
			} catch (e) {
				alert('No se pudo descargar la página: ' + (e && e.message ? e.message : e));
			}
		}
		
		// Event listeners
		let isPaging = false;
		document.getElementById('next-page').onclick = function() {
			if (isExerciseVisible()) {
				navigateExercise(+1, true);
				return;
			}
			if (isPaging || currentPage >= totalPages) return; // no hay cambio
			if (window.__pageFlip && window.__pageFlip.isAnimating) { try { window.__pageFlip.cancel(); } catch(e) {} }
			isPaging = true;
			animatePage('right');
			playSwipeSound();
			try { if (document.body.classList.contains('menu-open')) { window.__resetMenuInactivity && window.__resetMenuInactivity(); } } catch(e) {}
			setTimeout(() => { nextPage(); isPaging = false; updateNavigationArrows(); }, 220);
		};
		
		document.getElementById('prev-page').onclick = function() {
			if (isExerciseVisible()) {
				navigateExercise(-1, true);
				return;
			}
			if (isPaging || currentPage <= 1) return; // no hay cambio
			if (window.__pageFlip && window.__pageFlip.isAnimating) { try { window.__pageFlip.cancel(); } catch(e) {} }
			isPaging = true;
			animatePage('left');
			playSwipeSound();
			try { if (document.body.classList.contains('menu-open')) { window.__resetMenuInactivity && window.__resetMenuInactivity(); } } catch(e) {}
			setTimeout(() => { prevPage(); isPaging = false; updateNavigationArrows(); }, 220);
		};
		


		document.getElementById('show-exercise-btn').onclick = function() {
			const input = document.getElementById('exercise-input');
			
			// Limpiar estado rojo si existe
			if (input.classList.contains('red-placeholder')) {
				input.classList.remove('red-placeholder');
				if (input._removeClass) {
					input.removeEventListener('input', input._removeClass);
					input._removeClass = null;
				}
			}
			
			const n = parseInt(input.value, 10);
			console.log('Ejercicio solicitado:', n); // Debug
			
			if (!n || n < 1 || n > imageLinks.length) {
				alert('Número entre 1 y ' + imageLinks.length);
				return;
			}
			
			playButtonSound();
			
			// Verificar que el elemento de imagen existe
			const exerciseImgEl = document.getElementById('exercise-img');
			if (!exerciseImgEl) {
				console.error('Elemento exercise-img no encontrado');
				return;
			}
			
			showImageByNumber(n,{ 
				onSuccess: () => {
					console.log('Ejercicio cargado exitosamente:', n);
					updateNavigationArrows();
				}, 
				onFail: () => {
					console.log('Error cargando ejercicio:', n);
					updateNavigationArrows();
				}
			});
			setTimeout(updateNavigationArrows,0);
		};

		document.getElementById('show-all-btn').onclick = function() {
			// Transición instantánea de la imagen al PDF
			if (isExerciseVisible()) {
				playButtonSound();
				
				// Ocultar imagen inmediatamente
				exerciseImg.style.display = 'none';
				exerciseImg.style.transition = 'none';
				
				// Calcular página destino según el ejercicio visible/solicitado/guardado
				let exNum = null;
				try {
					if (exerciseImg.dataset && exerciseImg.dataset.exerciseNumber) {
						exNum = parseInt(exerciseImg.dataset.exerciseNumber, 10);
					}
					if (!exNum && currentExerciseTarget) {
						exNum = parseInt(currentExerciseTarget, 10);
					}
					if (!exNum) {
						exNum = getLastValidExercise();
					}
				} catch (e) {}
				const targetPage = exNum && exerciseToPage[exNum] ? exerciseToPage[exNum] : null;
				// Mostrar PDF inmediatamente sin transiciones elaboradas
				const pdfCanvas = document.getElementById('pdf-canvas');
				pdfCanvas.style.display = 'block';
				pdfCanvas.style.opacity = '1';
				pdfCanvas.style.transform = 'translateX(-50%) scale(1)';
				pdfCanvas.style.transition = 'none';
				if (targetPage && targetPage >= 1 && (!totalPages || targetPage <= totalPages)) {
					currentPage = targetPage;
				}
				renderPage(currentPage);
			} else {
				// Si no hay imagen, ya estamos en PDF: calcular si hay un destino mapeado reciente
				const pdfCanvas = document.getElementById('pdf-canvas');
				pdfCanvas.style.display = 'block';
				let exNum = null;
				try {
					if (exerciseImg.dataset && exerciseImg.dataset.exerciseNumber) {
						exNum = parseInt(exerciseImg.dataset.exerciseNumber, 10);
					}
					if (!exNum && currentExerciseTarget) {
						exNum = parseInt(currentExerciseTarget, 10);
					}
					if (!exNum) {
						exNum = getLastValidExercise();
					}
				} catch (e) {}
				const targetPage = exNum && exerciseToPage[exNum] ? exerciseToPage[exNum] : null;
				if (targetPage && targetPage >= 1 && (!totalPages || targetPage <= totalPages)) {
					currentPage = targetPage;
				}
				renderPage(currentPage);
			}
		};

		// Descargar página actual/mapeada
		document.getElementById('download-page-btn').onclick = function() {
			playButtonSound();
			downloadCurrentPdfPage();
		};

		// Ir a página específica
		function renderPageStable(targetPage, forceWhileKeyboard = false){
			if (keyboardOpen && !forceWhileKeyboard) {
				pendingKeyboardCloseRender = true;
				currentPage = targetPage;
				return;
			}
			// Si forzamos durante teclado, anulamos el pending previo (estaba esperando cierre)
			if (forceWhileKeyboard) {
				pendingKeyboardCloseRender = false;
			}
			currentPage = targetPage;
			renderPage(currentPage);
		}

		document.getElementById('goto-page-btn').onclick = function() {
			const input = document.getElementById('page-input');
			if (!input) return;
			let n = parseInt(input.value, 10);
			if (!Number.isFinite(n)) return;
			// Validación de página inexistente
			if (totalPages && (n < 1 || n > totalPages)) {
				showErrorModal('Página ' + n, 'La página solicitada no existe en este documento (1 - ' + totalPages + ').');
				return;
			}
			if (n === currentPage) return;
			if (window.__pageFlip && window.__pageFlip.isAnimating) { try { window.__pageFlip.cancel(); } catch(e) {} }
			const exEl = document.getElementById('exercise-img');
			const wasExerciseVisible = isExerciseVisible();
			playButtonSound();
			if (wasExerciseVisible) {
				exEl.style.transition = 'opacity 0.25s ease';
				exEl.style.opacity = '0';
				setTimeout(() => {
					exEl.style.display = 'none';
					const pdfCanvas = document.getElementById('pdf-canvas');
					pdfCanvas.style.display = 'block';
					pdfCanvas.style.opacity = '1';
					pdfCanvas.style.transform = 'translateX(-50%)';
					// SIEMPRE activar el indicador rojo al ir a una página
					const exInput = document.getElementById('exercise-input');
					if (exInput) {
						// Limpiar listeners anteriores si existen
						if (exInput._removeClass) {
							exInput.removeEventListener('input', exInput._removeClass);
						}
						exInput.value = ''; // Input vacío con cursor parpadeando
						exInput.classList.add('dash-placeholder');
						exInput.focus(); // Enfocar para mostrar cursor
						// Remover la clase cuando el usuario empiece a escribir
						const removeClass = () => {
							if (exInput.value !== '') {
								exInput.classList.remove('dash-placeholder');
								exInput.removeEventListener('input', removeClass);
								exInput._removeClass = null;
							}
						};
						exInput._removeClass = removeClass;
						exInput.addEventListener('input', removeClass);
					}
					currentExerciseTarget = null;
					renderPageStable(n);
				}, 260);
			} else {
				// SIEMPRE activar el indicador rojo al ir a una página (incluso si ya estábamos en PDF)
				const exInput = document.getElementById('exercise-input');
				if (exInput) {
					// Limpiar listeners anteriores si existen
					if (exInput._removeClass) {
						exInput.removeEventListener('input', exInput._removeClass);
					}
					exInput.value = ''; // Input vacío con cursor parpadeando
					exInput.classList.add('dash-placeholder');
					exInput.focus(); // Enfocar para mostrar cursor
					// Remover la clase cuando el usuario empiece a escribir
					const removeClass = () => {
						if (exInput.value !== '') {
							exInput.classList.remove('dash-placeholder');
							exInput.removeEventListener('input', removeClass);
							exInput._removeClass = null;
						}
					};
					exInput._removeClass = removeClass;
					exInput.addEventListener('input', removeClass);
				}
				renderPageStable(n);
			}
		};

		// Enter en input de página → Ir
		document.getElementById('page-input').addEventListener('keypress', function(e) {
			if (e.key === 'Enter') {
				e.preventDefault();
				const input = this;
				let n = parseInt(input.value, 10);
				if (!Number.isFinite(n)) return;
				if (totalPages && (n < 1 || n > totalPages)) {
					showErrorModal('Página ' + n, 'La página solicitada no existe en este documento (1 - ' + totalPages + ').');
					return;
				}
				if (n === currentPage) return;
				// Cancelar animación si existiera
				if (window.__pageFlip && window.__pageFlip.isAnimating) { try { window.__pageFlip.cancel(); } catch(e) {} }
				// Si hay imagen visible, primero ocultarla (similar al botón Ir)
				const exEl = document.getElementById('exercise-img');
				const wasExerciseVisible = isExerciseVisible();
				playButtonSound();
				if (wasExerciseVisible) {
					exEl.style.transition = 'opacity 0.25s ease';
					exEl.style.opacity = '0';
					setTimeout(() => {
						exEl.style.display = 'none';
						// Al ir a una página desde un ejercicio, mostrar input vacío con fondo rojo
						const exInput = document.getElementById('exercise-input');
						if (exInput) {
							exInput.value = ''; // Input vacío con cursor parpadeando
							exInput.classList.add('dash-placeholder');
							exInput.focus(); // Enfocar para mostrar cursor
							// Remover la clase cuando el usuario empiece a escribir
							const removeClass = () => {
								if (exInput.value !== '') {
									exInput.classList.remove('dash-placeholder');
									exInput.removeEventListener('input', removeClass);
								}
							};
							exInput.addEventListener('input', removeClass);
						}
						currentExerciseTarget = null;
						renderPageStable(n, true); // forzar aunque teclado siga abierto
					}, 250);
				} else {
					// SIEMPRE activar el indicador rojo al ir a una página (incluso si ya estábamos en PDF)
					const exInput = document.getElementById('exercise-input');
					if (exInput) {
						// Limpiar listeners anteriores si existen
						if (exInput._removeClass) {
							exInput.removeEventListener('input', exInput._removeClass);
						}
						exInput.value = ''; // Input vacío con cursor parpadeando
						exInput.classList.add('dash-placeholder');
						exInput.focus(); // Enfocar para mostrar cursor
						// Remover la clase cuando el usuario empiece a escribir
						const removeClass = () => {
							if (exInput.value !== '') {
								exInput.classList.remove('dash-placeholder');
								exInput.removeEventListener('input', removeClass);
								exInput._removeClass = null;
							}
						};
						exInput._removeClass = removeClass;
						exInput.addEventListener('input', removeClass);
					}
					renderPageStable(n, true);
				}
			}
		});

		// Permitir presionar Enter en el campo de ejercicio para ejecutar "Ir"
		document.getElementById('exercise-input').addEventListener('keypress', function(e) {
			if (e.key === 'Enter') {
				e.preventDefault();
				document.getElementById('show-exercise-btn').click();
			}
		});

		// Navegación con teclado
		document.addEventListener('keydown', function(e) {
			if (e.key === 'ArrowRight' || e.key === ' ') {
				e.preventDefault();
				if (isExerciseVisible()) {
					navigateExercise(+1, true); updateNavigationArrows();
				} else {
					playSwipeSound();
					nextPage(); updateNavigationArrows();
				}
			} else if (e.key === 'ArrowLeft') {
				e.preventDefault();
				if (isExerciseVisible()) {
					navigateExercise(-1, true); updateNavigationArrows();
				} else {
					playSwipeSound();
					prevPage(); updateNavigationArrows();
				}
			}
		});
		
		// Ajustar tamaño de la imagen para caber en el área visible (entre selector superior y contador inferior)
		function adjustImageSize() {
			const img = document.getElementById('exercise-img');
			if (!img || img.style.display === 'none') return;
			// La cinta debe superponerse (overlay); no debe empujar la imagen hacia abajo
			// Por eso ignoramos la altura del menú en el cálculo de área visible
			let menuHeight = 0;
			const counter = document.getElementById('page-counter');
			const counterRect = counter.getBoundingClientRect();
			// espacio visible entre menú superior y contador inferior
			const visibleTop = menuHeight;
			const visibleBottom = Math.min(window.innerHeight, counterRect.top);
			const availableHeight = Math.max(100, visibleBottom - visibleTop);

			// Preferir ocupar todo el alto disponible en móviles y ajustar ancho proporcional
			if (window.innerWidth <= 768) {
				img.style.height = availableHeight + 'px';
				img.style.width = 'auto';
				img.style.maxWidth = '100vw';
				img.style.top = visibleTop + 'px';
				img.style.left = '50%';
				img.style.transform = 'translateX(-50%)';
			} else {
				// Desktop: ajustar al ancho de la ventana, y limitar altura al availableHeight
				img.style.width = '100vw';
				img.style.height = 'auto';
				if (img.naturalHeight && img.naturalWidth) {
					const renderedHeight = (window.innerWidth * img.naturalHeight) / img.naturalWidth;
					if (renderedHeight > availableHeight) {
						// si la altura resultante excede el espacio, bajar el scale
						img.style.height = availableHeight + 'px';
						img.style.width = 'auto';
					}
				}
				img.style.top = (visibleTop + (availableHeight/2)) + 'px';
				img.style.left = '50%';
				img.style.transform = 'translate(-50%, -50%)';
			}
		}

		window.addEventListener('resize', function() {
			adjustImageSize();
		});

		// Toggle del menú: abre/cierra como cinta de izquierda a derecha
		(function initMenuToggle(){
			const toggleBtn = document.getElementById('menu-toggle-btn');
			const wrapper = document.querySelector('.top-menu-wrapper');
			const body = document.body;
			if (!toggleBtn || !wrapper) return;

			let inactivityTimer = null;
			const INACTIVITY_MS = 15000;
			function clearInactivity(){ if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; } }
			function scheduleInactivity(){
				clearInactivity();
				if (!document.body.classList.contains('menu-open')) return;
				// No cerrar si hay foco en inputs dentro del menú
				const active = document.activeElement;
				if (active && wrapper.contains(active) && (active.tagName === 'INPUT' || active.tagName === 'BUTTON')) return;
				inactivityTimer = setTimeout(() => { setOpen(false); }, INACTIVITY_MS);
			}

			function updateToggleBtnSize(){
				try {
					const bar = document.querySelector('.top-menu');
					const rect = (bar || wrapper).getBoundingClientRect();
					if (rect && rect.height > 0) {
						// Altura igual a la barra (cinta)
						toggleBtn.style.height = Math.round(rect.height) + 'px';
						// Alinear el borde superior con el de la barra
						toggleBtn.style.top = Math.round(rect.top) + 'px';
						// Mantener el radio de borde definido por CSS (sin forzar píldora)
					}
				} catch (e) {}
			}

			function setOpen(open){
				if (open) {
					body.classList.add('menu-open');
					toggleBtn.setAttribute('aria-expanded', 'true');
				} else {
					body.classList.remove('menu-open');
					toggleBtn.setAttribute('aria-expanded', 'false');
				}
				// Sonido al abrir/cerrar menú (debounced)
				try { playButtonSound(); } catch (e) {}
				// Reajustar imagen según el espacio visible
				requestAnimationFrame(() => adjustImageSize());
				// Programar auto-ocultado si está abierto
				if (open) scheduleInactivity(); else clearInactivity();
			}

			toggleBtn.addEventListener('click', (e) => {
				e.stopPropagation();
				const isOpen = document.body.classList.contains('menu-open');
				// Período de gracia tras cerrar la modal: evita que un toque cercano la cierre
				const graceUntil = (typeof window.__menuGraceUntil === 'number') ? window.__menuGraceUntil : 0;
				const now = Date.now();
				if (isOpen && now < graceUntil) {
					// Ignorar intento de cerrar durante la gracia
					scheduleInactivity();
					return;
				}
				setOpen(!isOpen);
				updateToggleBtnSize();
			});

			// Cerrar al hacer clic fuera cuando está abierto
			document.addEventListener('click', (e) => {
				if (!document.body.classList.contains('menu-open')) return;
				// No cerrar por clics cuando la modal está visible
				const modal = document.getElementById('error-modal');
				if (modal && modal.style.display === 'flex') return;
				// Respetar período de gracia post-modal
				const graceUntil = (typeof window.__menuGraceUntil === 'number') ? window.__menuGraceUntil : 0;
				if (Date.now() < graceUntil) return;
				// No cerrar cuando el clic proviene de flechas laterales (interacción válida)
				const isSideArrow = e.target.closest && e.target.closest('.side-arrow');
				if (isSideArrow) { scheduleInactivity(); return; }
				const isInsideMenu = wrapper.contains(e.target);
				const isBtn = toggleBtn.contains(e.target);
				if (!isInsideMenu && !isBtn) setOpen(false);
				else scheduleInactivity();
			});

			// Cerrar con Escape
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape' && document.body.classList.contains('menu-open')) {
					setOpen(false);
				}
				else if (document.body.classList.contains('menu-open')) {
					// tecleo dentro con menú abierto reinicia timer
					scheduleInactivity();
				}
			});

			// Interacciones que reinician el temporizador cuando el menú está abierto
			['mousemove','touchstart','scroll'].forEach(evt => {
				document.addEventListener(evt, () => {
					if (document.body.classList.contains('menu-open')) scheduleInactivity();
				}, { passive: true });
			});
			// Inputs y botones internos
			wrapper.addEventListener('input', scheduleInactivity);
			wrapper.addEventListener('click', scheduleInactivity);

			// Sincronizar en carga y resize
			window.addEventListener('load', updateToggleBtnSize);
			window.addEventListener('resize', updateToggleBtnSize);
			// Llamada inicial
			updateToggleBtnSize();

			// Funciones globales para interactuar con el menú desde otros componentes
			try {
				window.showMenuAfterModal = function(){ setOpen(true); };
				window.__resetMenuInactivity = function(){ scheduleInactivity(); };
			} catch(e) {}
		})();

		// Intentar cargar una versión de mayor resolución si la imagen se va a escalar mucho
		function attemptHiRes(originalUrl, imgEl, displayWidth) {
			if (!originalUrl) return;
			// construir variantes comunes de alta resolución
			const variants = [];
			// ejemplo: image.png -> image@2x.png, image_2x.png, image-2x.png
			const m = originalUrl.match(/(.+)\.(png|jpe?g)$/i);
			if (!m) return;
			const prefix = m[1];
			const ext = m[2];
			variants.push(`${prefix}@2x.${ext}`);
			variants.push(`${prefix}_2x.${ext}`);
			variants.push(`${prefix}-2x.${ext}`);

			// si la imagen naturalWidth es menor que el displayWidth, intentar hi-res
			if (imgEl.naturalWidth && imgEl.naturalWidth < displayWidth * 1.5) {
				( async function tryVariants() {
					for (const v of variants) {
						try {
							await new Promise((res, rej) => {
								const p = new Image();
								p.onload = () => res(p);
								p.onerror = () => rej();
								p.src = v;
							});
							// si existe, usar srcset para permitir browser seleccionar mejor
							imgEl.srcset = `${v} 2x, ${originalUrl} 1x`;
							imgEl.src = v; // forzar reemplazo inmediato
							return;
						} catch (e) {
							// ignora y prueba siguiente
						}
					}
				})();
			}
		}

		// Bloquear scroll (excepto durante gestos de swipe)
		document.addEventListener('wheel', function(e) {
			e.preventDefault();
		}, { passive: false });
		
		document.addEventListener('touchmove', function(e) {
			// Permitir touchmove durante gestos de swipe
			if (isSwipeGesture) return;
			e.preventDefault();
		}, { passive: false });

		// Gestión de gestos táctiles para navegación en móvil
		let touchStartX = 0;
		let touchStartY = 0;
		let touchStartTime = 0;
		let isSwipeGesture = false;
		let activeIndicator = null;
		const SWIPE_THRESHOLD = 20; // ULTRA SENSIBLE: mínima distancia para considerar swipe
		const SWIPE_VELOCITY_THRESHOLD = 0.1; // ULTRA SENSIBLE: mínima velocidad
		const EDGE_ZONE_WIDTH = 100; // MÁXIMA ZONA: ancho de zona lateral para iniciar swipe (px)
		const MAX_VERTICAL_DRIFT = 200; // MÁXIMA TOLERANCIA: máxima desviación vertical permitida

		// Detectar inicio del gesto táctil
		document.addEventListener('touchstart', function(e) {
			if (e.touches.length !== 1) return; // solo gestos de un dedo
			
			const touch = e.touches[0];
			const screenWidth = window.innerWidth;
			
			// Solo permitir inicio desde las zonas laterales
			const isLeftEdge = touch.clientX <= EDGE_ZONE_WIDTH;
			const isRightEdge = touch.clientX >= (screenWidth - EDGE_ZONE_WIDTH);
			
			if (!isLeftEdge && !isRightEdge) return;
			
			touchStartX = touch.clientX;
			touchStartY = touch.clientY;
			touchStartTime = Date.now();
			isSwipeGesture = true;
			
			// Activar indicador visual
			const leftIndicator = document.getElementById('swipe-indicator-left');
			const rightIndicator = document.getElementById('swipe-indicator-right');
			
			if (isLeftEdge && leftIndicator) {
				leftIndicator.classList.add('active');
				activeIndicator = leftIndicator;
			} else if (isRightEdge && rightIndicator) {
				rightIndicator.classList.add('active');
				activeIndicator = rightIndicator;
			}
		}, { passive: true });

		// Procesar el movimiento táctil
		document.addEventListener('touchmove', function(e) {
			if (!isSwipeGesture || e.touches.length !== 1) return;
			
			const touch = e.touches[0];
			const deltaX = touch.clientX - touchStartX;
			const deltaY = touch.clientY - touchStartY;
			
			// Cancelar si hay mucha desviación vertical
			if (Math.abs(deltaY) > MAX_VERTICAL_DRIFT) {
				isSwipeGesture = false;
				if (activeIndicator) {
					activeIndicator.classList.remove('active');
					activeIndicator = null;
				}
				return;
			}
			
			// Prevenir scroll durante el swipe
			e.preventDefault();
		}, { passive: false });

		// Finalizar el gesto y ejecutar navegación
		document.addEventListener('touchend', function(e) {
			// Limpiar indicador visual
			if (activeIndicator) {
				activeIndicator.classList.remove('active');
				activeIndicator = null;
			}
			
			if (!isSwipeGesture) return;
			
			const touch = e.changedTouches[0];
			const deltaX = touch.clientX - touchStartX;
			const deltaY = touch.clientY - touchStartY;
			const deltaTime = Date.now() - touchStartTime;
			const velocity = deltaTime > 0 ? Math.abs(deltaX) / deltaTime : 0;
			
			isSwipeGesture = false;
			
			// Verificar si cumple los requisitos de swipe (ULTRA SENSIBLES)
			if (Math.abs(deltaX) < SWIPE_THRESHOLD) return;
			if (Math.abs(deltaY) > MAX_VERTICAL_DRIFT) return;
			// REMOVIDO: el requerimiento de velocidad mínima para máxima sensibilidad
			
			// Determinar dirección y navegar
			if (deltaX > 0) {
				// Swipe derecha → página anterior
				if (isExerciseVisible()) {
					navigateExercise(-1, true);
				} else if (currentPage > 1) {
					// Usar el sonido específico para swipes
					isPaging = true;
					animatePage('left');
					playSwipeSound();
					try { if (document.body.classList.contains('menu-open')) { window.__resetMenuInactivity && window.__resetMenuInactivity(); } } catch(e) {}
					setTimeout(() => { 
						prevPage(); 
						isPaging = false; 
						updateNavigationArrows(); 
					}, 220);
				}
			} else {
				// Swipe izquierda → página siguiente
				if (isExerciseVisible()) {
					navigateExercise(+1, true);
				} else if (currentPage < totalPages) {
					// Usar el sonido específico para swipes
					isPaging = true;
					animatePage('right');
					playSwipeSound();
					try { if (document.body.classList.contains('menu-open')) { window.__resetMenuInactivity && window.__resetMenuInactivity(); } } catch(e) {}
					setTimeout(() => { 
						nextPage(); 
						isPaging = false; 
						updateNavigationArrows(); 
					}, 220);
				}
			}
		}, { passive: true });
		
		// Ocultar controles automáticamente
		let hideControlsTimeout;
		
		function showControls() {
			const controls = document.querySelector('.floating-controls');
			const pageCounter = document.querySelector('.page-counter');
			if (controls) controls.style.opacity = '1';
			if (pageCounter) pageCounter.style.opacity = '1';
			clearTimeout(hideControlsTimeout);
			hideControlsTimeout = setTimeout(() => {
				if (controls) controls.style.opacity = '0.3';
				if (pageCounter) pageCounter.style.opacity = '0.3';
			}, 3000);
		}
		
		document.addEventListener('mousemove', showControls);
		document.addEventListener('touchstart', showControls);
		
		// Cargar PDF y restaurar estado previo
		pdfjsLib.getDocument(urlDefault).promise.then(function(pdfDoc_) {
			pdfDoc = pdfDoc_;
			totalPages = pdfDoc.numPages;
			
			// Verificar estado guardado ANTES de renderizar
			const savedState = getUserState();
			let shouldRenderPDF = true;
			
			if (savedState) {
				if (savedState.type === 'exercise') {
					// Si había un ejercicio, no renderizar PDF y mostrar ejercicio directamente
					shouldRenderPDF = false;
					const exerciseNum = savedState.data.exerciseNumber;
					document.getElementById('exercise-input').value = exerciseNum;
					// Ocultar PDF completamente
					const pdfCanvas = document.getElementById('pdf-canvas');
					pdfCanvas.style.display = 'none';
					// Mostrar ejercicio inmediatamente
					showImageByNumber(exerciseNum, { suppressError: true });
					showControls();
					
					// Marcar como cargado en móvil para ejercicios
					if (isMobile) {
						setTimeout(() => {
							const container = document.querySelector('.pdf-viewer-container');
							if (container) container.classList.add('loaded');
							document.body.classList.add('mobile-loaded');
						}, 300);
					}
					
					return; // No continuar con renderización de PDF
				} else if (savedState.type === 'pdf') {
					currentPage = savedState.data.page || 1;
				}
			}
			
			// Solo renderizar PDF si es necesario
			if (shouldRenderPDF) {
				renderPage(currentPage);
				showControls();
			}
			
			// Marcar como completamente cargado en móvil
			if (isMobile) {
				setTimeout(() => {
					const container = document.querySelector('.pdf-viewer-container');
					if (container) container.classList.add('loaded');
					document.body.classList.add('mobile-loaded');
				}, 500); // Medio segundo después de la carga para asegurar estabilidad
			}
		}).catch(function(error) {
			console.error('Error cargando PDF:', error);
			const loading = document.getElementById('loading');
			loading.style.display = 'block';
			loading.textContent = 'Error: No se pudo cargar el PDF';
			
			// También marcar como cargado en caso de error para que se vea el error
			if (isMobile) {
				setTimeout(() => {
					const container = document.querySelector('.pdf-viewer-container');
					if (container) container.classList.add('loaded');
					document.body.classList.add('mobile-loaded');
				}, 100);
			}
		});
		
		// Redimensionar al cambiar tamaño de ventana
		window.addEventListener('resize', function() {
			if (!pdfDoc) return;
			// Si el teclado no está abierto, actualizamos el stableViewport
			if (!keyboardOpen) {
				stableViewport.width = window.innerWidth;
				stableViewport.height = window.innerHeight;
				renderPage(currentPage);
			} else {
				// Ignorar resize intermedios provocados por el teclado
			}
		});

		// Detección de teclado móvil usando visualViewport (cuando disponible)
		(function setupKeyboardDetection(){
			const vv = window.visualViewport;
			if (!vv) return; // Fallback: no soportado, no hacemos nada
			const THRESHOLD = 120; // px de reducción de altura para considerar teclado abierto
			let lastHeight = vv.height;
			function check(e){
				const delta = stableViewport.height - vv.height;
				if (!keyboardOpen && delta > THRESHOLD) {
					keyboardOpen = true;
					// Guardar viewport estable antes del teclado
					stableViewport.width = window.innerWidth;
					stableViewport.height = window.innerHeight;
				}
				else if (keyboardOpen && (stableViewport.height - vv.height) <= THRESHOLD) {
					// Teclado cerrándose
					keyboardOpen = false;
					// Actualizar viewport estable y re-render si había pendiente
					stableViewport.width = window.innerWidth;
					stableViewport.height = window.innerHeight;
					if (pendingKeyboardCloseRender) {
						pendingKeyboardCloseRender = false;
						setTimeout(() => { try { renderPage(currentPage); } catch(e) {} }, 40);
					}
				}
				lastHeight = vv.height;
			}
			vv.addEventListener('resize', check);
			vv.addEventListener('scroll', check); // algunos navegadores disparan scroll interno
		})();

		// Focus/blur directo en los inputs como respaldo (por si visualViewport falla)
		['exercise-input','page-input'].forEach(id => {
			const el = document.getElementById(id);
			if (!el) return;
			el.addEventListener('focus', () => {
				// Guardar viewport actual antes de potencial teclado
				stableViewport.width = window.innerWidth;
				stableViewport.height = window.innerHeight;
				keyboardOpen = true;
			});
			el.addEventListener('blur', () => {
				// Esperar un tick para que cierre realmente
				setTimeout(() => {
					keyboardOpen = false;
					stableViewport.width = window.innerWidth;
					stableViewport.height = window.innerHeight;
					if (pendingKeyboardCloseRender) {
						pendingKeyboardCloseRender = false;
						try { renderPage(currentPage); } catch(e) {}
					}
				}, 120);
			});
		});

		// Funciones para la modal elegante de errores
		function showErrorModal(title, message) {
			const modal = document.getElementById('error-modal');
			const content = modal.querySelector('.error-modal-content');
			modal.querySelector('.error-title').textContent = title + ' no disponible';
			modal.querySelector('.error-message').textContent = message;
			modal.style.display = 'flex';
			// Reposicionar si teclado abierto en móvil
			adjustErrorModalPosition();
		}

		function adjustErrorModalPosition(){
			const modal = document.getElementById('error-modal');
			if (modal.style.display !== 'flex') return;
			const content = modal.querySelector('.error-modal-content');
			if (!content) return;
			// Reset
			content.style.marginTop = '';
			content.style.transformOrigin = '';
			// Si teclado abierto, subir el modal
			if (keyboardOpen) {
				try {
					const vv = window.visualViewport;
					let visibleHeight = vv ? vv.height : window.innerHeight;
					// Subir un porcentaje de la diferencia
					const diff = window.innerHeight - visibleHeight; // espacio ocupado por teclado
					if (diff > 80) { // umbral mínimo
						// Movemos el contenido hacia arriba proporcionalmente (60% del teclado)
						const shift = Math.min(diff * 0.6, visibleHeight * 0.35);
						content.style.marginTop = '-' + Math.round(shift) + 'px';
						content.style.transformOrigin = 'center bottom';
					}
				} catch(e) {}
			}
		}

		// Escuchar cambios del visualViewport mientras la modal esté abierta
		(function observeViewportForModal(){
			const vv = window.visualViewport;
			if (!vv) return;
			['resize','scroll'].forEach(evt => vv.addEventListener(evt, () => adjustErrorModalPosition()));
		})();

		let isClosingModal = false;
		function closeErrorModal() {
			if (isClosingModal) return; // evitar reentradas
			isClosingModal = true;
			const modal = document.getElementById('error-modal');
			const modalContent = modal.querySelector('.error-modal-content');
			// Limpiar ajustes de posición previos
			modalContent.style.marginTop = '';
			modalContent.style.transformOrigin = '';
			
			// Animación elegante: zoom out + fade
			modalContent.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease';
			modalContent.style.transform = 'translateY(0) scale(0.9)';
			modalContent.style.opacity = '0';
			
			// Fade del fondo
			modal.style.transition = 'opacity 0.4s ease';
			modal.style.opacity = '0';
			
			setTimeout(() => {
				modal.style.display = 'none';
				modal.style.opacity = '1';
				modalContent.style.transform = 'translateY(0) scale(1)';
				modalContent.style.opacity = '1';
				modalContent.style.transition = '';
				modal.style.transition = '';
				
				// Si ya hay un ejercicio visible detrás del modal, no recargar; solo cerrar
				const exerciseImgEl = document.getElementById('exercise-img');
				if (exerciseImgEl && exerciseImgEl.style.display !== 'none') {
					// Mostrar la cinta y arrancar su temporizador (15s) desde este momento
					try { if (typeof window.showMenuAfterModal === 'function') window.showMenuAfterModal(); } catch(e) {}
					isClosingModal = false;
					return;
				}

				// Preferir volver al último ejercicio válido; si no, restaurar estado general
				const last = getLastValidExercise();
				if (last) {
					// Solo reproducir sonido si efectivamente vamos a cambiar a un ejercicio (no estamos ya en él)
					playButtonSound();
					showImageByNumber(last, { suppressError: true, onFail: () => restoreUserState() });
				} else {
					// También reproducir si vamos a restaurar el PDF u otro estado
					playButtonSound();
					restoreUserState();
				}
				// Mostrar la cinta y arrancar su temporizador (15s) desde este momento
				try {
					if (typeof window.showMenuAfterModal === 'function') window.showMenuAfterModal();
					// Establecer período de gracia para evitar cierre inmediato por toque contiguo
					window.__menuGraceUntil = Date.now() + 600; // 600ms
				} catch(e) {}
				isClosingModal = false;
			}, 400);
		}

		// Cerrar modal con Escape
		document.addEventListener('keydown', function(e) {
			if (e.key === 'Escape' && document.getElementById('error-modal').style.display === 'flex') {
				closeErrorModal();
			}
		});

	function enableClickToClear(input){
  if(!input) return;
  let lastValue = input.value;  // valor previo
  let wasCleared = false;       // se vació en este foco
  let changed = false;          // el usuario escribió/cambió algo

  input.addEventListener('focusin', () => {
    lastValue = input.value;
    wasCleared = false;
    changed = false;
  });

  input.addEventListener('pointerdown', (e) => {
    const r = input.getBoundingClientRect();
    const spinnerZone = 26; // ancho aprox. de las flechas
    const onSpinner = e.clientX > (r.right - spinnerZone);
    if (onSpinner) return; // no borrar si se toca el spinner
    requestAnimationFrame(() => {
      if (document.activeElement !== input) input.focus();
      lastValue = input.value;
      input.value = '';     // borrar
      wasCleared = true;
      changed = false;
    });
  });

  // Si escribe o usa las flechas, marcamos como cambiado
  input.addEventListener('input', () => { if (wasCleared) changed = true; });

  // Si sale sin cambiar, restaurar
  input.addEventListener('blur', () => {
    if (wasCleared && !changed) {
      input.value = lastValue;
    }
    wasCleared = false;
    changed = false;
  });

  // Exponer el último valor para uso en Enter
  input.__getLastValue = () => lastValue;
}

// Enter en input de página → si está vacío, reponer y ejecutar
document.getElementById('page-input').addEventListener('keypress', function(e) {
  if (e.key === 'Enter') {
    e.preventDefault();
    if (this.value === '' && typeof this.__getLastValue === 'function') {
      this.value = this.__getLastValue();
    }
    document.getElementById('goto-page-btn').click();
  }
});

// Enter en input de ejercicio → si está vacío, reponer y ejecutar
document.getElementById('exercise-input').addEventListener('keypress', function(e) {
  if (e.key === 'Enter') {
    e.preventDefault();
    if (this.value === '' && typeof this.__getLastValue === 'function') {
      this.value = this.__getLastValue();
    }
    document.getElementById('show-exercise-btn').click();
  }
});

// Activar en ambos inputs
enableClickToClear(document.getElementById('exercise-input'));
enableClickToClear(document.getElementById('page-input'));	
	</script>
</body>
</html>
